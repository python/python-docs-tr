# Python Documentation Turkish Translation
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 22:33+0300\n"
"PO-Revision-Date: 2024-02-10 15:42+0300\n"
"Last-Translator: \n"
"Language-Team: TURKISH <python.docs.tr@gmail.com>\n"
"Language: tr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.3.2\n"

#: library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Gömülü Türler"

#: library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"Aşağıdaki bölümlerde, yorumlayıcıda yerleşik olarak yer alan standart türler "
"açıklanmaktadır."

#: library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"Başlıca gömülü türler sayısallar, diziler, eşleşmeler, sınıflar, örnekler ve "
"kural dışı durumlardır."

#: library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never return "
"the collection instance itself but ``None``."
msgstr ""
"Bazı koleksiyon sınıfları değişebilirdir.  Üyelerini yerinde ekleyen, çıkaran "
"veya yeniden düzenleyen ve belirli bir öğe döndürmeyen metotlar, her zaman "
"koleksiyon örneğini değil ``None`` değerini döndürür."

#: library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth value, "
"and converted to a string (with the :func:`repr` function or the slightly "
"different :func:`str` function).  The latter function is implicitly used when an "
"object is written by the :func:`print` function."
msgstr ""
"Bazı işlemler birkaç nesne türü tarafından desteklenir; özellikle, tüm nesneler "
"eşitlik için karşılaştırılabilir, doğruluk değeri için test edilebilir ve bir "
"dizeye dönüştürülebilir (:func:`repr` fonksiyonu veya hafif farklı olan :func:"
"`str` fonksiyonu ile).  İkinci fonksiyon, bir nesne :func:`print` ile "
"yazdırıldığında dolaylı olarak kullanılır."

#: library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Doğruluk Değeri Testi"

#: library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Herhangi bir nesne, :keyword:`if` veya :keyword:`while` koşulunda veya aşağıdaki "
"Boolean işlemlerinin işleneni olarak kullanımında doğruluk değeri için test "
"edilebilir."

#: library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :meth:"
"`~object.__bool__` method that returns ``False`` or a :meth:`__len__` method "
"that returns zero, when called with the object. [1]_  Here are most of the built-"
"in objects considered false:"
msgstr ""
"Varsayılan olarak, bir nesne, sınıfı \"False\" döndüren bir :meth:`__bool__` "
"metodunu veya nesneyle birlikte çağrıldığında sıfır döndüren bir :meth:`__len__` "
"metodunu tanımlamadıkça doğru kabul edilir. [1]_ Yanlış olarak kabul edilen "
"yerleşik nesnelerin çoğu:"

#: library/stdtypes.rst:55
msgid "constants defined to be false: ``None`` and ``False``"
msgstr "false olarak tanımlanan sabitler: ``None`` ve ``False``"

#: library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, ``Fraction(0, "
"1)``"
msgstr ""
"herhangi bir sayısal türden sıfır: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"

#: library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"boş diziler ve koleksiyonlar: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"

#: library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always return ``0`` "
"or ``False`` for false and ``1`` or ``True`` for true, unless otherwise stated. "
"(Important exception: the Boolean operations ``or`` and ``and`` always return "
"one of their operands.)"
msgstr ""
"Boolean sonucu olan işlemler ve gömülü fonksiyonlar, aksi belirtilmedikçe her "
"zaman false için \"0\" veya \"False\" ve true için \"1\" veya \"True\" döndürür. "
"(Önemli istisna: Boolean işlemleri \"or\" ve \"and\" her zaman işlenenlerinden "
"birini döndürür.)"

#: library/stdtypes.rst:78
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr "Boolean İşlemleri --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "Bunlar artan önceliğe göre sıralanmış Boolean işlemleridir:"

#: library/stdtypes.rst:143 library/stdtypes.rst:365 library/stdtypes.rst:963
#: library/stdtypes.rst:1168
msgid "Operation"
msgstr "İşlem"

#: library/stdtypes.rst:275 library/stdtypes.rst:415 library/stdtypes.rst:1168
msgid "Result"
msgstr "Sonuç"

#: library/stdtypes.rst:275 library/stdtypes.rst:963 library/stdtypes.rst:2418
#: library/stdtypes.rst:3636
msgid "Notes"
msgstr "Notlar"

#: library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: library/stdtypes.rst:87
msgid "if *x* is true, then *x*, else *y*"
msgstr "*x* doğruysa, *x*, aksi halde *y*"

#: library/stdtypes.rst:965 library/stdtypes.rst:1179 library/stdtypes.rst:3642
msgid "\\(1)"
msgstr "\\(1)"

#: library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "*x* yanlışsa, *x*, aksi halde *y*"

#: library/stdtypes.rst:288 library/stdtypes.rst:1207 library/stdtypes.rst:2430
#: library/stdtypes.rst:3648
msgid "\\(2)"
msgstr "\\(2)"

#: library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "*x* yanlışsa, ``True``, aksi halde ``False``"

#: library/stdtypes.rst:977 library/stdtypes.rst:2432 library/stdtypes.rst:2436
#: library/stdtypes.rst:3650 library/stdtypes.rst:3654 library/stdtypes.rst:3656
msgid "\\(3)"
msgstr "\\(3)"

#: library/stdtypes.rst:319 library/stdtypes.rst:1014 library/stdtypes.rst:2464
#: library/stdtypes.rst:3686
msgid "Notes:"
msgstr "Notlar:"

#: library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument if "
"the first one is false."
msgstr ""
"Bu bir kısa devre operatörüdür, bu nedenle ikinci argümanı yalnızca birincisi "
"yanlışsa değerlendirir."

#: library/stdtypes.rst:109
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument if "
"the first one is true."
msgstr ""
"Bu bir kısa devre operatörüdür, bu nedenle sadece ilki doğruysa ikinci argümanı "
"değerlendirir."

#: library/stdtypes.rst:113
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` is "
"interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` Boolean olmayan operatörlerden daha düşük bir önceliğe sahiptir, bu "
"nedenle ``not a == b``, ``not (a == b)`` olarak yorumlanır bu sebeple ``a == not "
"b`` bir söz dizimi hatasıdır."

#: library/stdtypes.rst:120
msgid "Comparisons"
msgstr "Karşılaştırmalar"

#: library/stdtypes.rst:134
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons can "
"be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x < y and "
"y <= z``, except that *y* is evaluated only once (but in both cases *z* is not "
"evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Python'da sekiz karşılaştırma işlemi vardır.  Hepsinin önceliği aynıdır (Boolean "
"işlemlerinden daha önceliklidir).  Karşılaştırmalar isteğe bağlı olarak "
"zincirlenebilir; örneğin, ``x < y <= z``, ``x < y and y <= z`` ile eş değerdir, "
"ancak *y* yalnızca bir kez değerlendirilir (ancak her iki durumda da ``x < y`` "
"yanlış olduğu tespit edildiğinde *z* hiç değerlendirilmez)."

#: library/stdtypes.rst:140
msgid "This table summarizes the comparison operations:"
msgstr "Bu tablo karşılaştırma operatörlerini özetlemektedir:"

#: library/stdtypes.rst:2395 library/stdtypes.rst:3613 library/stdtypes.rst:3636
msgid "Meaning"
msgstr "Anlamı"

#: library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: library/stdtypes.rst:145
msgid "strictly less than"
msgstr "kesinlikle daha az"

#: library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: library/stdtypes.rst:147
msgid "less than or equal"
msgstr "daha az veya eşit"

#: library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "kesinlikle daha büyük"

#: library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "daha büyük veya eşit"

#: library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: library/stdtypes.rst:153
msgid "equal"
msgstr "eşit"

#: library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: library/stdtypes.rst:155
msgid "not equal"
msgstr "eşit değil"

#: library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: library/stdtypes.rst:157
msgid "object identity"
msgstr "nesne kimliği"

#: library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: library/stdtypes.rst:159
msgid "negated object identity"
msgstr "olumsuz nesne kimliği"

#: library/stdtypes.rst:166
msgid ""
"Objects of different types, except different numeric types, never compare equal. "
"The ``==`` operator is always defined but for some object types (for example, "
"class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, ``>`` and "
"``>=`` operators are only defined where they make sense; for example, they raise "
"a :exc:`TypeError` exception when one of the arguments is a complex number."
msgstr ""
"Farklı sayısal türler dışında, farklı türdeki nesneler hiçbir zaman eşit olarak "
"karşılaştırılmaz. ``==`` operatörü her zaman tanımlanır, ancak bazı nesne "
"türleri için (örneğin, sınıf nesneleri) :keyword:`is` ile eş değerdir. ``<``, "
"``<=``, ``>`` ve ``>=`` operatörleri yalnızca anlamlı oldukları yerde "
"tanımlanır; örneğin, argümanlardan biri karmaşık bir sayı olduğunda bir :exc:"
"`TypeError` hatası oluştururlar."

#: library/stdtypes.rst:180
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr ""
"Normalde, bir sınıfın özdeş olmayan örnekleri, sınıf :meth:`~object.__eq__` "
"metodunu tanımlamadığı sürece eşit olmayan olarak karşılaştırılır."

#: library/stdtypes.rst:183
msgid ""
"Instances of a class cannot be ordered with respect to other instances of the "
"same class, or other types of object, unless the class defines enough of the "
"methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object.__gt__`, "
"and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :meth:"
"`~object.__eq__` are sufficient, if you want the conventional meanings of the "
"comparison operators)."
msgstr ""
"Bir sınıfın örnekleri, sınıf yeterli metotları tanımlamadıkça, aynı sınıfın "
"diğer örneklerine veya diğer nesne türlerine göre sıralanamaz :meth:`~object."
"__lt__`, :meth:`~object.__le__` , :meth:`~object.__gt__` ve :meth:`~object."
"__ge__` (karşılaştırma operatörlerin geleneksel anlamlarını istiyorsanız, :meth:"
"`~object.__lt__` ve :meth:`~object.__eq__` genellikle yeterli olacaktır)."

#: library/stdtypes.rst:190
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
":keyword:`is` ve :keyword:`is not` operatörlerinin davranışı özelleştirilemez; "
"ayrıca herhangi iki nesneye uygulanabilirler ve asla bir hata oluşturmazlar."

#: library/stdtypes.rst:198
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :keyword:"
"`not in`, are supported by types that are :term:`iterable` or implement the :"
"meth:`__contains__` method."
msgstr ""
"Aynı söz dizimsel önceliğe sahip iki işlem daha, :keyword:`in` ve :keyword:`not "
"in`, :term:`iterable` olan veya :meth:`__contains__` metodunu uygulayan türler "
"tarafından desteklenir."

#: library/stdtypes.rst:205
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Sayısal Türler --- :class:`int`, :class:`float`, :class:`complex`"

#: library/stdtypes.rst:215
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating point "
"numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a subtype of "
"integers.  Integers have unlimited precision.  Floating point numbers are "
"usually implemented using :c:expr:`double` in C; information about the precision "
"and internal representation of floating point numbers for the machine on which "
"your program is running is available in :data:`sys.float_info`.  Complex numbers "
"have a real and imaginary part, which are each a floating point number.  To "
"extract these parts from a complex number *z*, use ``z.real`` and ``z.imag``. "
"(The standard library includes the additional numeric types :mod:`fractions."
"Fraction`, for rationals, and :mod:`decimal.Decimal`, for floating-point numbers "
"with user-definable precision.)"
msgstr ""
"Üç farklı sayısal tür vardır: :dfn:`integers`, :dfn:`floating point numbers`, "
"ve :dfn:`complex numbers`.  Ayrıca, Booleanlar tam sayıların bir alt türüdür.  "
"Tam sayıların kesinliği sınırsızdır.  Gerçel sayılar genellikle C dilinde :c:"
"expr:`double` kullanılarak uygulanır; programınızın çalıştığı makine için gerçel "
"sayıların kesinliği ve dahili gösterimi hakkında bilgi :data:`sys.float_info` "
"içinde mevcuttur.  Karmaşık sayıların her biri bir gerçel sayı olan gerçek ve "
"sanal birer kısımları vardır. Bu parçaları *z* karmaşık sayısından ayıklamak "
"için ``z.real`` ve ``z.imag`` kullanın. (Standart kütüphane, rasyonel sayılar "
"için :mod:`fractions.Fraction` ve kullanıcı tarafından tanımlanabilen "
"hassasiyete sahip gerçel sayılar için :mod:`decimal.Decimal` ek sayısal "
"türlerini içerir.)"

#: library/stdtypes.rst:237
msgid ""
"Numbers are created by numeric literals or as the result of built-in functions "
"and operators.  Unadorned integer literals (including hex, octal and binary "
"numbers) yield integers.  Numeric literals containing a decimal point or an "
"exponent sign yield floating point numbers.  Appending ``'j'`` or ``'J'`` to a "
"numeric literal yields an imaginary number (a complex number with a zero real "
"part) which you can add to an integer or float to get a complex number with real "
"and imaginary parts."
msgstr ""
"Sayılar, sayısal değişmezlerle veya, gömülü fonksiyonlar ve operatörlerin sonucu "
"olarak oluşturulur.  Sade tam sayı değişmezleri (onaltılı, sekizli ve ikili "
"sayılar dahil) tam sayıları verir.  Ondalık nokta veya üs işareti içeren sayısal "
"değişmezler, gerçel sayıları verir.  Sayısal bir değişmeze ``'j'`` veya ``'J'`` "
"eklemek, tam veya gerçel bir sayıya eklenince gerçek ve hayali kısımları olan "
"bir karmaşık sayı ortaya çıkaran, hayali bir sayı üretir."

#: library/stdtypes.rst:262
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator has "
"operands of different numeric types, the operand with the \"narrower\" type is "
"widened to that of the other, where integer is narrower than floating point, "
"which is narrower than complex. A comparison between numbers of different types "
"behaves as though the exact values of those numbers were being compared. [2]_"
msgstr ""
"Python karma aritmetiği tam olarak destekler: herhangi bir ikili aritmetik "
"operatörü farklı sayısal türlerde işlenenlere sahip olduğunda, \"dar\" türe "
"sahip işlenen, tam sayı karmaşık sayıdan daha dar olan gerçel sayıdan daha dar "
"olduğu diğerininkine genişletilir. Farklı türlerdeki sayıların "
"karşılaştırılması, bu sayıların tam değerleri karşılaştırılıyormuş gibi "
"davranır. [2]_"

#: library/stdtypes.rst:268
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used to "
"produce numbers of a specific type."
msgstr ""
":func:`int`, :func:`float` ve :func:`complex` yapıcıları belirli bir türde "
"sayılar üretmek için kullanılabilir."

#: library/stdtypes.rst:271
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"Tüm sayısal türler (karmaşık sayılar hariç) aşağıdaki işlemleri destekler "
"(işlemlerin öncelikleri için bkz. :ref:`operator-summary`):"

#: library/stdtypes.rst:275
msgid "Full documentation"
msgstr "Tam dokümantasyon"

#: library/stdtypes.rst:277
msgid "``x + y``"
msgstr "``x + y``"

#: library/stdtypes.rst:277
msgid "sum of *x* and *y*"
msgstr "*x* ve *y* 'nin toplamı"

#: library/stdtypes.rst:279
msgid "``x - y``"
msgstr "``x - y``"

#: library/stdtypes.rst:279
msgid "difference of *x* and *y*"
msgstr "*x* ve *y* 'nin farkı"

#: library/stdtypes.rst:281
msgid "``x * y``"
msgstr "``x * y``"

#: library/stdtypes.rst:281
msgid "product of *x* and *y*"
msgstr "*x* ve *y* 'nin çarpımı"

#: library/stdtypes.rst:283
msgid "``x / y``"
msgstr "``x / y``"

#: library/stdtypes.rst:283
msgid "quotient of *x* and *y*"
msgstr "*x* 'in *y* 'ye bölümü"

#: library/stdtypes.rst:285
msgid "``x // y``"
msgstr "``x // y``"

#: library/stdtypes.rst:285
msgid "floored quotient of *x* and *y*"
msgstr "*x* ve *y* 'nin kat bölümü"

#: library/stdtypes.rst:285
msgid "\\(1)\\(2)"
msgstr "\\(1)\\(2)"

#: library/stdtypes.rst:288
msgid "``x % y``"
msgstr "``x % y``"

#: library/stdtypes.rst:288
msgid "remainder of ``x / y``"
msgstr "``x / y`` işleminde kalan"

#: library/stdtypes.rst:290
msgid "``-x``"
msgstr "``-x``"

#: library/stdtypes.rst:290
msgid "*x* negated"
msgstr "*x* 'in negatifi"

#: library/stdtypes.rst:292
msgid "``+x``"
msgstr "``+x``"

#: library/stdtypes.rst:292
msgid "*x* unchanged"
msgstr "*x* 'in değişmemişi"

#: library/stdtypes.rst:294
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: library/stdtypes.rst:294
msgid "absolute value or magnitude of *x*"
msgstr "*x* 'in mutlak değeri"

#: library/stdtypes.rst:294
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: library/stdtypes.rst:297
msgid "``int(x)``"
msgstr "``int(x)``"

#: library/stdtypes.rst:297
msgid "*x* converted to integer"
msgstr "*x* 'in integer tam sayıya (integer) dönüştürülmüş hali"

#: library/stdtypes.rst:297
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: library/stdtypes.rst:297
msgid ":func:`int`"
msgstr ":func:`int`"

#: library/stdtypes.rst:299
msgid "``float(x)``"
msgstr "``float(x)``"

#: library/stdtypes.rst:299
msgid "*x* converted to floating point"
msgstr "*x* 'in gerçel sayıya (float) dönüştürülmüş hali"

#: library/stdtypes.rst:299
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: library/stdtypes.rst:299
msgid ":func:`float`"
msgstr ":func:`float`"

#: library/stdtypes.rst:301
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: library/stdtypes.rst:301
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to zero."
msgstr ""
"gerçek kısmı *re*, sanal kısmı *im* olan bir karmaşık sayı. *im* varsayılan "
"olarak sıfırdır."

#: library/stdtypes.rst:1200 library/stdtypes.rst:3673
msgid "\\(6)"
msgstr "\\(6)"

#: library/stdtypes.rst:301
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: library/stdtypes.rst:305
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: library/stdtypes.rst:305
msgid "conjugate of the complex number *c*"
msgstr "*c* karmaşık sayısının eşleniği"

#: library/stdtypes.rst:308
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: library/stdtypes.rst:308
msgid "the pair ``(x // y, x % y)``"
msgstr "``(x // y, x % y)`` ifadesinin ikilisi"

#: library/stdtypes.rst:308
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: library/stdtypes.rst:310
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: library/stdtypes.rst:312
msgid "*x* to the power *y*"
msgstr "*x* üzeri *y*"

#: library/stdtypes.rst:312 library/stdtypes.rst:1192 library/stdtypes.rst:2454
#: library/stdtypes.rst:3669 library/stdtypes.rst:3676
msgid "\\(5)"
msgstr "\\(5)"

#: library/stdtypes.rst:310
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: library/stdtypes.rst:312
msgid "``x ** y``"
msgstr "``x ** y``"

#: library/stdtypes.rst:322
msgid ""
"Also referred to as integer division.  For operands of type :class:`int`, the "
"result has type :class:`int`.  For operands of type :class:`float`, the result "
"has type :class:`float`.  In general, the result is a whole integer, though the "
"result's type is not necessarily :class:`int`.  The result is always rounded "
"towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is ``-1``, ``1//(-2)`` is "
"``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"Tamsayılı bölme olarak da adlandırılır. :class:`int` türündeki işlenenler için "
"sonuç, :class:`int` türüne sahiptir. :class:`float` tipindeki işlenenler için "
"sonuç :class:`float` tipine sahiptir. Genel olarak sonuç bir tam sayıdır, ancak "
"sonucun türünün mutlaka :class:`int` olması gerekmez. Sonuç her zaman eksi "
"sonsuza yuvarlanır: ``1//2`` ``0``, ``(-1)//2`` ``-1``, ``1//(- 2)``,``-1`` ve "
"``(-1)//(-2)``,``0``."

#: library/stdtypes.rst:330
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Karmaşık sayılar için değil.  Bunun yerine uygunsa :func:`abs` kullanarak gerçel "
"sayılara dönüştürün."

#: library/stdtypes.rst:341
msgid ""
"Conversion from :class:`float` to :class:`int` truncates, discarding the "
"fractional part. See functions :func:`math.floor` and :func:`math.ceil` for "
"alternative conversions."
msgstr ""
":class:`float`tan :class:`int`e dönüştürme kesirli kısmı atarak keser. "
"Alternatif dönüşümler için :func:`math.floor` ve :func:`math.ceil` işlevlerine "
"bakın."

#: library/stdtypes.rst:346
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix \"+\" "
"or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"float ayrıca \"nan\" ve \"inf\" dizelerini, Sayı Değil ( Not a Number -> NaN) ve "
"pozitif veya negatif sonsuzluk için isteğe bağlı bir \"+\" veya \"-\" ön ekiyle "
"kabul eder."

#: library/stdtypes.rst:350
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python, diğer programlama dillerinde de olduğu gibi ``pow(0, 0)`` = ``1`` ve ``0 "
"** 0`` = ``1`` şeklinde tanımlar."

#: library/stdtypes.rst:354
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any Unicode "
"equivalent (code points with the ``Nd`` property)."
msgstr ""
"Kabul edilen sayısal değişmezler, ``0`` ile ``9`` arasındaki rakamları veya "
"herhangi bir Unicode eş değerini (\"Nd\" özelliğine sahip kod noktaları) içerir."

#: library/stdtypes.rst:357
msgid ""
"See `the Unicode Standard <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_ for a complete list of code points with the ``Nd`` "
"property."
msgstr ""
"``Nd`` özelliğine sahip kod noktalarının tam listesi için ``Unicode Standardı "
"<https://unicode.org/Public/UNIDATA/extracted/DerivedNumericType.txt>`_'ye bakın."

#: library/stdtypes.rst:361
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also include "
"the following operations:"
msgstr ""
"Tüm :class:`numbers.Real` türleri (:class:`int` ve :class:`float`) ayrıca "
"aşağıdaki işlemleri içerir:"

#: library/stdtypes.rst:367
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: library/stdtypes.rst:367
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* :class:`~numbers.Integral` şeklinde kısaltıldı"

#: library/stdtypes.rst:370
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: library/stdtypes.rst:370
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it defaults "
"to 0."
msgstr ""
"*x* *n* haneye yuvarlanır, yarıdan çifte yuvarlanır. *n* atlanırsa, *n* "
"varsayılan olarak 0 olur."

#: library/stdtypes.rst:374
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: library/stdtypes.rst:374
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "en büyük :class:`~numbers.Integral` <= *x*"

#: library/stdtypes.rst:377
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: library/stdtypes.rst:377
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "en küçük :class:`~numbers.Integral` >= *x*"

#: library/stdtypes.rst:381
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` modules."
msgstr "Ek sayısal işlemler için :mod:`math` ve :mod:`cmath` modüllerine bakın."

#: library/stdtypes.rst:390
msgid "Bitwise Operations on Integer Types"
msgstr "Tam sayı Türlerinde Bit Düzeyinde İşlemler"

#: library/stdtypes.rst:404
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"Bit düzeyinde işlemler yalnızca tam sayılar için anlamlıdır. Bit düzeyinde "
"işlemlerin sonucu, sonsuz sayıda işaret biti ile ikiye tümleyende "
"gerçekleştiriliyormuş gibi hesaplanır."

#: library/stdtypes.rst:408
msgid ""
"The priorities of the binary bitwise operations are all lower than the numeric "
"operations and higher than the comparisons; the unary operation ``~`` has the "
"same priority as the other unary numeric operations (``+`` and ``-``)."
msgstr ""
"İkili bit düzeyinde işlemlerin öncelikleri, sayısal işlemlerden daha düşük ve "
"karşılaştırmalardan daha yüksektir; ``~`` tekli işlemidiğer tekli sayısal "
"işlemlerle (``+`` ve ``-``) aynı önceliğe sahiptir."

#: library/stdtypes.rst:412
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr "Bu tablo, artan önceliğe göre sıralanmış bit düzeyinde işlemleri listeler:"

#: library/stdtypes.rst:417
msgid "``x | y``"
msgstr "``x | y``"

#: library/stdtypes.rst:417
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "bit düzeyinde *x* :dfn:`or` *y*"

#: library/stdtypes.rst:420 library/stdtypes.rst:1213 library/stdtypes.rst:2444
#: library/stdtypes.rst:3662
msgid "\\(4)"
msgstr "\\(4)"

#: library/stdtypes.rst:420
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: library/stdtypes.rst:420
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "bit düzeyinde *x* :dfn:`exclusive or` *y*"

#: library/stdtypes.rst:423
msgid "``x & y``"
msgstr "``x & y``"

#: library/stdtypes.rst:423
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "bit düzeyinde *x* :dfn:`and` *y*"

#: library/stdtypes.rst:426
msgid "``x << n``"
msgstr "``x << n``"

#: library/stdtypes.rst:426
msgid "*x* shifted left by *n* bits"
msgstr "*x*, *n* bit kadar sola kaydırıldı"

#: library/stdtypes.rst:426
msgid "(1)(2)"
msgstr "(1)(2)"

#: library/stdtypes.rst:428
msgid "``x >> n``"
msgstr "``x >> n``"

#: library/stdtypes.rst:428
msgid "*x* shifted right by *n* bits"
msgstr "*x*, *n* bit kadar sağa kaydırıldı"

#: library/stdtypes.rst:428
msgid "(1)(3)"
msgstr "(1)(3)"

#: library/stdtypes.rst:430
msgid "``~x``"
msgstr "``~x``"

#: library/stdtypes.rst:430
msgid "the bits of *x* inverted"
msgstr "*x* 'in bitleri ters çevrildi"

#: library/stdtypes.rst:436
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""
"Negatif kaydırma sayıları geçersizdir ve :exc:`ValueError` hatasına sebep olur."

#: library/stdtypes.rst:439
msgid "A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr "*n* bitlik sola kaydırma, ``pow(2, n)`` ile çarpmaya eş değerdir."

#: library/stdtypes.rst:442
msgid "A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr ""
"*n* bitlik sağa kaydırma, ``pow(2, n)`` ile kat bölümü işlemine eş değerdir."

#: library/stdtypes.rst:445
msgid ""
"Performing these calculations with at least one extra sign extension bit in a "
"finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same result as "
"if there were an infinite number of sign bits."
msgstr ""
"Bu hesaplamaları, sonlu ikinin tümleyen temsilinde en az bir ekstra işaret "
"uzatma biti ile yapmak ( ``1 + max(x.bit_length(), y.bit_length())`` veya daha "
"fazla çalışan bit genişliği), sonsuz sayıda işaret biti varmış gibi aynı sonucu "
"elde etmek için yeterlidir."

#: library/stdtypes.rst:452
msgid "Additional Methods on Integer Types"
msgstr "Integer (Tam sayı) Türlerinde Ek Metotlar"

#: library/stdtypes.rst:454
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"Int türü, :class:`numbers.Integral` :term:`abstract base class` 'ı uygular. Ek "
"olarak, birkaç metot daha sağlar:"

#: library/stdtypes.rst:459
msgid ""
"Return the number of bits necessary to represent an integer in binary, excluding "
"the sign and leading zeros::"
msgstr ""
"İşaret ve baştaki sıfırlar hariç, ikili sistemde bir tam sayıyı (integer) temsil "
"etmek için gereken bit sayısını döndürür::"

#: library/stdtypes.rst:468
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. Equivalently, "
"when ``abs(x)`` is small enough to have a correctly rounded logarithm, then ``k "
"= 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x.bit_length()`` returns "
"``0``."
msgstr ""
"Daha doğrusu, ``x`` sıfırdan farklıysa, ``x.bit_length()``, ``2**(k-1) <= abs(x) "
"< 2**k`` olacak şekilde benzersiz ``k`` pozitif tam sayısıdır. Aynı şekilde, "
"``abs(x)`` doğru olarak yuvarlatılmış bir logaritmaya sahip olacak kadar küçük "
"olduğunda, ``k = 1 + int(log(abs(x), 2))`` olur. ``x`` sıfır ise, ``x."
"bit_length()``, ``0`` döndürür."

#: library/stdtypes.rst:497 library/stdtypes.rst:586
msgid "Equivalent to::"
msgstr "Eşittir::"

#: library/stdtypes.rst:485
msgid ""
"Return the number of ones in the binary representation of the absolute value of "
"the integer. This is also known as the population count. Example::"
msgstr ""
"Tam sayının mutlak değerinin ikili gösterimindeki birlerin sayısını döndürür. "
"Buna nüfus sayımı da denir. Örneğin::"

#: library/stdtypes.rst:506
msgid "Return an array of bytes representing an integer."
msgstr "Bir tam sayıyı temsil eden bir bayt dizisi döndürür."

#: library/stdtypes.rst:518
msgid ""
"The integer is represented using *length* bytes, and defaults to 1.  An :exc:"
"`OverflowError` is raised if the integer is not representable with the given "
"number of bytes."
msgstr ""
"Tam sayı, *length* bayt kullanılarak temsil edilir ve varsayılan olarak birdir.  "
"Tam sayı verilen bayt sayısıyla gösterilemezse :exc:`OverflowError` hatası "
"ortaya çıkar."

#: library/stdtypes.rst:522
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the most "
"significant byte is at the beginning of the byte array.  If *byteorder* is "
"``\"little\"``, the most significant byte is at the end of the byte array."
msgstr ""
"*byteorder* argümanı, tam sayıyı temsil etmek için kullanılan bayt sırasını "
"belirler ve varsayılan olarak ``\"big\"`` 'dir.  *byteorder* ``\"big\"`` ise, en "
"önemli bayt, bayt dizisinin başındadır. *byteorder* ``\"little\"`` ise, en "
"önemli bayt, bayt dizisinin sonundadır."

#: library/stdtypes.rst:528
msgid ""
"The *signed* argument determines whether two's complement is used to represent "
"the integer.  If *signed* is ``False`` and a negative integer is given, an :exc:"
"`OverflowError` is raised. The default value for *signed* is ``False``."
msgstr ""
"*signed* argümanı, tam sayıyı temsil etmek için ikinin tümleyeninin kullanılıp "
"kullanılmayacağını belirler.  *signed* ``False`` ise ve negatif bir tam sayı "
"verilirse, bir :exc:`OverflowError` hatası ortaya çıkar. *signed* için "
"varsayılan değer ``False`` şeklindedir."

#: library/stdtypes.rst:533
msgid ""
"The default values can be used to conveniently turn an integer into a single "
"byte object::"
msgstr ""
"Varsayılan değerler, bir tamsayıyı tek baytlık bir nesneye dönüştürmek için "
"kullanılabilir::"

#: library/stdtypes.rst:539
msgid ""
"However, when using the default arguments, don't try to convert a value greater "
"than 255 or you'll get an :exc:`OverflowError`."
msgstr ""
"Ancak, varsayılan bağımsız değişkenleri kullanırken, 255'ten büyük bir değeri "
"dönüştürmeye çalışmayın, aksi halde :exc:`OverflowError` hatasıyla "
"karşılaşırsınız."

#: library/stdtypes.rst:555
msgid "Added default argument values for ``length`` and ``byteorder``."
msgstr ""
"Length`` ve ``byteorder`` için varsayılan bağımsız değişken değerleri eklendi."

#: library/stdtypes.rst:560
msgid "Return the integer represented by the given array of bytes."
msgstr "Verilen bayt dizisi tarafından temsil edilen tam sayıyı döndürür."

#: library/stdtypes.rst:573
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an iterable "
"producing bytes."
msgstr ""
"*bytes* argümanı ya bir :term:`bytes-like object` ya da yinelenebilir üreten "
"bayt olabilir."

#: library/stdtypes.rst:576
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the most "
"significant byte is at the beginning of the byte array.  If *byteorder* is "
"``\"little\"``, the most significant byte is at the end of the byte array.  To "
"request the native byte order of the host system, use :data:`sys.byteorder` as "
"the byte order value."
msgstr ""
"*byteorder* argümanı, tam sayıyı temsil etmek için kullanılan bayt sırasını "
"belirler.  *byteorder* ``\"big\"`` ise, en önemli bayt, bayt dizisinin "
"başındadır. *byteorder* ``\"little\"`` ise, en önemli bayt, bayt dizisinin "
"sonundadır. Ana sistemin yerel bayt sırasını istemek için bayt sırası değeri "
"olarak :data:`sys.byteorder` kullanın."

#: library/stdtypes.rst:583
msgid ""
"The *signed* argument indicates whether two's complement is used to represent "
"the integer."
msgstr ""
"*signed* argümanı, tam sayıyı temsil etmek için ikinin tümleyeninin kullanılıp "
"kullanılmadığını gösterir."

#: library/stdtypes.rst:603
msgid "Added default argument value for ``byteorder``."
msgstr "Byteorder`` için varsayılan bağımsız değişken değeri eklendi."

#: library/stdtypes.rst:608
msgid ""
"Return a pair of integers whose ratio is equal to the original integer and has a "
"positive denominator.  The integer ratio of integers (whole numbers) is always "
"the integer as the numerator and ``1`` as the denominator."
msgstr ""
"Oranı, orijinal tam sayıya tam olarak eşit ve pozitif bir paydaya sahip bir tam "
"sayı çifti döndürür. Integerlerin tam sayı oranı her zaman pay olarak tam sayı "
"ve payda olarak ``1`` dir."

#: library/stdtypes.rst:617
msgid ""
"Returns ``True``. Exists for duck type compatibility with :meth:`float."
"is_integer`."
msgstr ""
"``Doğru`` değerini döndürür. :meth:`float.is_integer` ile ördek türü uyumluluğu "
"için mevcuttur."

#: library/stdtypes.rst:622
msgid "Additional Methods on Float"
msgstr "Gerçel Sayılarda Ek Metotlar"

#: library/stdtypes.rst:624
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base class`. "
"float also has the following additional methods."
msgstr ""
"Float türü, :class:`numbers.Real` :term:`abstract base class` 'ı uygular. Float "
"ayrıca aşağıdaki ek metotlara sahiptir."

#: library/stdtypes.rst:629
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float. "
"The ratio is in lowest terms and has a positive denominator.  Raises :exc:"
"`OverflowError` on infinities and a :exc:`ValueError` on NaNs."
msgstr ""
"Oranı tam olarak orijinal gerçel sayıya eşit ve pozitif bir paydaya sahip bir "
"çift tam sayı döndürür. Sonsuzluklarda :exc:`OverflowError` ve NaN'lerde "
"(SayıDeğil) :exc:`ValueError` hataları ortaya çıkar."

#: library/stdtypes.rst:636
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Float örneği integral değeriyle sonluysa ``True``, aksi takdirde ``False`` "
"döndürür::"

#: library/stdtypes.rst:644
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since Python's "
"floats are stored internally as binary numbers, converting a float to or from a "
"*decimal* string usually involves a small rounding error.  In contrast, "
"hexadecimal strings allow exact representation and specification of floating-"
"point numbers.  This can be useful when debugging, and in numerical work."
msgstr ""
"İki yöntem, onaltılık dizelere dönüştürmeyi destekler. Python'un floatları "
"dahili olarak ikili sayılar olarak depolandığından, bir kayan noktayı *decimal* "
"(ondalık) dizgeye dönüştürmek veya bu karakter dizisinden dönüştürmek genellikle "
"küçük bir yuvarlama hatası içerir. Buna karşılık, onaltılık diziler, gerçel "
"sayıların tam olarak gösterilmesine ve belirtilmesine izin verir. Bu, hata "
"ayıklama sırasında ve sayısal çalışmalarda yararlı olabilir."

#: library/stdtypes.rst:655
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  For "
"finite floating-point numbers, this representation will always include a leading "
"``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Bir gerçel sayının temsilini, onaltılık bir dize olarak döndürür. Sonlu gerçel "
"sayılar için, bu gösterim her zaman başında bir ``0x`` ve sonunda bir ``p`` ve "
"üs içerecektir."

#: library/stdtypes.rst:663
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  The "
"string *s* may have leading and trailing whitespace."
msgstr ""
"Gerçel sayıyı temsil eden bir onaltılık dize *s*'yi döndüren için sınıf (class) "
"metodu. *s* dizesinin başında ve sonunda boşluk olabilir."

#: library/stdtypes.rst:668
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float.fromhex` "
"is a class method."
msgstr ""
":meth:`float.hex` 'in bir örnek (instance) metodu olduğunu, :meth:`float."
"fromhex` 'in ise bir sınıf (class) metodu olduğunu unutmayın."

#: library/stdtypes.rst:671
msgid "A hexadecimal string takes the form::"
msgstr "Onaltılık bir dize şu biçimi alır::"

#: library/stdtypes.rst:675
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a decimal "
"integer with an optional leading sign.  Case is not significant, and there must "
"be at least one hexadecimal digit in either the integer or the fraction.  This "
"syntax is similar to the syntax specified in section 6.4.4.2 of the C99 "
"standard, and also to the syntax used in Java 1.5 onwards.  In particular, the "
"output of :meth:`float.hex` is usable as a hexadecimal floating-point literal in "
"C or Java code, and hexadecimal strings produced by C's ``%a`` format character "
"or Java's ``Double.toHexString`` are accepted by :meth:`float.fromhex`."
msgstr ""
"burada opsiyonel ``işaret``, ``+`` veya ``-`` olabilir; ``tam sayı`` ve "
"``kesir`` onaltılı basamaklı dizelerdir; ``üs`` opsiyonel ön işaretle birlikte "
"ondalık tam sayıdır.  Büyük/küçük harf önemli değildir ve tam sayı veya kesirde "
"en az bir onaltılık basamak olmalıdır.  Bu söz dizimi, C99 standardının 6.4.4.2 "
"bölümünde belirtilen söz dizimine ve ayrıca Java 1.5'ten itibaren kullanılan söz "
"dizimine benzer.  Özellikle, :meth:`float.hex` 'in çıktısı, C veya Java kodunda "
"bir onaltılık gerçel değişmezi olarak kullanılabilir ve C'nin ``%a`` biçim "
"karakteri veya Java'nın ``Double.toHexString`` 'i tarafından üretilen onaltılık "
"dizeler :meth:`float.fromhex` tarafından kabul edilir."

#: library/stdtypes.rst:688
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and that "
"it gives the power of 2 by which to multiply the coefficient. For example, the "
"hexadecimal string ``0x3.a7p10`` represents the floating-point number ``(3 + "
"10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Üssün onaltılık değil ondalık olarak yazıldığına ve katsayıyı çarpmak için 2'nin "
"gücünü verdiğine dikkat edin. Örneğin, ``0x3.a7p10`` onaltılık dizesi, ``(3 + "
"10./16 + 7./16**2) * 2.0**10`` veya ``3740.0`` gerçel sayısını temsil eder::"

#: library/stdtypes.rst:698
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"``3740.0`` 'a ters dönüştürme uygulamak, aynı sayıyı temsil eden farklı bir "
"onaltılık dize verir::"

#: library/stdtypes.rst:708
msgid "Hashing of numeric types"
msgstr "Sayısal türlerin hashlemesi"

#: library/stdtypes.rst:710
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of implementation "
"and efficiency across a variety of numeric types (including :class:`int`, :class:"
"`float`, :class:`decimal.Decimal` and :class:`fractions.Fraction`) Python's hash "
"for numeric types is based on a single mathematical function that's defined for "
"any rational number, and hence applies to all instances of :class:`int` and :"
"class:`fractions.Fraction`, and all finite instances of :class:`float` and :"
"class:`decimal.Decimal`.  Essentially, this function is given by reduction "
"modulo ``P`` for a fixed prime ``P``.  The value of ``P`` is made available to "
"Python as the :attr:`modulus` attribute of :data:`sys.hash_info`."
msgstr ""
"Muhtemelen farklı türlerdeki ``x`` ve ``y`` sayıları için, ``x == y`` olduğunda "
"``hash(x) == hash(y)`` olması bir gerekliliktir (bkz. :meth:`~object.__hash__`). "
"Çeşitli sayısal türler arasında uygulama kolaylığı ve verimlilik için (:class:"
"`int`, :class:`float`, :class:`decimal.Decimal` ve :class:`fractions.Fraction` "
"dahil) Python'un sayısal türler için hash'i, herhangi bir rasyonel sayı için "
"tanımlanmış tek bir matematiksel fonksiyona dayanır ve bu nedenle :class:`int` "
"ve :class:`fractions.Fraction` 'ın tüm örnekleri ve :class:`float` ve :class:"
"`decimal.Decimal` öğelerinin tüm sonlu örnekleri için geçerlidir. Esasen, bu "
"fonksiyon sabit bir asal sayı olan ``P`` için ``reduction modulo`` ``P`` ile "
"verilir. ``P`` değeri Python'a :data:`sys.hash_info` 'nun :attr:`modulus` "
"özelliği olarak sunulur."

#: library/stdtypes.rst:725
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C longs "
"and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"Şu anda kullanılan asal sayı, 32 bit C uzunluğundaki makinelerde ``P = 2**31 - "
"1`` ve 64-bit C uzunluğundaki makinelerde ``P = 2**61 - 1`` şeklindedir."

#: library/stdtypes.rst:728
msgid "Here are the rules in detail:"
msgstr "İşte ayrıntılı kurallar:"

#: library/stdtypes.rst:730
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible by "
"``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, P)`` "
"gives the inverse of ``n`` modulo ``P``."
msgstr ""
"``x = m / n`` negatif olmayan bir rasyonel sayıysa ve ``n`` ``P`` ile "
"bölünemiyorsa, ``hash(x)`` 'i ``m * invmod(n, P) % P`` olarak tanımlayın, bu "
"durumda ``invmod(n, P)``, ``n`` modül ``P`` 'nin tersini verir."

#: library/stdtypes.rst:734
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant value "
"``sys.hash_info.inf``."
msgstr ""
"``x = m / n`` negatif olmayan bir rasyonel sayıysa ve ``n``, ``P`` ile "
"bölünebiliyorsa (ancak ``m`` değildir), o zaman ``n`` 'nin ``P`` şeklinde ters "
"modülü yoktur ve yukarıdaki kural geçerli değildir; bu durumda ``hash(x)`` i "
"``sys.hash_info.inf`` olarak tanımlayın."

#: library/stdtypes.rst:739
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-hash(-"
"x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"``x = m / n`` negatif bir rasyonel sayıysa, ``hash(x)`` 'i ``-hash(-x)`` olarak "
"tanımlayın. Elde edilen ``hash`` ``-1`` ise, bunu ``-2`` ile değiştirin."

#: library/stdtypes.rst:743
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are used "
"as hash values for positive infinity or negative infinity (respectively)."
msgstr ""
"``sys.hash_info.inf`` ve ``-sys.hash_info.inf``, pozitif sonsuz veya negatif "
"sonsuz (sırasıyla) için ``hash`` değerleri olarak kullanılır."

#: library/stdtypes.rst:747
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and imaginary "
"parts are combined by computing ``hash(z.real) + sys.hash_info.imag * hash(z."
"imag)``, reduced modulo ``2**sys.hash_info.width`` so that it lies in "
"``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))``.  Again, "
"if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Bir :class:`complex` sayı ``z`` için, gerçek ve sanal parçaların hash değerleri, "
"``hash(z.real) + sys.hash_info.imag * hash(z.imag)`` , ``reduced modulo`` "
"``2**sys.hash_info.width`` hesaplanarak birleştirilir, böylece ``range(-2**(sys."
"hash_info.width - 1), 2**(sys.hash_info.width - 1))`` 'de bulunur. Yine sonuç "
"``-1`` ise, ``-2`` ile değiştirilir."

#: library/stdtypes.rst:755
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to the "
"built-in hash, for computing the hash of a rational number, :class:`float`, or :"
"class:`complex`::"
msgstr ""
"Yukarıdaki kuralları açıklığa kavuşturmak için, :class:`float` veya :class:"
"`complex` olan rasyonel bir sayının ``hash`` 'ini hesaplamak için gömülü "
"``hash`` 'e eş değer örnek Python kodu::"

#: library/stdtypes.rst:810
msgid "Boolean Type - :class:`bool`"
msgstr "Boole Türü - :sınıf:`bool`"

#: library/stdtypes.rst:812
msgid ""
"Booleans represent truth values. The :class:`bool` type has exactly two constant "
"instances: ``True`` and ``False``."
msgstr ""
"Boolean'lar doğruluk değerlerini temsil eder. :class:`bool` türünün tam olarak "
"iki sabit örneği vardır: ``Doğru`` ve ``Yanlış``."

#: library/stdtypes.rst:820
msgid ""
"The built-in function :func:`bool`  converts any value to a boolean, if the "
"value can be interpreted as a truth value (see section :ref:`truth` above)."
msgstr ""
"Yerleşik :func:`bool` işlevi, eğer değer bir doğruluk değeri olarak "
"yorumlanabiliyorsa, herhangi bir değeri bir boole dönüştürür (yukarıdaki :ref:"
"`truth` bölümüne bakın)."

#: library/stdtypes.rst:823
msgid ""
"For logical operations, use the :ref:`boolean operators <boolean>` ``and``, "
"``or`` and ``not``. When applying the bitwise operators ``&``, ``|``, ``^`` to "
"two booleans, they return a bool equivalent to the logical operations \"and\", "
"\"or\", \"xor\". However, the logical operators ``and``, ``or`` and ``!=`` "
"should be preferred over ``&``, ``|`` and ``^``."
msgstr ""
"Mantıksal işlemler için :ref:`boolean operatörlerini <boolean>` ``and``, ``or`` "
"ve ``not`` kullanın. Bitsel operatörler ``&``, ``|``, ``^`` iki boolean'a "
"uygulandığında, \"ve\", \"veya\", \"xor\" mantıksal işlemlerine eşdeğer bir bool "
"döndürürler. Ancak, mantıksal operatörler ``ve``, ``veya`` ve ``!=``, ``&``, ``|"
"`` ve ``^`` yerine tercih edilmelidir."

#: library/stdtypes.rst:832
msgid ""
"The use of the bitwise inversion operator ``~`` is deprecated and will raise an "
"error in Python 3.14."
msgstr ""
"Bitsel ters çevirme operatörünün ``~`` kullanımı artık önerilmemektedir ve "
"Python 3.14'te bir hataya neden olacaktır."

#: library/stdtypes.rst:835
msgid ""
":class:`bool` is a subclass of :class:`int` (see :ref:`typesnumeric`). In many "
"numeric contexts, ``False`` and ``True`` behave like the integers 0 and 1, "
"respectively. However, relying on this is discouraged; explicitly convert using :"
"func:`int` instead."
msgstr ""
":class:`bool`, :class:`int`in bir alt sınıfıdır (bkz. :ref:`typesnumeric`). "
"Birçok sayısal bağlamda \"Yanlış\" ve \"Doğru\" sırasıyla 0 ve 1 tam sayıları "
"gibi davranır. Ancak buna güvenmek tavsiye edilmez; Bunun yerine açıkça :func:"
"`int` kullanarak dönüştürün."

#: library/stdtypes.rst:843
msgid "Iterator Types"
msgstr "Yineleyici Türleri"

#: library/stdtypes.rst:851
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always support "
"the iteration methods."
msgstr ""
"Python, konteynerler üzerinde yineleme kavramını destekler. Bu, iki farklı metot "
"kullanılarak uygulanır; bunlar, kullanıcı tanımlı sınıfların yinelemeyi "
"desteklemesine izin vermek için kullanılır. Aşağıda daha ayrıntılı olarak "
"açıklanan diziler, her zaman yineleme metotlarını destekler."

#: library/stdtypes.rst:856
msgid ""
"One method needs to be defined for container objects to provide :term:`iterable` "
"support:"
msgstr ""
"Container nesnelerinin :term:`iterable` desteği sağlaması için bir metodun "
"tanımlanması gerekir:"

#: library/stdtypes.rst:863
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request iterators "
"for those iteration types.  (An example of an object supporting multiple forms "
"of iteration would be a tree structure which supports both breadth-first and "
"depth-first traversal.)  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"Bir :term:`iterator` nesnesi döndürür.  Nesnenin aşağıda açıklanan yineleyici "
"protokolünü desteklemesi gerekir.  Bir container, farklı yineleme türlerini "
"destekliyorsa, bu yineleme türleri için özel olarak yineleyiciler istemek için "
"ek yöntemler sağlanabilir.  (Birden çok yineleme biçimini destekleyen bir "
"nesneye örnek olarak hem genişlik öncelikli hem de derinlik öncelikli geçişi "
"destekleyen bir ağaç yapısı verilebilir.)  Bu metot, Python/C API'sindeki Python "
"nesneleri için tür yapısının :c:member:`~PyTypeObject.tp_iter` yuvasına karşılık "
"gelir."

#: library/stdtypes.rst:872
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Yineleyici nesnelerinin kendilerinin, birlikte :dfn:`iterator protocol` 'ü "
"oluşturan aşağıdaki iki metodu desteklemesi gerekir:"

#: library/stdtypes.rst:878
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:`in` "
"statements.  This method corresponds to the :c:member:`~PyTypeObject.tp_iter` "
"slot of the type structure for Python objects in the Python/C API."
msgstr ""
":term:`iterator` nesnesinin kendisini döndürür.  Bu, hem containerların hem de "
"yineleyicilerin :keyword:`for` ve :keyword:`in` ifadeleriyle birlikte "
"kullanılmasına izin vermek için gereklidir.  Bu metot, Python/C API'sindeki "
"Python nesneleri için tür yapısının :c:member:`~PyTypeObject.tp_iter` yuvasına "
"karşılık gelir."

#: library/stdtypes.rst:887
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iternext` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
":term:`iterator` 'den sonraki öğeyi döndürür.  Başka öğe yoksa, :exc:"
"`StopIteration` hatasını verir.  Bu metot, Python/C API'sindeki Python nesneleri "
"için tür yapısının :c:member:`~PyTypeObject.tp_iternext` yuvasına karşılık gelir."

#: library/stdtypes.rst:892
msgid ""
"Python defines several iterator objects to support iteration over general and "
"specific sequence types, dictionaries, and other more specialized forms.  The "
"specific types are not important beyond their implementation of the iterator "
"protocol."
msgstr ""
"Python, genel ve özel dizi türleri, sözlükler ve diğer daha özel formlar "
"üzerinde yinelemeyi desteklemek için birkaç yineleyici nesnesi tanımlar.  "
"Belirli türler, yineleyici protokolünün uygulanmasının ötesinde önemli değildir."

#: library/stdtypes.rst:897
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. Implementations "
"that do not obey this property are deemed broken."
msgstr ""
"Bir yineleyicinin :meth:`~iterator.__next__` metodu :exc:`StopIteration` "
"hatasını verdiğinde, sonraki çağrılarda bunu yapmaya devam etmelidir. Bu "
"özelliğe uymayan uygulamalar bozuk sayılır."

#: library/stdtypes.rst:905
msgid "Generator Types"
msgstr "Oluşturucu Tipleri"

#: library/stdtypes.rst:907
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the iterator "
"protocol.  If a container object's :meth:`__iter__` method is implemented as a "
"generator, it will automatically return an iterator object (technically, a "
"generator object) supplying the :meth:`__iter__` and :meth:`~generator.__next__` "
"methods. More information about generators can be found in :ref:`the "
"documentation for the yield expression <yieldexpr>`."
msgstr ""
"Python'un :term:`generator`\\s, yineleyici protokolünü uygulamak için uygun bir "
"yol sağlar.  Bir container nesnesinin :meth:`__iter__` metodu bir oluşturucu "
"olarak uygulanırsa, otomatik olarak :meth:`__iter__` ve :meth:`~generator."
"__next__` metotlarını sağlayan bir yineleyici nesne (teknik olarak bir "
"oluşturucu nesnesi) döndürür. Oluşturucular hakkında daha fazla bilgi :ref:`the "
"documentation for the yield expression <yieldexpr>` adresinde bulunabilir."

#: library/stdtypes.rst:919
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "Dizi Tipleri --- :class:`list`, :class:`tuple`, :class:`range`"

#: library/stdtypes.rst:921
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Üç temel dizi türü vardır: listeler, demetler ve aralık nesneleri. :ref:`binary "
"data <binaryseq>` ve :ref:`text strings <textseq>` 'in işlenmesi için uyarlanmış "
"ek dizi türleri, özel bölümlerde açıklanmıştır."

#: library/stdtypes.rst:930
msgid "Common Sequence Operations"
msgstr "Yaygın Dizi İşlemleri"

#: library/stdtypes.rst:934
msgid ""
"The operations in the following table are supported by most sequence types, both "
"mutable and immutable. The :class:`collections.abc.Sequence` ABC is provided to "
"make it easier to correctly implement these operations on custom sequence types."
msgstr ""
"Aşağıdaki tablodaki işlemler, hem değiştirilebilir hem de değiştirilemez olan "
"çoğu dizi türü tarafından desteklenir. :class:`collections.abc.Sequence` ABC, bu "
"işlemleri özel dize türlerinde doğru şekilde uygulamayı kolaylaştırmak için "
"sağlanmıştır."

#: library/stdtypes.rst:939
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In the "
"table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* are "
"integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"Bu tablo artan önceliğe göre sıralanmış dizi işlemlerini listeler.  Tabloda *s* "
"ve *t* aynı türden dizilerdir, *n*, *i*, *j* ve *k* tam sayılardır ve *x*, *s* "
"tarafından dayatılan her tür ve değer kısıtlamasını karşılayan isteğe bağlı bir "
"nesnedir."

#: library/stdtypes.rst:944
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the comparison "
"operations. The ``+`` (concatenation) and ``*`` (repetition) operations have the "
"same priority as the corresponding numeric operations. [3]_"
msgstr ""
"``in`` ve ``not in`` işlemleri, karşılaştırma işlemleriyle aynı önceliklere "
"sahiptir. ``+`` (birleştirme) ve ``*`` (yineleme) işlemleri, karşılık gelen "
"sayısal işlemlerle aynı önceliğe sahiptir. [3]_"

#: library/stdtypes.rst:965
msgid "``x in s``"
msgstr "``x in s``"

#: library/stdtypes.rst:965
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "*s* 'nin bir öğesi *x* 'e eşitse ``True``, aksi takdirde ``False``"

#: library/stdtypes.rst:968
msgid "``x not in s``"
msgstr "``x not in s``"

#: library/stdtypes.rst:968
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "*s* 'nin bir öğesi *x* 'e eşitse ``False``, aksi taktirde ``True``"

#: library/stdtypes.rst:971
msgid "``s + t``"
msgstr "``s + t``"

#: library/stdtypes.rst:971
msgid "the concatenation of *s* and *t*"
msgstr "*s* ve *t* 'nin birleşimi"

#: library/stdtypes.rst:971
msgid "(6)(7)"
msgstr "(6)(7)"

#: library/stdtypes.rst:974
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` veya ``n * s``"

#: library/stdtypes.rst:974
msgid "equivalent to adding *s* to itself *n* times"
msgstr "*s* 'yi kendisine *n* kez eklemeye eş değer"

#: library/stdtypes.rst:974
msgid "(2)(7)"
msgstr "(2)(7)"

#: library/stdtypes.rst:977
msgid "``s[i]``"
msgstr "``s[i]``"

#: library/stdtypes.rst:977
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*s* 'nin *i*\\ 'inci öğesi, orijin 0"

#: library/stdtypes.rst:979
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: library/stdtypes.rst:979
msgid "slice of *s* from *i* to *j*"
msgstr "*s* 'nin *i* 'den *j* 'ye kadar olan dilimi"

#: library/stdtypes.rst:979
msgid "(3)(4)"
msgstr "(3)(4)"

#: library/stdtypes.rst:981
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: library/stdtypes.rst:981
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr ""
"*s* 'nin *i* 'den *j* 'ye kadar olan dilimi, *k* 'lik adımlarla (örneğin *k* = 2 "
"ise, ikişer ikişer)"

#: library/stdtypes.rst:981
msgid "(3)(5)"
msgstr "(3)(5)"

#: library/stdtypes.rst:984
msgid "``len(s)``"
msgstr "``len(s)``"

#: library/stdtypes.rst:984
msgid "length of *s*"
msgstr "*s* 'nin uzunluğu"

#: library/stdtypes.rst:986
msgid "``min(s)``"
msgstr "``min(s)``"

#: library/stdtypes.rst:986
msgid "smallest item of *s*"
msgstr "*s* 'nin en küçük öğesi"

#: library/stdtypes.rst:988
msgid "``max(s)``"
msgstr "``max(s)``"

#: library/stdtypes.rst:988
msgid "largest item of *s*"
msgstr "*s* 'nin en büyük öğesi"

#: library/stdtypes.rst:990
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: library/stdtypes.rst:990
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and before "
"index *j*)"
msgstr ""
"*x* 'in *s* içindeki ilk görüldüğü dizini (*i* dizininde veya sonrasında ve *j* "
"dizininden önce)"

#: library/stdtypes.rst:3644
msgid "\\(8)"
msgstr "\\(8)"

#: library/stdtypes.rst:994
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: library/stdtypes.rst:994
msgid "total number of occurrences of *x* in *s*"
msgstr "*s* 'de *x*'in toplam görülme sayısı"

#: library/stdtypes.rst:998
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples and "
"lists are compared lexicographically by comparing corresponding elements. This "
"means that to compare equal, every element must compare equal and the two "
"sequences must be of the same type and have the same length.  (For full details "
"see :ref:`comparisons` in the language reference.)"
msgstr ""
"Aynı türden diziler de karşılaştırmaları destekler. Özellikle, demetler ve "
"listeler, karşılık gelen öğeler ile sözlükbilimsel olarak karşılaştırılır. Bu, "
"eşit karşılaştırma yapılabilmesi için her öğenin eşit olarak karşılaştırması "
"gerektiği ve iki dizinin aynı türde ve aynı uzunlukta olması gerektiği anlamına "
"gelir. (Tüm ayrıntılar için dil referansındaki :ref:`comparisons` bölümüne "
"bakın.)"

#: library/stdtypes.rst:1008
msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index drops "
"below zero)."
msgstr ""
"Değiştirilebilir diziler üzerindeki ileri ve geri yineleyiciler, bir dizin "
"kullanarak değerlere erişir. Temel dizi mutasyona uğrasa bile bu endeks ileri "
"(veya geri) ilerlemeye devam edecektir. Yineleyici yalnızca :exc:`IndexError` "
"veya :exc:`StopIteration` ile karşılaşıldığında (veya dizin sıfırın altına "
"düştüğünde) sonlandırılır."

#: library/stdtypes.rst:1017
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple containment "
"testing in the general case, some specialised sequences (such as :class:`str`, :"
"class:`bytes` and :class:`bytearray`) also use them for subsequence testing::"
msgstr ""
"``in`` ve ``not in`` işlemleri, genel durumda yalnızca basit sınırlama testi "
"için kullanılırken, bazı özel diziler (örneğin: :class:`str`, :class:`bytes` ve :"
"class:`bytearray`) bunları sonraki dizi testi için de kullanır:"

#: library/stdtypes.rst:1026
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are not "
"copied; they are referenced multiple times.  This often haunts new Python "
"programmers; consider::"
msgstr ""
"*n* 'nin ``0`` 'dan küçük değerleri ``0`` olarak değerlendirilir (bu, *s* ile "
"aynı türde boş bir dizi verir). *s* dizisindeki öğeler kopyalanmaz, birden çok "
"kez referans gösterilir (kullanılır).  Bu, çoğunlukla yeni Python "
"programcılarına musallat olur; şunu düşünün::"

#: library/stdtypes.rst:1038
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single empty "
"list.  Modifying any of the elements of ``lists`` modifies this single list. You "
"can create a list of different lists this way::"
msgstr ""
"Olan şu ki, ``[[]]`` boş bir liste içeren tek elemanlı bir listedir, dolayısıyla "
"``[[]] * 3`` 'ün üç elemanı da bu boş listeye referanstır.  ``lists`` öğelerinin "
"herhangi birinin değiştirilmesi bu listeyi değiştirir. Bu şekilde farklı "
"listelerin bir listesini oluşturabilirsiniz::"

#: library/stdtypes.rst:1050
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"Daha fazla açıklama SSS gönderisinde mevcuttur: :ref:`faq-multidimensional-list`."

#: library/stdtypes.rst:1054
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is still "
"``0``."
msgstr ""
"*i* veya *j* negatifse, dizin *s*: dizisinin sonuna göredir: ``len(s) + i`` veya "
"``len(s) + j`` değiştirilir.  Ancak ``-0`` 'ın hala ``0`` olduğuna dikkat edin."

#: library/stdtypes.rst:1059
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with index "
"*k* such that ``i <= k < j``.  If *i* or *j* is greater than ``len(s)``, use "
"``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If *j* is omitted or "
"``None``, use ``len(s)``.  If *i* is greater than or equal to *j*, the slice is "
"empty."
msgstr ""
"*s* 'nin *i* ile *j* arasındaki dilimi, ``i <= k < j`` olacak şekilde *k* "
"indeksine sahip öğelerin dizisi olarak tanımlanır.  *i* veya *j* ``len(s)`` 'den "
"büyükse,``len(s)`` kullanın.  *i* atlanırsa veya ``None`` ise, ``0`` kullanın.  "
"*j* atlanırsa veya ``None`` ise, ``len(s)`` kullanın. *i*, *j* 'den büyük veya "
"ona eşitse, dilim boştur."

#: library/stdtypes.rst:1066
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, stopping "
"when *j* is reached (but never including *j*).  When *k* is positive, *i* and "
"*j* are reduced to ``len(s)`` if they are greater. When *k* is negative, *i* and "
"*j* are reduced to ``len(s) - 1`` if they are greater.  If *i* or *j* are "
"omitted or ``None``, they become \"end\" values (which end depends on the sign "
"of *k*).  Note, *k* cannot be zero. If *k* is ``None``, it is treated like ``1``."
msgstr ""
"*k* adımıyla *s*'nin *i*'den *j*'ye dilimi, ``x = i + n*k`` indeksine sahip "
"öğelerin dizisi olarak tanımlanır, öyle ki ``0 <= n < (j-i) )/k``. Başka bir "
"deyişle, indeksler ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` vb. olup, *j* olduğunda "
"dururlar. ulaşıldı (ancak asla *j* dahil değil). *k* pozitif olduğunda, *i* ve "
"*j* büyükse ``len(s)``ye indirgenir. *k* negatif olduğunda, *i* ve *j* büyükse "
"``len(s) - 1``e indirgenir. *i* veya *j* atlanırsa veya ``Hiçbiri``, bunlar "
"\"son\" değerleri haline gelir (hangi son, *k* işaretine bağlıdır). *k*'nın "
"sıfır olamayacağını unutmayın. *k* \"Yok\" ise \"1\" gibi değerlendirilir."

#: library/stdtypes.rst:1077
msgid ""
"Concatenating immutable sequences always results in a new object.  This means "
"that building up a sequence by repeated concatenation will have a quadratic "
"runtime cost in the total sequence length.  To get a linear runtime cost, you "
"must switch to one of the alternatives below:"
msgstr ""
"Değiştirilemez dizileri birleştirmek her zaman yeni bir nesneyle sonuçlanır.  "
"Bu, tekrarlanan birleştirme ile bir dizi oluşturmanın, toplam dizi uzunluğunda "
"ikinci dereceden bir çalışma zamanı maliyetine sahip olacağı anlamına gelir.  "
"Doğrusal bir çalışma zamanı maliyeti elde etmek için aşağıdaki alternatiflerden "
"birine geçmelisiniz:"

#: library/stdtypes.rst:1082
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:`str."
"join` at the end or else write to an :class:`io.StringIO` instance and retrieve "
"its value when complete"
msgstr ""
":class:`str` nesnelerini birleştiriyorsanız, bir liste oluşturabilir ve sonunda :"
"meth:`str.join` kullanabilir veya bir :class:`io.StringIO` örneğine yazabilir ve "
"tamamlandığında değerini alabilirsiniz"

#: library/stdtypes.rst:1086
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :class:"
"`bytearray` object.  :class:`bytearray` objects are mutable and have an "
"efficient overallocation mechanism"
msgstr ""
":class:`bytes` nesnelerini birleştiriyorsanız, benzer şekilde :meth:`bytes.join` "
"veya :class:`io.BytesIO` kullanabilir veya bir :class:`bytearray` nesnesiyle "
"yerinde birleştirme yapabilirsiniz.  :class:`bytearray` nesneleri "
"değiştirilebilirdir ve verimli bir aşırı tahsis mekanizmasına sahiptir"

#: library/stdtypes.rst:1091
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
":class:`tuple` nesneleri birleştiriyorsanız, bunun yerine bir :class:`list` "
"öğesini genişletin"

#: library/stdtypes.rst:1093
msgid "for other types, investigate the relevant class documentation"
msgstr "diğer türler için ilgili sınıf dokümantasyonunu inceleyin"

#: library/stdtypes.rst:1097
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences that "
"follow specific patterns, and hence don't support sequence concatenation or "
"repetition."
msgstr ""
"Bazı dizi türleri (örneğin :class:`range`) yalnızca belirli kalıpları takip eden "
"öğe dizilerini destekler ve bu nedenle dizi birleştirmeyi veya tekrarlamayı "
"desteklemez."

#: library/stdtypes.rst:1102
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing the "
"extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only without "
"copying any data and with the returned index being relative to the start of the "
"sequence rather than the start of the slice."
msgstr ""
"*s* içinde *x* bulunmadığında ``index`` :exc:`ValueError` hatasını verir. Tüm "
"uygulamalar *i* ve *j* ek argümanlarının iletilmesini desteklemez. Bu "
"argümanlar, dizinin alt bölümlerinin verimli bir şekilde aranmasını sağlar. "
"Fazladan argümanları iletmek kabaca ``s[i:j].index(x)`` kullanmaya eş değerdir, "
"yalnızca herhangi bir veri kopyalamadan ve döndürülen index dilimin "
"başlangıcından ziyade dizinin başlangıcına göredir."

#: library/stdtypes.rst:1113
msgid "Immutable Sequence Types"
msgstr "Değiştirilemez Dizi Tipleri"

#: library/stdtypes.rst:1120
msgid ""
"The only operation that immutable sequence types generally implement that is not "
"also implemented by mutable sequence types is support for the :func:`hash` built-"
"in."
msgstr ""
"Değiştirilemez dizi türlerinin genellikle uyguladığı ve aynı zamanda değişken "
"dizi türleri tarafından uygulanmayan tek işlem, gömülü :func:`hash` desteğidir."

#: library/stdtypes.rst:1124
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, to be "
"used as :class:`dict` keys and stored in :class:`set` and :class:`frozenset` "
"instances."
msgstr ""
"Bu destek, :class:`tuple` örnekleri gibi değiştirilemez dizilerin :class:`dict` "
"anahtarları olarak kullanılmasına, :class:`set` ve :class:`frozenset` "
"örneklerinde saklanmasına izin verir."

#: library/stdtypes.rst:1128
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values will "
"result in :exc:`TypeError`."
msgstr ""
"Hash edilemeyen değerler içeren değişmez bir diziye hash uygulanmaya "
"çalışılması :exc:`TypeError` ile sonuçlanacaktır."

#: library/stdtypes.rst:1135
msgid "Mutable Sequence Types"
msgstr "Değiştirilebilir Dizi Tipleri"

#: library/stdtypes.rst:1142
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it easier "
"to correctly implement these operations on custom sequence types."
msgstr ""
"Aşağıdaki tabloda yer alan işlemler değiştirilebilir dizi tiplerinde "
"tanımlanmıştır. :class:`collections.abc.MutableSequence` ABC, bu işlemleri özel "
"dizi türlerinde doğru şekilde uygulamayı kolaylaştırmak için sağlanmıştır."

#: library/stdtypes.rst:1146
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any iterable "
"object and *x* is an arbitrary object that meets any type and value restrictions "
"imposed by *s* (for example, :class:`bytearray` only accepts integers that meet "
"the value restriction ``0 <= x <= 255``)."
msgstr ""
"Tabloda *s* değiştirilebilir bir dizi türünün bir örneğidir, *t* yinelenebilir "
"herhangi bir nesnedir ve *x*, *s* tarafından dayatılan herhangi bir tür ve değer "
"kısıtlamasını karşılayan rastgele bir nesnedir (örneğin, :class:`bytearray` "
"yalnızca ``0 <= x <= 255`` değer kısıtlamasını karşılayan tam sayıları kabul "
"eder)."

#: library/stdtypes.rst:1170
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: library/stdtypes.rst:1170
msgid "item *i* of *s* is replaced by *x*"
msgstr "*s* 'nin *i* öğesi *x* ile değiştirilir"

#: library/stdtypes.rst:1173
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: library/stdtypes.rst:1173
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"*s* 'nin *i* ile *j* arasındaki dilimi, yinelenebilir *t* içeriğiyle değiştirilir"

#: library/stdtypes.rst:1177
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: library/stdtypes.rst:1177
msgid "same as ``s[i:j] = []``"
msgstr "``s[i:j] = []`` ile eş değerdir"

#: library/stdtypes.rst:1179
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: library/stdtypes.rst:1179
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "``s[i:j:k]`` 'nin öğelerinin yerini *t* öğelerininkiler alır"

#: library/stdtypes.rst:1182
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: library/stdtypes.rst:1182
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "``s[i:j:k]`` 'nin öğelerini listeden kaldırır"

#: library/stdtypes.rst:1185
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: library/stdtypes.rst:1185
msgid "appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr "dizinin sonuna *x* ekler (``s[len(s):len(s)] = [x]`` ile eş değerdir)"

#: library/stdtypes.rst:1189
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: library/stdtypes.rst:1189
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "*s* içindeki tüm öğeleri kaldırır (``del s[:]`` ile eş değerdir)"

#: library/stdtypes.rst:1192
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: library/stdtypes.rst:1192
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "*s*'nin sığ bir kopyasını oluşturur (``s[:]`` ile eş değerdir)"

#: library/stdtypes.rst:1195
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` veya ``s += t``"

#: library/stdtypes.rst:1195
msgid ""
"extends *s* with the contents of *t* (for the most part the same as ``s[len(s):"
"len(s)] = t``)"
msgstr ""
"*s* 'yi *t* 'nin içeriğiyle genişletir (çoğunlukla ``s[len(s):len(s)] = t`` ile "
"eş değerdir)"

#: library/stdtypes.rst:1200
msgid "``s *= n``"
msgstr "``s *= n``"

#: library/stdtypes.rst:1200
msgid "updates *s* with its contents repeated *n* times"
msgstr "*n* kez tekrarlanan içeriğiyle *s* 'yi günceller"

#: library/stdtypes.rst:1203
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: library/stdtypes.rst:1203
msgid "inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""
"*i* tarafından verilen dizinde *s* 'nin içine *x* ekler (``s[i:i] = [x]`` ile eş "
"değerdir)"

#: library/stdtypes.rst:1207
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` veya ``s.pop(i)``"

#: library/stdtypes.rst:1207
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "*i* noktasındaki öğeyi alır ve *s* öğesinden kaldırır"

#: library/stdtypes.rst:1210
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: library/stdtypes.rst:1210
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "``s[i]`` 'nin *x* 'e eşit olduğu *s* 'den ilk öğeyi kaldırır"

#: library/stdtypes.rst:1213
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: library/stdtypes.rst:1213
msgid "reverses the items of *s* in place"
msgstr "*s* 'nin öğelerini yerinde tersine çevirir"

#: library/stdtypes.rst:1221
msgid "*t* must have the same length as the slice it is replacing."
msgstr "*t*, değiştirdiği dilimle aynı uzunlukta olmalıdır."

#: library/stdtypes.rst:1224
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last item "
"is removed and returned."
msgstr ""
"İsteğe bağlı *i* argümanı varsayılan olarak ``-1`` şeklindedir, böylece "
"varsayılan olarak son öğe kaldırılır ve döndürülür."

#: library/stdtypes.rst:1228
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""
"*s* 'nin içinde *x* bulunmadığında :meth:`remove` işlemi :exc:`ValueError` "
"hatasını verir."

#: library/stdtypes.rst:1231
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of space "
"when reversing a large sequence.  To remind users that it operates by side "
"effect, it does not return the reversed sequence."
msgstr ""
":meth:`reverse` metodu, büyük bir diziyi tersine çevirirken yerden tasarruf "
"sağlamak için diziyi yerinde değiştirir. Kullanıcılara yan etki ile çalıştığını "
"hatırlatmak için ters diziyi döndürmez."

#: library/stdtypes.rst:1236
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the interfaces "
"of mutable containers that don't support slicing operations (such as :class:"
"`dict` and :class:`set`). :meth:`!copy` is not part of the :class:`collections."
"abc.MutableSequence` ABC, but most concrete mutable sequence classes provide it."
msgstr ""
":meth:`clear` ve :meth:`!copy` dilimleme işlemlerini desteklemeyen değişken "
"kapların arayüzleriyle tutarlılık sağlamak amacıyla dahil edilmiştir (örneğin :"
"class:`dict` ve :class:`set`). :meth:`!copy`, :class:`collections.abc."
"MutableSequence` ABC'nin bir parçası değildir, ancak çoğu somut değişken dizi "
"sınıfı bunu sağlar."

#: library/stdtypes.rst:1242
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr ":meth:`clear` ve :meth:`!copy` metotları."

#: library/stdtypes.rst:1246
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in the "
"sequence are not copied; they are referenced multiple times, as explained for "
"``s * n`` under :ref:`typesseq-common`."
msgstr ""
"*n* değeri bir tam sayıdır veya :meth:`~object.__index__` uygulayan bir "
"nesnedir.  *n* 'nin sıfır ve negatif değerleri diziyi temizler.  Dizideki öğeler "
"kopyalanmaz; :ref:`typesseq-common` altında ``s * n`` için açıklandığı gibi, "
"bunlara birden çok kez başvurulur."

#: library/stdtypes.rst:1255
msgid "Lists"
msgstr "Listeler"

#: library/stdtypes.rst:1259
msgid ""
"Lists are mutable sequences, typically used to store collections of homogeneous "
"items (where the precise degree of similarity will vary by application)."
msgstr ""
"Listeler, tipik olarak (kesin benzerlik derecesinin uygulamaya göre değişeceği) "
"homojen öğelerin koleksiyonlarını depolamak için kullanılan değiştirilebilir "
"dizilerdir."

#: library/stdtypes.rst:1265
msgid "Lists may be constructed in several ways:"
msgstr "Listeler birkaç şekilde oluşturulabilir:"

#: library/stdtypes.rst:1267
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr "Boş listeyi belirtmek için bir çift köşeli parantez kullanma: ``[]``"

#: library/stdtypes.rst:1268
msgid "Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Köşeli parantez kullanarak, öğeleri virgülle ayırarak: ``[a]``, ``[a, b, c]``"

#: library/stdtypes.rst:1269
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "Liste kavrayışını kullanma: ``[x for x in iterable]``"

#: library/stdtypes.rst:1270
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "Tür oluşturucuyu kullanma: ``list()`` veya ``list(iterable)``"

#: library/stdtypes.rst:1272
msgid ""
"The constructor builds a list whose items are the same and in the same order as "
"*iterable*'s items.  *iterable* may be either a sequence, a container that "
"supports iteration, or an iterator object.  If *iterable* is already a list, a "
"copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` returns "
"``[1, 2, 3]``. If no argument is given, the constructor creates a new empty "
"list, ``[]``."
msgstr ""
"Yapıcı, öğeleri *iterable* 'ın öğeleriyle aynı ve aynı sırada olan bir liste "
"oluşturur.  *iterable*; bir dizi, yinelemeyi destekleyen bir container veya "
"yineleyici nesne olabilir.  *iterable* zaten bir listeyse, ``iterable[:]`` 'e "
"benzer şekilde bir kopya oluşturulur ve döndürülür. Örneğin, ``list('abc')``, "
"``['a', 'b', 'c']`` değerini döndürür ve ``list( (1, 2, 3) )``, ``[ 1, 2, 3]``. "
"Argüman verilmezse, yapıcı ``[]`` yeni bir boş liste oluşturur."

#: library/stdtypes.rst:1281
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-in."
msgstr ""
"Gömülü :func:`sorted` dahil olmak üzere diğer birçok işlem de listeler üretir."

#: library/stdtypes.rst:1284
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Listeler, tüm :ref:`common <typesseq-common>` ve :ref:`mutable <typesseq-"
"mutable>` dizi işlemlerini uygular. Listeler ayrıca aşağıdaki ek metodu da "
"sağlar:"

#: library/stdtypes.rst:1290
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between items. "
"Exceptions are not suppressed - if any comparison operations fail, the entire "
"sort operation will fail (and the list will likely be left in a partially "
"modified state)."
msgstr ""
"Bu metot, öğeler arasında yalnızca ``<`` karşılaştırmalarını kullanarak listeyi "
"yerinde sıralar. Hatalar bastırılmaz - herhangi bir karşılaştırma işlemi "
"başarısız olursa, tüm sıralama işlemi başarısız olur (ve liste büyük olasılıkla "
"kısmen değiştirilmiş durumda kalır)."

#: library/stdtypes.rst:1295
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` yalnızca anahtar kelime tarafından iletilebilen iki argümanı kabul "
"eder (:ref:`keyword-only arguments <keyword-only_parameter>`):"

#: library/stdtypes.rst:1298
msgid ""
"*key* specifies a function of one argument that is used to extract a comparison "
"key from each list element (for example, ``key=str.lower``). The key "
"corresponding to each item in the list is calculated once and then used for the "
"entire sorting process. The default value of ``None`` means that list items are "
"sorted directly without calculating a separate key value."
msgstr ""
"*key*, her liste öğesinden bir karşılaştırma anahtarı çıkarmak için kullanılan "
"bir argümanın işlevini belirtir (örneğin, ``key=str.lower``). Listedeki her bir "
"öğeye karşılık gelen anahtar bir kez hesaplanır ve ardından tüm sıralama işlemi "
"için kullanılır. Varsayılan değer olan ``None``, liste öğelerinin ayrı bir "
"anahtar değeri hesaplamadan doğrudan sıralandığı anlamına gelir."

#: library/stdtypes.rst:1305
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
":func:`functools.cmp_to_key` yardımcı programı, 2.x stili *cmp* işlevini bir "
"*key* işlevine dönüştürmek için kullanılabilir."

#: library/stdtypes.rst:1308
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements are "
"sorted as if each comparison were reversed."
msgstr ""
"*reverse* bir boolean değeridir. ``True`` olarak ayarlanırsa, liste öğeleri, her "
"karşılaştırma tersine çevrilmiş gibi sıralanır."

#: library/stdtypes.rst:1311
msgid ""
"This method modifies the sequence in place for economy of space when sorting a "
"large sequence.  To remind users that it operates by side effect, it does not "
"return the sorted sequence (use :func:`sorted` to explicitly request a new "
"sorted list instance)."
msgstr ""
"Bu yöntem, büyük bir diziyi sıralarken yerden tasarruf sağlamak için diziyi "
"yerinde değiştirir. Kullanıcılara yan etki ile çalıştığını hatırlatmak için, "
"sıralanan diziyi döndürmez (açıkça yeni bir sıralanmış liste örneği istemek "
"için :func:`sorted` kullanın)."

#: library/stdtypes.rst:1316
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal --- "
"this is helpful for sorting in multiple passes (for example, sort by department, "
"then by salary grade)."
msgstr ""
":meth:`sort` metodunun kararlı olduğu garanti edilir.  Bir sıralama, eşit olarak "
"karşılaştırılan öğelerin göreli sırasını değiştirmemeyi garanti ediyorsa "
"kararlıdır --- bu, birden çok geçişte sıralama için yararlıdır (örneğin, "
"departmana göre sıralama, ardından maaş derecesine göre)."

#: library/stdtypes.rst:1321
msgid "For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Sıralama örnekleri ve kısa bir sıralama eğitimi için bkz. :ref:`sortinghowto`."

#: library/stdtypes.rst:1325
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the list "
"appear empty for the duration, and raises :exc:`ValueError` if it can detect "
"that the list has been mutated during a sort."
msgstr ""
"Bir liste sıralanırken, listeyi değiştirmeye ve hatta incelemeye çalışmanın "
"etkisi tanımsızdır. Python'un C uygulaması, listenin süre boyunca boş "
"görünmesini sağlar ve bir sıralama sırasında listenin mutasyona uğradığını "
"algılayabilirse :exc:`ValueError` hatasını verir."

#: library/stdtypes.rst:1334
msgid "Tuples"
msgstr "Demetler"

#: library/stdtypes.rst:1338
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` built-"
"in). Tuples are also used for cases where an immutable sequence of homogeneous "
"data is needed (such as allowing storage in a :class:`set` or :class:`dict` "
"instance)."
msgstr ""
"Tuple'lar, tipik olarak heterojen veri koleksiyonlarını depolamak için "
"kullanılan değiştirilemez dizilerdir (örneğin, gömülü :func:`enumerate` "
"tarafından üretilen 2 tuple). Tuple'lar, değiştirilemez bir homojen veri "
"dizisinin gerekli olduğu durumlarda da kullanılır (bir :class:`set` veya :class:"
"`dict` örneğinde depolamaya izin vermek gibi)."

#: library/stdtypes.rst:1346
msgid "Tuples may be constructed in a number of ways:"
msgstr "Tuple'lar çeşitli şekillerde oluşturulabilir:"

#: library/stdtypes.rst:1348
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr "Boş demeti belirtmek için bir çift parantez kullanma: ``()``"

#: library/stdtypes.rst:1349
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr "Tekli bir tuple için sonunda virgül kullanma: ``a,`` veya ``(a,)``"

#: library/stdtypes.rst:1350
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "Öğeleri virgülle ayırma: ``a, b, c`` veya ``(a, b, c)``"

#: library/stdtypes.rst:1351
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr "Gömülü :func:`tuple` kullanmak: ``tuple()`` veya ``tuple(iterable)``"

#: library/stdtypes.rst:1353
msgid ""
"The constructor builds a tuple whose items are the same and in the same order as "
"*iterable*'s items.  *iterable* may be either a sequence, a container that "
"supports iteration, or an iterator object.  If *iterable* is already a tuple, it "
"is returned unchanged. For example, ``tuple('abc')`` returns ``('a', 'b', 'c')`` "
"and ``tuple( [1, 2, 3] )`` returns ``(1, 2, 3)``. If no argument is given, the "
"constructor creates a new empty tuple, ``()``."
msgstr ""
"Yapıcı, öğeleri *iterable* öğeleriyle aynı ve aynı sırada olan bir demet "
"oluşturur.  *iterable* bir dizi, yinelemeyi destekleyen bir container veya "
"yineleyici nesne olabilir.  *iterable* zaten bir tuple ise, değiştirilmeden "
"döndürülür. Örneğin, ``tuple('abc')``, ``('a', 'b', 'c')`` 'yi ve ``tuple( [1, "
"2, 3] )``, ``(1, 2, 3)`` 'yi döndürür. Herhangi bir argüman verilmezse, yapıcı "
"yeni bir boş demet oluşturur ``()``."

#: library/stdtypes.rst:1361
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. The "
"parentheses are optional, except in the empty tuple case, or when they are "
"needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a function "
"call with three arguments, while ``f((a, b, c))`` is a function call with a 3-"
"tuple as the sole argument."
msgstr ""
"Bir demeti oluşturanın aslında parantez değil virgül olduğuna dikkat edin. Boş "
"demet durumunda veya söz dizimsel belirsizliği önlemek için gerektiğinde "
"parantezler isteğe bağlıdır. Örneğin, ``f(a, b, c)`` üç argümanlı bir fonksiyon "
"çağrısı iken ``f((a, b, c))``, tek argüman olarak 3'lü bir tuple içeren bir "
"fonksiyon çağrısıdır."

#: library/stdtypes.rst:1367
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence operations."
msgstr "Tuple'lar, tüm :ref:`common <typesseq-common>` dizi işlemlerini uygular."

#: library/stdtypes.rst:1370
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate choice "
"than a simple tuple object."
msgstr ""
"Ada göre erişimin dizine göre erişimden daha net olduğu heterojen veri "
"koleksiyonları için, :func:`collections.namedtuple` basit bir tuple nesnesinden "
"daha uygun bir seçim olabilir."

#: library/stdtypes.rst:1378
msgid "Ranges"
msgstr "Aralıklar"

#: library/stdtypes.rst:1382
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
":class:`range` türü, değiştirilemez bir sayı dizisini temsil eder ve genellikle :"
"keyword:`for` döngülerinde belirli sayıda döngü yapmak için kullanılır."

#: library/stdtypes.rst:1389
msgid ""
"The arguments to the range constructor must be integers (either built-in :class:"
"`int` or any object that implements the :meth:`~object.__index__` special "
"method).  If the *step* argument is omitted, it defaults to ``1``. If the "
"*start* argument is omitted, it defaults to ``0``. If *step* is zero, :exc:"
"`ValueError` is raised."
msgstr ""
"Aralık oluşturucunun argümanları tamsayı olmalıdır (gömülü :class:`int` veya :"
"meth:`~object.__index__` özel metodunu uygulayan herhangi bir nesne). *step* "
"argümanı atlanırsa, varsayılan olarak ``1`` olur. *start* argümanı atlanırsa, "
"varsayılan olarak ``0`` olur. *step* sıfırsa, :exc:`ValueError` hatası ortaya "
"çıkar."

#: library/stdtypes.rst:1395
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Pozitif *step* için, ``r`` aralığının içeriği, ``i >= 0`` ve ``r[i] < stop`` "
"olmak üzere ``r[i] = start + step*i`` formülüyle belirlenir."

#: library/stdtypes.rst:1399
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and ``r[i] "
"> stop``."
msgstr ""
"Negatif bir *step* için, aralığın içeriği hala ``r[i] = start + step*i`` "
"formülüyle belirlenir, ancak kısıtlamalar ``i >= 0`` ve ``r[i] > stop`` 'dir."

#: library/stdtypes.rst:1403
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing from "
"the end of the sequence determined by the positive indices."
msgstr ""
"Bir aralık nesnesi ``r[0]`` değer kısıtlamasını karşılamıyorsa, boş olacaktır. "
"Aralıklar negatif indeksleri destekler, ancak bunlar pozitif indeksler "
"tarafından belirlenen dizinin sonundan indeksleme olarak yorumlanır."

#: library/stdtypes.rst:1408
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are permitted "
"but some features (such as :func:`len`) may raise :exc:`OverflowError`."
msgstr ""
":data:`sys.maxsize` 'dan büyük mutlak değerler içeren aralıklara izin verilir, "
"ancak bazı özellikler (:func:`len` gibi), :exc:`OverflowError` hatasınının "
"ortaya çıkmasını sağlayabilir."

#: library/stdtypes.rst:1412
msgid "Range examples::"
msgstr "Aralık örnekleri::"

#: library/stdtypes.rst:1429
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence operations "
"except concatenation and repetition (due to the fact that range objects can only "
"represent sequences that follow a strict pattern and repetition and "
"concatenation will usually violate that pattern)."
msgstr ""
"Aralıklar, birleştirme ve tekrar dışında tüm :ref:`common <typesseq-common>` "
"dizi işlemlerini uygular (aralık nesnelerinin yalnızca katı bir kalıp izleyen "
"dizileri temsil edebilmesi ve tekrarlama ve birleştirmenin genellikle bu kalıbı "
"ihlal etmesi nedeniyle)."

#: library/stdtypes.rst:1436
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not supplied)"
msgstr "*start* parametresinin değeri (veya parametre sağlanmadıysa ``0``)"

#: library/stdtypes.rst:1441
msgid "The value of the *stop* parameter"
msgstr "*stop* parametresinin değeri"

#: library/stdtypes.rst:1445
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not supplied)"
msgstr "*step* parametresinin değeri (veya parametre sağlanmadıysa ``1``)"

#: library/stdtypes.rst:1448
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :class:"
"`tuple` is that a :class:`range` object will always take the same (small) amount "
"of memory, no matter the size of the range it represents (as it only stores the "
"``start``, ``stop`` and ``step`` values, calculating individual items and "
"subranges as needed)."
msgstr ""
":class:`range` türünün normal bir :class:`list` veya :class:`tuple` üzerindeki "
"avantajı, bir :class:`range` nesnesinin temsil ettiği aralığın boyutu ne olursa "
"olsun her zaman aynı (küçük) miktarda bellek almasıdır (yalnızca ``start``, "
"``stop`` ve ``step`` değerlerini sakladığı için, tek tek öğeleri ve alt "
"aralıkları gerektiği gibi hesaplar)."

#: library/stdtypes.rst:1454
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and provide "
"features such as containment tests, element index lookup, slicing and support "
"for negative indices (see :ref:`typesseq`):"
msgstr ""
"Aralık (range) nesneleri :class:`collections.abc.Sequence` ABC'sini uygular ve "
"sınırlama testleri, eleman indeksi araması, dilimleme ve negatif indeksler için "
"destek gibi özellikler sağlar (bkz. :ref:`typesseq`):"

#: library/stdtypes.rst:1474
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they represent "
"the same sequence of values.  (Note that two range objects that compare equal "
"might have different :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range."
"step` attributes, for example ``range(0) == range(2, 1, 3)`` or ``range(0, 3, 2) "
"== range(0, 4, 2)``.)"
msgstr ""
"Aralık nesnelerini ``==`` ve ``!=`` ile eşitlik açısından test etmek, bunları "
"diziler olarak karşılaştırır. Yani, aynı değer dizisini temsil ediyorlarsa, iki "
"aralık nesnesi eşit kabul edilir.  (Eşit karşılaştıran iki aralık nesnesinin "
"farklı :attr:`~range.start`, :attr:`~range.stop` ve :attr:`~range.step` "
"niteliklerine sahip olabileceğini unutmayın, örneğin ``range(0) == range(2, 1, "
"3)`` veya ``range(0, 3, 2) == range(0, 4, 2)``.)"

#: library/stdtypes.rst:1481
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :class:"
"`int` objects for membership in constant time instead of iterating through all "
"items."
msgstr ""
"Dizi ABC'sini uygular, Dilimleme ve negatif indekslemeyi destekler, Tüm öğeleri "
"yinelemek yerine sabit zamanda üyelik için :class:`int` nesnelerini test eder."

#: library/stdtypes.rst:1487
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of values "
"they define (instead of comparing based on object identity)."
msgstr ""
"Aralık nesnelerini tanımladıkları değer sırasına göre karşılaştırmak için '==' "
"ve '!=' tanımlayın (nesne kimliğine göre karşılaştırmak yerine)."

#: library/stdtypes.rst:1492
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` attributes."
msgstr ""
":attr:`~range.start`, :attr:`~range.stop` ve :attr:`~range.step` özellikleri."

#: library/stdtypes.rst:1498
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000/>`_ shows how "
"to implement a lazy version of range suitable for floating point applications."
msgstr ""
"`Linspace tarifi <http://code.activestate.com/recipes/579000/>`_ , kayan nokta "
"uygulamaları için uygun olan tembel bir aralığın nasıl uygulanacağını gösterir."

#: library/stdtypes.rst:1510
msgid "Text Sequence Type --- :class:`str`"
msgstr "Metin Sırası Türü --- :class:`str`"

#: library/stdtypes.rst:1512
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:`strings`. "
"Strings are immutable :ref:`sequences <typesseq>` of Unicode code points.  "
"String literals are written in a variety of ways:"
msgstr ""
"Python'da metinsel veriler :class:`str` nesneleri veya :dfn:`strings` ile "
"işlenir. Dizeler, Unicode kod noktalarının değişmez :ref:`dizgeleridir "
"<typesseq>`. Dize değişmezleri çeşitli şekillerde yazılır:"

#: library/stdtypes.rst:1517
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Tek tırnak: ``'katıştırılmış \"çift\" tırnaklara izin verir'``"

#: library/stdtypes.rst:1518
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "Çift tırnak: ``\"katıştırılmış 'tek' tırnaklara izin verir\"``"

#: library/stdtypes.rst:1519
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double quotes\"\"\"``"
msgstr "Üçlü tırnak: ``'''Üç tek tırnak'''``, ``\"\"\"Üç çift tırnak\"\"\"``"

#: library/stdtypes.rst:1521
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace will "
"be included in the string literal."
msgstr ""
"Üçlü tırnak içine alınmış dizeler birden çok satıra yayılabilir - ilişkili tüm "
"boşluklar dize değişmezine dahil edilecektir."

#: library/stdtypes.rst:1524
msgid ""
"String literals that are part of a single expression and have only whitespace "
"between them will be implicitly converted to a single string literal. That is, "
"``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Tek bir ifadenin parçası olan ve aralarında yalnızca boşluk bulunan dize "
"değişmezleri, örtük olarak tek bir dize değişmezine dönüştürülür. Yani, "
"``(\"spam\" \"yumurtalar\") == \"spam yumurtalar\"``."

#: library/stdtypes.rst:1528
msgid ""
"See :ref:`strings` for more about the various forms of string literal, including "
"supported escape sequences, and the ``r`` (\"raw\") prefix that disables most "
"escape sequence processing."
msgstr ""
"Desteklenen kaçış dizileri ve çoğu kaçış dizisi işlemeyi devre dışı bırakan "
"``r`` (\"raw\", Türkçesiyle \"ham\") ön eki dahil olmak üzere dize değişmezinin "
"çeşitli biçimleri hakkında daha fazla bilgi için bkz. :ref:`strings`."

#: library/stdtypes.rst:1532
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Dizeler, :class:`str` yapıcısı kullanılarak diğer nesnelerden de oluşturulabilir."

#: library/stdtypes.rst:1535
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Ayrı bir \"karakter\" türü olmadığından, bir dizenin indekslenmesi 1 uzunluğunda "
"dizeler üretir. Yani, boş olmayan bir *s* dizesi için ``s[0] == s[0:1]``."

#: library/stdtypes.rst:1541
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple fragments."
msgstr ""
"Değiştirilebilir bir dize türü de yoktur, ancak :meth:`str.join` veya :class:`io."
"StringIO` birden çok parçadan dizeleri verimli bir şekilde oluşturmak için "
"kullanılabilir."

#: library/stdtypes.rst:1545
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is once "
"again permitted on string literals. It has no effect on the meaning of string "
"literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Python 2 serisiyle geriye dönük uyumluluk için, dize değişmezlerinde ``u`` ön "
"ekine izin verilir. Bunun dize değişmezlerinin anlamı üzerinde hiçbir etkisi "
"yoktur ve ``r`` ön ekiyle birleştirilemez."

#: library/stdtypes.rst:1557
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"*nesne* 'nin :ref:`string <textseq>` sürümünü döndürür. *nesne* sağlanmazsa boş "
"dizeyi döndürür.  Aksi takdirde, ``str()`` davranışı, aşağıdaki gibi *kodlama* "
"veya *hatalar* 'ın verilmesine bağlıdır."

#: library/stdtypes.rst:1561
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" or "
"nicely printable string representation of *object*.  For string objects, this is "
"the string itself.  If *object* does not have a :meth:`~object.__str__` method, "
"then :func:`str` falls back to returning :func:`repr(object) <repr>`."
msgstr ""
"Ne *encoding* ne de *errors* verilmezse, ``str(object)`` :meth:`type(object)."
"__str__(object) <object.__str__>` değerini döndürür, bu da \"gayri resmi\" veya "
"güzel bir şekilde yazdırılabilir *nesnenin* dize temsili. Dize nesneleri için "
"bu, dizenin kendisidir. *object*'in :meth:`~object.__str__` yöntemi yoksa, :func:"
"`str`, :func:`repr(object) <repr>` döndürmeye geri döner."

#: library/stdtypes.rst:1573
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :term:"
"`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In this case, "
"if *object* is a :class:`bytes` (or :class:`bytearray`) object, then "
"``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes.decode(encoding, "
"errors) <bytes.decode>`.  Otherwise, the bytes object underlying the buffer "
"object is obtained before calling :meth:`bytes.decode`.  See :ref:`binaryseq` "
"and :ref:`bufferobjects` for information on buffer objects."
msgstr ""
"*kodlama* veya *hatalar* 'dan en az biri verilirse, *nesne* bir :term:`bytes-"
"like object` olmalıdır (ör. :class:`bytes` veya :class:`bytearray`).  Bu "
"durumda, *nesne* bir :class:`bytes` (veya :class:`bytearray`) nesnesiyse "
"``str(bytes, *kodlama*, *hatalar*)``, :meth:`bytes.decode(*kodlama*, *hatalar*) "
"<bytes.decode>` 'a eş değerdir.  Aksi takdirde, arabellek nesnesinin altında "
"yatan bayt nesnesi, :meth:`bytes.decode` çağrılmadan önce elde edilir.  "
"Arabellek nesneleri hakkında bilgi için bkz. :ref:`binaryseq` ve :ref:"
"`bufferobjects`."

#: library/stdtypes.rst:1582
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal string "
"representation (see also the :option:`-b` command-line option to Python).  For "
"example::"
msgstr ""
"Bir :class:`bytes` nesnesini *kodlama* veya *hatalar* argümanları olmadan :func:"
"`str` 'ye iletmek, gayriresmi dize temsilini döndürmenin ilk durumuna girer "
"(ayrıca bkz. Python için :option:`-b` komut satırı seçeneği).  Örneğin::"

#: library/stdtypes.rst:1590
msgid ""
"For more information on the ``str`` class and its methods, see :ref:`textseq` "
"and the :ref:`string-methods` section below.  To output formatted strings, see "
"the :ref:`f-strings` and :ref:`formatstrings` sections.  In addition, see the :"
"ref:`stringservices` section."
msgstr ""
"``str`` sınıfı ve metotları hakkında daha fazla bilgi için aşağıdaki :ref:"
"`textseq` ve :ref:`string-methods` bölümüne bakın.  Biçimlendirilmiş dizelerin "
"çıktısını almak için :ref:`f-strings` ve :ref:`formatstrings` bölümlerine "
"bakın.  Ayrıca, :ref:`stringservices` bölümüne de bakın."

#: library/stdtypes.rst:1602
msgid "String Methods"
msgstr "String (Dize) Metotları"

#: library/stdtypes.rst:1607
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Dizeler, aşağıda açıklanan ek yöntemlerle birlikte tüm :ref:`ortak <typesseq-"
"common>` dizi işlemlerini uygular."

#: library/stdtypes.rst:1610
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Dizeler aynı zamanda iki dize biçimlendirme stilini de destekler; biri büyük "
"ölçüde esneklik ve özelleştirme sağlar (bkz. :meth:`str.format`, :ref:"
"`formatstrings` ve :ref:`string-formatting`) ve diğeri Daha dar bir tür "
"aralığını işleyen ve doğru şekilde kullanılması biraz daha zor olan, ancak "
"işleyebileceği durumlar için genellikle daha hızlı olan C ``printf`` stili "
"biçimlendirmesidir (:ref:`old-string-formatting`)."

#: library/stdtypes.rst:1617
msgid ""
"The :ref:`textservices` section of the standard library covers a number of other "
"modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"Standart kütüphanenin :ref:`textservices` bölümü, metinle ilgili çeşitli "
"yardımcı programlar sağlayan bir dizi başka modülü kapsar (:mod:`re` modülündeki "
"normal ifade desteği dahil)."

#: library/stdtypes.rst:1623
msgid ""
"Return a copy of the string with its first character capitalized and the rest "
"lowercased."
msgstr ""
"İlk karakteri büyük ve geri kalanı küçük harf ile, dizenin bir kopyasını "
"döndürür."

#: library/stdtypes.rst:1626
msgid ""
"The first character is now put into titlecase rather than uppercase. This means "
"that characters like digraphs will only have their first letter capitalized, "
"instead of the full character."
msgstr ""
"İlk karakter artık büyük harf yerine başlık harfine konulmuştur. Bu, digraflar "
"gibi karakterlerin tam karakter yerine yalnızca ilk harflerinin büyük olacağı "
"anlamına gelir."

#: library/stdtypes.rst:1633
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Dizenin küçük harfe katlanmış bir kopyasını döndürür. Küçük harfe katlanmış "
"dizeler, büyük/küçük harfsiz eşleştirme için kullanılabilir."

#: library/stdtypes.rst:1636
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is intended "
"to remove all case distinctions in a string. For example, the German lowercase "
"letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is already lowercase, :meth:"
"`lower` would do nothing to ``'ß'``; :meth:`casefold` converts it to ``\"ss\"``."
msgstr ""
"Büyük harf katlama, harf küçültmeye (lowercasing) benzer ancak daha agresiftir, "
"çünkü bir dizedeki tüm büyük/küçük harf ayrımlarını kaldırmayı amaçlar. Örneğin, "
"Almanca küçük harf ``'ß'``, ``\"ss\"`` ile eş değerdir. Zaten küçük harf "
"olduğundan, :meth:`lower` ``'ß'`` için hiçbir şey yapmaz; :meth:`casefold` onu "
"``\"ss\"`` biçimine dönüştürür."

#: library/stdtypes.rst:1642
msgid ""
"The casefolding algorithm is `described in section 3.13 'Default Case Folding' "
"of the Unicode Standard <https://www.unicode.org/versions/Unicode15.0.0/ch03."
"pdf>`__."
msgstr ""
"Kasa katlama algoritması Unicode Standardı <https://www.unicode.org/versions/"
"Unicode15.0.0/ch03.pdf> 3.13 'Varsayılan Vaka Katlama' bölümünde açıklanmıştır."

#: library/stdtypes.rst:1651
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"*width* uzunluğundaki bir dizede ortalanmış olarak döndürür. Doldurma, "
"belirtilen *fillchar* kullanılarak yapılır (varsayılanı bir ASCII boşluğudur). "
"*width*, ``len(s)`` değerinden küçük veya ona eşitse orijinal dize döndürülür."

#: library/stdtypes.rst:1659
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the range "
"[*start*, *end*].  Optional arguments *start* and *end* are interpreted as in "
"slice notation."
msgstr ""
"[*start*, *end*] aralığında *sub* alt dizesinin örtüşmeyen oluşumlarının "
"sayısını döndürür. İsteğe bağlı bağımsız değişkenler *start* ve *end*, dilim "
"notasyonunda olduğu gibi yorumlanır."

#: library/stdtypes.rst:1663
msgid ""
"If *sub* is empty, returns the number of empty strings between characters which "
"is the length of the string plus one."
msgstr ""
"Sub* boşsa, karakterler arasındaki boş dizelerin sayısını döndürür; bu sayı "
"dizenin uzunluğu artı birdir."

#: library/stdtypes.rst:1669
msgid "Return the string encoded to :class:`bytes`."
msgstr ":class:`bytes` olarak kodlanmış dizeyi döndürün."

#: library/stdtypes.rst:2810
msgid ""
"*encoding* defaults to ``'utf-8'``; see :ref:`standard-encodings` for possible "
"values."
msgstr ""
"*kodlama* varsayılan olarak ``'utf-8'`` şeklindedir; Olası değerler için :ref:"
"`standart kodlamalar`a bakın."

#: library/stdtypes.rst:1674
msgid ""
"*errors* controls how encoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values are "
"``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` and "
"any other name registered via :func:`codecs.register_error`. See :ref:`error-"
"handlers` for details."
msgstr ""
"*errors* kodlama hatalarının nasıl ele alınacağını kontrol eder. Eğer "
"``'strict'`` (varsayılan) ise, bir :exc:`UnicodeError` istisnası oluşturulur. "
"Diğer olası değerler ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` ve :func:`codecs.register_error` ile kaydedilen diğer "
"isimlerdir. Ayrıntılar için :ref:`error-handlers` bölümüne bakınız."

#: library/stdtypes.rst:1681
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless an encoding error actually occurs, :ref:`devmode` is enabled or a :ref:"
"`debug build <debug-build>` is used."
msgstr ""
"Performans nedenleriyle, gerçekten bir kodlama hatası oluşmadıkça, :ref:"
"`devmode` etkinleştirilmedikçe veya :ref:`debug build <debug-build>` "
"kullanılmadıkça *errors* değeri geçerlilik açısından kontrol edilmez."

#: library/stdtypes.rst:2829
msgid "Added support for keyword arguments."
msgstr "Anahtar kelime argümanları için destek eklendi."

#: library/stdtypes.rst:2832
msgid ""
"The value of the *errors* argument is now checked in :ref:`devmode` and in :ref:"
"`debug mode <debug-build>`."
msgstr ""
"*errors* şimdi :ref:`devmode` ve :ref:`hata ayıklama modunda <debug-build>` "
"kontrol edilir."

#: library/stdtypes.rst:1696
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise return "
"``False``.  *suffix* can also be a tuple of suffixes to look for.  With optional "
"*start*, test beginning at that position.  With optional *end*, stop comparing "
"at that position."
msgstr ""
"Dize belirtilen *suffix* ile bitiyorsa ``True``, aksi takdirde ``False`` "
"döndürür. *suffix* ayrıca aranacak bir son ek grubu da olabilir. İsteğe bağlı "
"*start* ile, o konumdan başlayarak test edin. İsteğe bağlı *end* ile, o konumda "
"karşılaştırmayı bırakın."

#: library/stdtypes.rst:1704
msgid ""
"Return a copy of the string where all tab characters are replaced by one or more "
"spaces, depending on the current column and the given tab size.  Tab positions "
"occur every *tabsize* characters (default is 8, giving tab positions at columns "
"0, 8, 16 and so on).  To expand the string, the current column is set to zero "
"and the string is examined character by character.  If the character is a tab "
"(``\\t``), one or more space characters are inserted in the result until the "
"current column is equal to the next tab position. (The tab character itself is "
"not copied.)  If the character is a newline (``\\n``) or return (``\\r``), it is "
"copied and the current column is reset to zero.  Any other character is copied "
"unchanged and the current column is incremented by one regardless of how the "
"character is represented when printed."
msgstr ""
"Geçerli sütuna ve verilen tab boyutuna bağlı olarak, tüm tab karakterlerinin bir "
"veya daha fazla boşlukla değiştirildiği dizenin bir kopyasını döndürür.  Tab "
"konumları her *tab boyutu* karakterinde oluşur (varsayılan 8'dir, 0, 8, 16 ve "
"benzeri sütunlarda tab konumları verilir).  Dizeyi genişletmek için mevcut sütun "
"sıfıra ayarlanır ve dize karakter karakter incelenir. Karakter bir tab ise "
"(``\\t``), geçerli sütun sonraki tab konumuna eşit olana kadar sonuca bir veya "
"daha fazla boşluk karakteri eklenir. (Tab karakterinin kendisi kopyalanmaz.)  "
"Karakter yeni satırsa (``\\n``) veya dönüşse (``\\r``), kopyalanır ve mevcut "
"sütun sıfırlanır.  Diğer herhangi bir karakter değiştirilmeden kopyalanır ve "
"mevcut sütun, karakterin yazdırıldığında nasıl temsil edildiğine bakılmaksızın "
"bir artırılır."

#: library/stdtypes.rst:1725
msgid ""
"Return the lowest index in the string where substring *sub* is found within the "
"slice ``s[start:end]``.  Optional arguments *start* and *end* are interpreted as "
"in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"*sub* alt dizesinin ``s[start:end]`` diliminde bulunduğu dizedeki en düşük "
"dizini döndür.  İsteğe bağlı argümanlar *start* ve *end*, dilim notasyonunda "
"olduğu gibi yorumlanır. *sub* bulunamazsa ``-1`` döndürür."

#: library/stdtypes.rst:1731
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :keyword:"
"`in` operator::"
msgstr ""
":meth:`~str.find` metodu yalnızca *sub* öğesinin konumunu bilmeniz gerekiyorsa "
"kullanılmalıdır.  *sub* 'ın bir alt dize olup olmadığını kontrol etmek için :"
"keyword:`in` operatörünü kullanın::"

#: library/stdtypes.rst:1741
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces ``{}"
"``.  Each replacement field contains either the numeric index of a positional "
"argument, or the name of a keyword argument.  Returns a copy of the string where "
"each replacement field is replaced with the string value of the corresponding "
"argument."
msgstr ""
"Bir dize biçimlendirme işlemi gerçekleştirin. Bu yöntemin çağrıldığı dize, "
"parantez ``{}`` ile sınırlandırılmış metin veya değiştirme alanları içerebilir.  "
"Her değiştirme alanı, ya bir konumsal (sırası önemli) argümanın sayısal dizinini "
"ya da bir anahtar sözcük argmünanının adını içerir. Her değiştirme alanının, "
"karşılık gelen argümanın dize değeriyle değiştirildiği dizenin bir kopyasını "
"döndürür."

#: library/stdtypes.rst:1751
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Biçim dizelerinde (f string) belirtilebilecek çeşitli biçimlendirme "
"seçeneklerinin açıklaması için bkz. :ref:`formatstrings`."

#: library/stdtypes.rst:1755
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :class:"
"`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to the "
"``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` fields "
"of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, and the "
"``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  This temporary "
"change affects other threads."
msgstr ""
"Bir sayıyı (:class:`int`, :class:`float`, :class:`complex`, :class:`decimal."
"Decimal` ve alt sınıfları) ``n`` türüyle biçimlendirirken (örn: ``'{:n}'. "
"format(1234)``), işlev :c:func:`localeconv` öğesinin ``decimal_point`` ve "
"``thousands_sep`` alanlarını ASCII değilse veya 1 bayttan uzunsa ve "
"``LC_NUMERIC`` yerel ayarı ``LC_CTYPE`` yerel ayarından farklıysa kod çözmek "
"için ``LC_CTYPE`` yerel ayarını geçici olarak ``LC_NUMERIC`` yerel ayarına "
"ayarlar.  Bu geçici değişiklik diğer iş parçacıklarını etkiler."

#: library/stdtypes.rst:1764
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily the "
"``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"Bir sayıyı ``n`` türüyle biçimlendirirken, fonksiyon bazı durumlarda "
"``LC_CTYPE`` yerel ayarını geçici olarak ``LC_NUMERIC`` yerel ayarına ayarlar."

#: library/stdtypes.rst:1772
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used directly "
"and not copied to a :class:`dict`.  This is useful if for example ``mapping`` is "
"a dict subclass:"
msgstr ""
"``str.format(**mapping)`` ile benzerdir, ancak ``mapping`` doğrudan kullanılır "
"ve bir :class:`dict` 'e kopyalanmaz.  Örneğin, ``mapping`` bir dict alt sınıfı "
"ise bu kullanışlıdır:"

#: library/stdtypes.rst:1788
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is not "
"found."
msgstr ""
":meth:`~str.find` gibi, ancak alt dize bulunamadığında :exc:`ValueError` "
"yükseltir."

#: library/stdtypes.rst:1794
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there is at "
"least one character, ``False`` otherwise.  A character ``c`` is alphanumeric if "
"one of the following returns ``True``: ``c.isalpha()``, ``c.isdecimal()``, ``c."
"isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Dizedeki tüm karakterler alfanümerikse ve en az bir karakter varsa ``True``, "
"aksi takdirde ``False`` döndürür.  Bir ``c`` karakteri, aşağıdakilerden biri "
"``True`` döndürüyorsa alfasayısaldır: ``c.isalpha()``, ``c.isdecimal()``, ``c."
"isdigit()`` veya ``c.isnumeric()``."

#: library/stdtypes.rst:1802
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is at "
"least one character, ``False`` otherwise.  Alphabetic characters are those "
"characters defined in the Unicode character database as \"Letter\", i.e., those "
"with general category property being one of \"Lm\", \"Lt\", \"Lu\", \"Ll\", or "
"\"Lo\".  Note that this is different from the `Alphabetic property defined in "
"the section 4.10 'Letters, Alphabetic, and Ideographic' of the Unicode Standard "
"<https://www.unicode.org/versions/Unicode15.0.0/ch04.pdf>`_."
msgstr ""
"Dizedeki tüm karakterler alfabetikse ve en az bir karakter varsa ``True``, aksi "
"takdirde ``False`` döndürür.  Alfabetik karakterler, Unicode karakter "
"veritabanında \"Harf\" olarak tanımlanan karakterlerdir, yani genel kategori "
"özelliği \"Lm\", \"Lt\", \"Lu\", \"Ll\" veya \"Lo \"dan biri olan "
"karakterlerdir.  Bunun Unicode Standardında tanımlanan \"Alfabetik\" "
"özelliğinden farklı olduğunu unutmayın."

#: library/stdtypes.rst:1813
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""
"Dize boşsa veya dizedeki tüm karakterler ASCII ise ``True``, aksi takdirde "
"``False`` döndürür. ASCII karakterleri U+0000-U+007F aralığında kod noktalarına "
"sahiptir."

#: library/stdtypes.rst:1822
msgid ""
"Return ``True`` if all characters in the string are decimal characters and there "
"is at least one character, ``False`` otherwise. Decimal characters are those "
"that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT "
"ZERO.  Formally a decimal character is a character in the Unicode General "
"Category \"Nd\"."
msgstr ""
"Dizedeki tüm karakterler ondalık karakter ise ve en az bir karakter varsa "
"``True``, aksi takdirde ``False`` döndürür. Ondalık karakterler 10 tabanında "
"sayılar oluşturmak için kullanılabilen karakterlerdir, örneğin U+0660, ARAPÇA-"
"HİNTÇE RAKAM SIFIR.  Resmi olarak bir ondalık karakter Unicode Genel Kategorisi "
"\"Nd\" içerisindeki bir karakterdir."

#: library/stdtypes.rst:1832
msgid ""
"Return ``True`` if all characters in the string are digits and there is at least "
"one character, ``False`` otherwise.  Digits include decimal characters and "
"digits that need special handling, such as the compatibility superscript digits. "
"This covers digits which cannot be used to form numbers in base 10, like the "
"Kharosthi numbers.  Formally, a digit is a character that has the property value "
"Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Dizedeki tüm karakterler rakamsa ve en az bir karakter varsa ``True``, aksi "
"takdirde ``False`` döndürür.  Rakamlar ondalık karakterleri ve özel işlem "
"gerektiren rakamları (uyumluluk üst simge rakamları gibi) içerir. Bu, Kharosthi "
"sayıları gibi 10 tabanında sayı oluşturmak için kullanılamayan rakamları "
"kapsar.  Resmi olarak rakam, Numeric_Type=Digit veya Numeric_Type=Decimal "
"özellik değerine sahip bir karakterdir."

#: library/stdtypes.rst:1842
msgid ""
"Return ``True`` if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`."
msgstr ""
":ref:`identifiers` bölümüne göre dizge dil tanımına göre geçerli bir tanımlayıcı "
"ise ``True`` döndürür."

#: library/stdtypes.rst:1845
msgid ""
":func:`keyword.iskeyword` can be used to test whether string ``s`` is a reserved "
"identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
":func:`keyword.iskeyword`, ``s`` dizesinin :keyword:`def` ve :keyword:`class` "
"gibi ayrılmış bir tanımlayıcı olup olmadığını test etmek için kullanılabilir."

#: library/stdtypes.rst:1848
msgid "Example: ::"
msgstr "Örnek: ::"

#: library/stdtypes.rst:1861
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Dizedeki tüm büyük harfli karakterler [4]_ küçük harfli ise ve en az bir büyük "
"harfli karakter varsa ``True``, aksi takdirde ``False`` döndürür."

#: library/stdtypes.rst:1867
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters include "
"digit characters, and all characters that have the Unicode numeric value "
"property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric characters "
"are those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or "
"Numeric_Type=Numeric."
msgstr ""
"Dizedeki tüm karakterler sayısal karakterlerse ve en az bir karakter varsa "
"``True``, aksi takdirde ``False`` döndürür. Sayısal karakterler rakam "
"karakterlerini ve Unicode sayısal değer özelliğine sahip tüm karakterleri "
"içerir, örneğin U+2155, VULGAR FRAKSİYONU BEŞİNCİ.  Resmi olarak, sayısal "
"karakterler Numeric_Type=Digit, Numeric_Type=Decimal veya Numeric_Type=Numeric "
"özellik değerine sahip karakterlerdir."

#: library/stdtypes.rst:1877
msgid ""
"Return ``True`` if all characters in the string are printable or the string is "
"empty, ``False`` otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped when :"
"func:`repr` is invoked on a string.  It has no bearing on the handling of "
"strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Dizedeki tüm karakterler yazdırılabilirse veya dize boşsa ``True``, aksi "
"takdirde ``False`` döndürür.  Yazdırılamayan karakterler, yazdırılabilir olarak "
"kabul edilen ASCII boşluğu (0x20) dışında, Unicode karakter veritabanında "
"\"Diğer\" veya \"Ayırıcı\" olarak tanımlanan karakterlerdir.  (Bu bağlamda, "
"yazdırılabilir karakterlerin :func:`repr` bir dize üzerinde çağrıldığında "
"kaçılmaması gereken karakterler olduğunu unutmayın.  Bunun :data:`sys.stdout` "
"veya :data:`sys.stderr` dosyalarına yazılan dizelerin işlenmesiyle bir ilgisi "
"yoktur)"

#: library/stdtypes.rst:1888
msgid ""
"Return ``True`` if there are only whitespace characters in the string and there "
"is at least one character, ``False`` otherwise."
msgstr ""
"Dizede yalnızca boşluk karakterleri varsa ve en az bir karakter varsa ``True``, "
"aksi takdirde ``False`` döndürür."

#: library/stdtypes.rst:1891
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, space\"), or "
"its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"Bir karakter, genel kategorisi ``Zs`` (“Ayırıcı, boşluk”) ya da çift yönlü "
"sınıfı ``WS``, ``B`` veya ``S``’den biri ise Unicode karakter veritabanında "
"(bkz. :mod:`unicodedata`) *beyaz boşluk karakteri*’dir."

#: library/stdtypes.rst:1899
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least one "
"character, for example uppercase characters may only follow uncased characters "
"and lowercase characters only cased ones.  Return ``False`` otherwise."
msgstr ""
"Eğer dizenin yalnızca ilk harfi büyük ise ve en az bir karakter varsa ``True`` "
"döndürür. Örneğin, büyük harfli karakterler sadece küçük harfli karakterleri ve "
"küçük harfli karakterler sadece büyük harfli karakterleri takip edebilir.  Aksi "
"takdirde ``False`` döndürür."

#: library/stdtypes.rst:1906
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Dizedeki tüm karakterler [4]_ büyük harfli ise ve en az bir büyük harfli "
"karakter varsa ``True``, aksi takdirde ``False`` döndürür."

#: library/stdtypes.rst:1924
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :exc:"
"`TypeError` will be raised if there are any non-string values in *iterable*, "
"including :class:`bytes` objects.  The separator between elements is the string "
"providing this method."
msgstr ""
"*iterable* içindeki dizgelerin birleşiminden oluşan bir dizge döndürür. Eğer "
"*iterable* içinde :class:`bytes` nesneleri de dahil olmak üzere string olmayan "
"değerler varsa bir :exc:`TypeError` oluşacaktır.  Öğeler arasındaki ayırıcı, bu "
"yöntemi sağlayan dizedir."

#: library/stdtypes.rst:1932
msgid ""
"Return the string left justified in a string of length *width*. Padding is done "
"using the specified *fillchar* (default is an ASCII space). The original string "
"is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"*width* uzunluğundaki bir dizeyi sola hizalanmış olarak döndürür. Doldurma, "
"belirtilen *fillchar* kullanılarak yapılır (varsayılanı bir ASCII boşluğudur). "
"*width*, ``len(s)`` değerinden küçük veya ona eşitse orijinal dize döndürülür."

#: library/stdtypes.rst:1939
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Dizenin tüm büyük harfli karakterlerini [4]_ küçük harfe dönüştürerek bir "
"kopyasını döndürür."

#: library/stdtypes.rst:1942
msgid ""
"The lowercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/Unicode15.0.0/"
"ch03.pdf>`__."
msgstr ""
"Kullanılan küçük harf algoritması 'Unicode Standardı'nın <https://www.unicode."
"org/versions/Unicode15.0.0/ch03.pdf> 3.13 'Varsayılan Harf Katlaması' bölümünde "
"açıklanmıştır."

#: library/stdtypes.rst:1949
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If omitted "
"or ``None``, the *chars* argument defaults to removing whitespace.  The *chars* "
"argument is not a prefix; rather, all combinations of its values are stripped::"
msgstr ""
"Dizenin baştaki karakterleri çıkarılmış bir kopyasını döndürür.  *chars* "
"bağımsız değişkeni, kaldırılacak karakter kümesini belirten bir dizedir.  "
"Atlanırsa veya ``None`` olursa, *chars* bağımsız değişkeni varsayılan olarak "
"boşlukları kaldırır.  *chars* bağımsız değişkeni bir ön ek değildir; bunun "
"yerine, değerlerinin tüm kombinasyonları çıkarılır::"

#: library/stdtypes.rst:1959
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Bir karakter kümesinin tüm ön ekleri yerine tek bir ön ek dizesini kaldıracak "
"bir yöntem için :meth:`str.removeprefix` bölümüne bakın.  Örneğin::"

#: library/stdtypes.rst:1970
msgid ""
"This static method returns a translation table usable for :meth:`str.translate`."
msgstr ""
"Bu statik yöntem :meth:`str.translate` için kullanılabilecek bir çeviri tablosu "
"döndürür."

#: library/stdtypes.rst:1972
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode ordinals "
"(integers) or characters (strings of length 1) to Unicode ordinals, strings (of "
"arbitrary lengths) or ``None``.  Character keys will then be converted to "
"ordinals."
msgstr ""
"Yalnızca bir bağımsız değişken varsa, Unicode sıradanlarını (tamsayılar) veya "
"karakterlerini (1 uzunluğundaki dizeler) Unicode sıradanlarına, dizelere (isteğe "
"bağlı uzunluklarda) veya ``None`` değerine eşleyen bir sözlük olmalıdır.  "
"Karakter anahtarları daha sonra sıradanlara dönüştürülecektir."

#: library/stdtypes.rst:1977
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at the "
"same position in y.  If there is a third argument, it must be a string, whose "
"characters will be mapped to ``None`` in the result."
msgstr ""
"İki bağımsız değişken varsa, bunlar eşit uzunlukta dizgeler olmalıdır. Sözlüğün "
"son halinde x'teki her karakter y'de aynı konumdaki karakterle eşlenecektir. "
"Üçüncü bir bağımsız değişken varsa, karakterleri sonuçta ``None`` ile eşlenecek "
"bir dizge olmalıdır."

#: library/stdtypes.rst:1985
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple containing "
"the string itself, followed by two empty strings."
msgstr ""
"Dizeyi *sep* öğesinin ilk geçtiği yerden böler ve ayırıcıdan önceki kısmı, "
"ayırıcının kendisini ve ayırıcıdan sonraki kısmı içeren bir 3'lü döndürür.  "
"Ayırıcı bulunamazsa, dizenin kendisini ve ardından iki boş dizeyi içeren bir "
"3'lü döndürür."

#: library/stdtypes.rst:1993
msgid ""
"If the string starts with the *prefix* string, return ``string[len(prefix):]``. "
"Otherwise, return a copy of the original string::"
msgstr ""
"Eğer dize *prefix* dizesi ile başlıyorsa, ``dize[len(prefix):]`` döndürür. Aksi "
"takdirde, orijinal dizgenin bir kopyasını döndürür::"

#: library/stdtypes.rst:2007
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"Dize *suffix* (son ek) dizesiyle bitiyorsa ve bu *suffix* boş değilse, ``dize[:-"
"len(suffix)]`` döndürür. Aksi takdirde, orijinal dizenin bir kopyasını döndürür::"

#: library/stdtypes.rst:2021
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced by "
"*new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"Dizenin, *eski* alt dizesinin tüm oluşumları *yeni* ile değiştirilmiş bir "
"kopyasını döndürür.  İsteğe bağlı olarak *count* bağımsız değişkeni verilirse, "
"yalnızca ilk *count* oluşumu değiştirilir."

#: library/stdtypes.rst:2028
msgid ""
"Return the highest index in the string where substring *sub* is found, such that "
"*sub* is contained within ``s[start:end]``.  Optional arguments *start* and "
"*end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Dizede *sub* alt dizesinin bulunduğu en yüksek dizini döndürür, öyle ki *sub* "
"``s[start:end]`` içinde yer alır.  İsteğe bağlı argümanlar *start* ve *end* "
"dilim gösterimindeki gibi yorumlanır.  Başarısızlık durumunda ``-1`` döndürür."

#: library/stdtypes.rst:2035
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is not "
"found."
msgstr ""
":meth:`rfind` gibi, ancak *sub* alt dizesi bulunamadığında :exc:`ValueError` "
"yükseltir."

#: library/stdtypes.rst:2041
msgid ""
"Return the string right justified in a string of length *width*. Padding is done "
"using the specified *fillchar* (default is an ASCII space). The original string "
"is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"*width* uzunluğundaki bir dizeyi sağa hizalanmış olarak döndürür. Doldurma, "
"belirtilen *fillchar* kullanılarak yapılır (varsayılanı bir ASCII boşluğudur). "
"*width*, ``len(s)`` değerinden küçük veya ona eşitse orijinal dize döndürülür."

#: library/stdtypes.rst:2048
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple containing "
"two empty strings, followed by the string itself."
msgstr ""
"Dizeyi *sep* öğesinin ilk geçtiği yerden böler ve ayırıcıdan önceki kısmı, "
"ayırıcının kendisini ve ayırıcıdan sonraki kısmı içeren bir 3'lü döndürür.  "
"Ayırıcı bulunamazsa, dizenin kendisini ve ardından iki boş dizeyi içeren bir "
"3'lü döndürür."

#: library/stdtypes.rst:2056
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter string. "
"If *maxsplit* is given, at most *maxsplit* splits are done, the *rightmost* "
"ones.  If *sep* is not specified or ``None``, any whitespace string is a "
"separator.  Except for splitting from the right, :meth:`rsplit` behaves like :"
"meth:`split` which is described in detail below."
msgstr ""
"Ayırıcı dizge olarak *sep* kullanarak dizgedeki sözcüklerin bir listesini "
"döndürür. Eğer *maxsplit* belirtilmişse, *rightmost* olmak üzere en fazla "
"*maxsplit* bölme yapılır.  Eğer *sep* belirtilmemişse veya ``None`` ise, "
"herhangi bir boşluk dizesi ayırıcıdır.  Sağdan bölme dışında, :meth:`rsplit` "
"aşağıda ayrıntılı olarak açıklanan :meth:`split` gibi davranır."

#: library/stdtypes.rst:2065
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If omitted "
"or ``None``, the *chars* argument defaults to removing whitespace.  The *chars* "
"argument is not a suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Dizenin en sondaki karakterleri çıkarılmış bir kopyasını döndürür.  *chars* "
"bağımsız değişkeni, kaldırılacak karakter kümesini belirten bir dizedir.  "
"Atlanırsa veya ``None`` olursa, *chars* bağımsız değişkeni varsayılan olarak "
"boşlukları kaldırır.  *chars* bağımsız değişkeni bir ön ek değildir; bunun "
"yerine, değerlerinin tüm kombinasyonları çıkarılır::"

#: library/stdtypes.rst:2075
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Bir karakter kümesinin tüm son ekleri yerine tek bir son ek dizesini kaldıracak "
"bir yöntem için :meth:`str.removeprefix` bölümüne bakın.  Örneğin::"

#: library/stdtypes.rst:2085
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter string.  "
"If *maxsplit* is given, at most *maxsplit* splits are done (thus, the list will "
"have at most ``maxsplit+1`` elements).  If *maxsplit* is not specified or "
"``-1``, then there is no limit on the number of splits (all possible splits are "
"made)."
msgstr ""
"Ayırıcı dizge olarak *sep* kullanarak dizgedeki sözcüklerin bir listesini "
"döndürür.  Eğer *maxsplit* belirtilmişse, en fazla *maxsplit* bölme işlemi "
"yapılır (dolayısıyla, liste en fazla ``maxsplit+1`` elemana sahip olur).  Eğer "
"*maxsplit* belirtilmemişse veya ``-1`` ise, bölme sayısında bir sınırlama yoktur "
"(tüm olası bölmeler yapılır)."

#: library/stdtypes.rst:2091
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters (for "
"example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). Splitting an "
"empty string with a specified separator returns ``['']``."
msgstr ""
"*sep* verilirse, ardışık sınırlayıcılar birlikte gruplanmaz ve boş dizeleri "
"sınırladıkları kabul edilir (örneğin, ``'1,,2'.split(',')``, ``['1', '', '2']`` "
"döndürür). *sep* bağımsız değişkeni birden çok karakterden oluşabilir (örneğin, "
"``'1<>2<>3'.split('<>')``, ``['1', '2', '3']`` döndürür). Boş bir dizeyi "
"belirtilen bir ayırıcıyla bölmek ``['']`` döndürür."

#: library/stdtypes.rst:2113 library/stdtypes.rst:2233 library/stdtypes.rst:3148
#: library/stdtypes.rst:3255 library/stdtypes.rst:3296 library/stdtypes.rst:3338
#: library/stdtypes.rst:3370 library/stdtypes.rst:3420 library/stdtypes.rst:3489
#: library/stdtypes.rst:3513
msgid "For example::"
msgstr "Örneğin: ::"

#: library/stdtypes.rst:2106
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, and "
"the result will contain no empty strings at the start or end if the string has "
"leading or trailing whitespace.  Consequently, splitting an empty string or a "
"string consisting of just whitespace with a ``None`` separator returns ``[]``."
msgstr ""
"Eğer *sep* belirtilmemişse veya ``None`` ise, farklı bir bölme algoritması "
"uygulanır: ardışık boşluk dizileri tek bir ayırıcı olarak kabul edilir ve "
"dizgenin başında veya sonunda boşluk varsa, sonucun başında veya sonunda boş "
"dizeler olmaz. Dolayısıyla, boş bir dizeyi veya sadece beyaz boşluktan oluşan "
"bir dizeyi ``None`` ayırıcısıyla bölmek ``[]`` döndürür."

#: library/stdtypes.rst:2128
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Satır sınırlarında keserek dizedeki satırların bir listesini döndürür.  Satır "
"sonları için *keepends* belirtilmediği ve true değerinde olmadığı sürece, satır "
"sonları sonuç listesine dahil edilmez."

#: library/stdtypes.rst:2132
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Bu yöntem aşağıdaki satır sınırlarında bölme yapar.  Spesifik olarak, sınırlar :"
"term:`universal newlines` 'ın bir üst kümesidir."

#: library/stdtypes.rst:2136
msgid "Representation"
msgstr "Temsil"

#: library/stdtypes.rst:2136
msgid "Description"
msgstr "Açıklama"

#: library/stdtypes.rst:2138
msgid "``\\n``"
msgstr "``\\n``"

#: library/stdtypes.rst:2138
msgid "Line Feed"
msgstr "Satır Atlama"

#: library/stdtypes.rst:2140
msgid "``\\r``"
msgstr "``\\r``"

#: library/stdtypes.rst:2140
msgid "Carriage Return"
msgstr "Satır Başına Alma"

#: library/stdtypes.rst:2142
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: library/stdtypes.rst:2142
msgid "Carriage Return + Line Feed"
msgstr "Satır Başına Alma + Satır Atlama"

#: library/stdtypes.rst:2144
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` or ``\\x0b``"

#: library/stdtypes.rst:2144
msgid "Line Tabulation"
msgstr "Satır Tablolama"

#: library/stdtypes.rst:2146
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` or ``\\x0c``"

#: library/stdtypes.rst:2146
msgid "Form Feed"
msgstr "Form Besleme"

#: library/stdtypes.rst:2148
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: library/stdtypes.rst:2148
msgid "File Separator"
msgstr "Dosya Ayırıcı"

#: library/stdtypes.rst:2150
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: library/stdtypes.rst:2150
msgid "Group Separator"
msgstr "Grup Ayırıcı"

#: library/stdtypes.rst:2152
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: library/stdtypes.rst:2152
msgid "Record Separator"
msgstr "Kayıt Ayırıcı"

#: library/stdtypes.rst:2154
msgid "``\\x85``"
msgstr "``\\x85``"

#: library/stdtypes.rst:2154
msgid "Next Line (C1 Control Code)"
msgstr "Yeni Satır (C1 Denetim Kodu)"

#: library/stdtypes.rst:2156
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: library/stdtypes.rst:2156
msgid "Line Separator"
msgstr "Satır Ayrıcı"

#: library/stdtypes.rst:2158
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: library/stdtypes.rst:2158
msgid "Paragraph Separator"
msgstr "Paragraf Ayırıcı"

#: library/stdtypes.rst:2163
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` ve ``\\f`` satır sınırlarına eklenir."

#: library/stdtypes.rst:2172
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this method "
"returns an empty list for the empty string, and a terminal line break does not "
"result in an extra line::"
msgstr ""
"Bir sınırlayıcı dize *sep* verildiğinde :meth:`~str.split` yönteminden farklı "
"olarak, bu yöntem boş dize için boş bir liste döndürür ve bir terminal satır "
"sonu fazladan bir satır ile sonuçlanmaz::"

#: library/stdtypes.rst:2181
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Kıyaslayacak olursak ``split(‘\\n’)`` şu değeri verir::"

#: library/stdtypes.rst:2191
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return ``False``. "
"*prefix* can also be a tuple of prefixes to look for.  With optional *start*, "
"test string beginning at that position.  With optional *end*, stop comparing "
"string at that position."
msgstr ""
"Dize *önek* ile başlıyorsa ``True`` döndürür, aksi takdirde ``False`` döndürür. "
"*prefix* ayrıca aranacak ön eklerin bir tuple'ı da olabilir.  İsteğe bağlı "
"*start* ile, o konumdan başlayan dizeyi sınar.  İsteğe bağlı *end* ile, dizeyi o "
"konumda karşılaştırmayı durdurur."

#: library/stdtypes.rst:2199
msgid ""
"Return a copy of the string with the leading and trailing characters removed. "
"The *chars* argument is a string specifying the set of characters to be removed. "
"If omitted or ``None``, the *chars* argument defaults to removing whitespace. "
"The *chars* argument is not a prefix or suffix; rather, all combinations of its "
"values are stripped::"
msgstr ""
"Dizenin baştaki ve sondaki karakterleri çıkarılmış bir kopyasını döndürür. "
"*chars* bağımsız değişkeni, kaldırılacak karakter kümesini belirten bir dizedir. "
"Atlanırsa veya ``None`` olursa, *chars* bağımsız değişkeni varsayılan olarak "
"boşlukları kaldırır. *chars* bağımsız değişkeni bir ön ek veya son ek değildir; "
"bunun yerine, değerlerinin tüm kombinasyonları çıkarılır::"

#: library/stdtypes.rst:2210
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from the "
"string. Characters are removed from the leading end until reaching a string "
"character that is not contained in the set of characters in *chars*. A similar "
"action takes place on the trailing end. For example::"
msgstr ""
"En dıştaki ön ve son*chars* bağımsız değişken değerleri dizeden çıkarılır. "
"Karakterler, *chars* içindeki karakter kümesinde bulunmayan bir dize karakterine "
"ulaşılana kadar önde gelen uçtan çıkarılır. Benzer bir işlem son uçta da "
"gerçekleşir. Örneğin::"

#: library/stdtypes.rst:2223
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase and "
"vice versa. Note that it is not necessarily true that ``s.swapcase().swapcase() "
"== s``."
msgstr ""
"Büyük harf karakterleri küçük harfe dönüştürülmüş veya tam tersi yapılmış "
"dizenin bir kopyasını döndürür. ``s.swapcase().swapcase() == s`` ifadesinin "
"mutlaka doğru olması gerekmediğine dikkat edin."

#: library/stdtypes.rst:2230
msgid ""
"Return a titlecased version of the string where words start with an uppercase "
"character and the remaining characters are lowercase."
msgstr ""
"Sözcüklerin büyük harfle başladığı ve kalan karakterlerin küçük harf olduğu "
"dizenin başlıklandırılmış bir sürümünü döndürür."

#: library/stdtypes.rst:3457
msgid ""
"The algorithm uses a simple language-independent definition of a word as groups "
"of consecutive letters.  The definition works in many contexts but it means that "
"apostrophes in contractions and possessives form word boundaries, which may not "
"be the desired result::"
msgstr ""
"Algoritma, bir kelimenin ardışık harf grupları olarak dilden bağımsız basit bir "
"tanımını kullanır.  Bu tanım birçok bağlamda işe yarar, ancak bu, kısaltmalar ve "
"iyeliklerdeki kesme işaretlerinin kelime sınırları oluşturduğu anlamına gelir ve "
"bu istenen sonuç olmayabilir::"

#: library/stdtypes.rst:2246
msgid ""
"The :func:`string.capwords` function does not have this problem, as it splits "
"words on spaces only."
msgstr ""
":func:`string.capwords` işlevinde bu sorun yoktur, çünkü sözcükleri yalnızca "
"boşluklara böler."

#: library/stdtypes.rst:2249
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr ""
"Alternatif olarak, normal ifadeler kullanılarak kesme işaretleri için geçici bir "
"çözüm oluşturulabilir::"

#: library/stdtypes.rst:2264
msgid ""
"Return a copy of the string in which each character has been mapped through the "
"given translation table.  The table must be an object that implements indexing "
"via :meth:`__getitem__`, typically a :term:`mapping` or :term:`sequence`.  When "
"indexed by a Unicode ordinal (an integer), the table object can do any of the "
"following: return a Unicode ordinal or a string, to map the character to one or "
"more other characters; return ``None``, to delete the character from the return "
"string; or raise a :exc:`LookupError` exception, to map the character to itself."
msgstr ""
"Her karakterin verilen çeviri tablosu aracılığıyla eşlendiği dizgenin bir "
"kopyasını döndürür.  Tablo, :meth:`__getitem__` aracılığıyla indeksleme "
"uygulayan bir nesne, tipik olarak bir :term:`mapping` veya :term:`sequence` "
"olmalıdır.  Bir Unicode sıra numarası (bir tamsayı) ile indekslendiğinde, tablo "
"nesnesi aşağıdakilerden herhangi birini yapabilir: karakteri bir veya daha fazla "
"başka karakterle eşlemek için bir Unicode sıra numarası veya bir dize döndürmek; "
"karakteri dönüş dizesinden silmek için ``None`` döndürmek; veya karakteri "
"kendisiyle eşlemek için bir :exc:`LookupError` istisnası oluşturmak."

#: library/stdtypes.rst:2273
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-to-"
"character mappings in different formats."
msgstr ""
"Farklı formatlardaki karakterden karaktere eşlemelerden bir çeviri haritası "
"oluşturmak için :meth:`str.maketrans` komutunu kullanabilirsiniz."

#: library/stdtypes.rst:2276
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"Özel karakter eşlemelerine daha esnek bir yaklaşım için ayrıca :mod:`codecs` "
"modülüne bakın."

#: library/stdtypes.rst:2282
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Tüm büyük harfli karakterlerin [4]_ büyük harfe dönüştürüldüğü dizenin bir "
"kopyasını döndürün. ``s.upper().isupper()``, eğer ``s`` büyük küçük harfe "
"dönüştürülmemiş karakterler içeriyorsa veya ortaya çıkan karakter(ler)in Unicode "
"kategorisi \"Lu\" değilse (Mektup) ``False`` olabileceğini unutmayın. , büyük "
"harf), ancak ör. \"Lt\" (Mektup, başlık)."

#: library/stdtypes.rst:2288
msgid ""
"The uppercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/Unicode15.0.0/"
"ch03.pdf>`__."
msgstr ""
"Kullanılan büyük harf algoritması 'Unicode Standardı'nın <https://www.unicode."
"org/versions/Unicode15.0.0/ch03.pdf> 3.13 'Varsayılan Harf Katlaması' bölümünde "
"açıklanmıştır."

#: library/stdtypes.rst:2295
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled by "
"inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Uzunluk *genişlik* uzunluğunda bir dize oluşturmak için soldaki dizenin ASCII "
"``'0'`` rakamlarıyla dolu bir kopyasını döndürün. Baştaki işaret öneki (``'+'``/"
"``'-'``), işaret karakterinin öncesine değil *sonrasına* dolgu eklenerek "
"işlenir. *width* ``len(s)`` değerinden küçük veya ona eşitse orijinal dize "
"döndürülür."

#: library/stdtypes.rst:2313
msgid "``printf``-style String Formatting"
msgstr "``printf`` tarzı Dize Biçimlendirmesi"

#: library/stdtypes.rst:2326
msgid ""
"The formatting operations described here exhibit a variety of quirks that lead "
"to a number of common errors (such as failing to display tuples and dictionaries "
"correctly).  Using the newer :ref:`formatted string literals <f-strings>`, the :"
"meth:`str.format` interface, or :ref:`template strings <template-strings>` may "
"help avoid these errors.  Each of these alternatives provides their own trade-"
"offs and benefits of simplicity, flexibility, and/or extensibility."
msgstr ""
"Burada açıklanan biçimlendirme işlemleri, bir dizi yaygın hataya (demetlerin ve "
"sözlüklerin doğru şekilde görüntülenememesi gibi) yol açan çeşitli tuhaflıklar "
"sergiler. Daha yeni :ref:`formatlı dize değişmezleri <f-strings>`, :meth:`str."
"format` arayüzü veya :ref:`template strings <template-strings>` kullanılması bu "
"hataların önlenmesine yardımcı olabilir. Bu alternatiflerin her biri kendi "
"dengelerini ve basitlik, esneklik ve/veya genişletilebilirlik faydalarını sağlar."

#: library/stdtypes.rst:2334
msgid ""
"String objects have one unique built-in operation: the ``%`` operator (modulo). "
"This is also known as the string *formatting* or *interpolation* operator. Given "
"``format % values`` (where *format* is a string), ``%`` conversion "
"specifications in *format* are replaced with zero or more elements of *values*. "
"The effect is similar to using the :c:func:`sprintf` in the C language."
msgstr ""
"Dize nesnelerinin benzersiz bir yerleşik işlemi vardır: ``%`` operatörü "
"(modulo). Bu aynı zamanda dize *biçimlendirme* veya *enterpolasyon* operatörü "
"olarak da bilinir. ``Biçim % değerleri`` (burada *format* bir dizedir) "
"verildiğinde, *format* içindeki ``%`` dönüştürme spesifikasyonları sıfır veya "
"daha fazla *values* öğesiyle değiştirilir. Etki, C dilinde :c:func:`sprintf` "
"kullanımına benzer."

#: library/stdtypes.rst:2340
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for example, a "
"dictionary)."
msgstr ""
"*format* tek bir argüman gerektiriyorsa, *values* tuple olmayan tek bir nesne "
"olabilir. [5]_ Aksi halde, *değerler*, biçim dizesi tarafından belirtilen öğe "
"sayısını tam olarak içeren bir tanımlama grubu veya tek bir eşleme nesnesi "
"(örneğin, bir sözlük) olmalıdır."

#: library/stdtypes.rst:3568
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Bir dönüşüm belirteci iki veya daha fazla karakter içerir ve bu sırayla "
"gerçekleşmesi gereken aşağıdaki bileşenlere sahiptir:"

#: library/stdtypes.rst:3571
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "Belirleyicinin başlangıcını işaret eden ``'%'`` karakteri."

#: library/stdtypes.rst:3573
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"Parantez içindeki karakter dizisinden oluşan eşleme anahtarı (isteğe bağlı) "
"(örneğin, ``(bazı ad)``)."

#: library/stdtypes.rst:3576
msgid ""
"Conversion flags (optional), which affect the result of some conversion types."
msgstr ""
"Bazı dönüşüm türlerinin sonucunu etkileyen dönüşüm işaretleri (isteğe bağlı)."

#: library/stdtypes.rst:3579
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Minimum alan genişliği (isteğe bağlı). Bir ``'*'`` (yıldız işareti) olarak "
"belirtilirse, gerçek genişlik *değerler* içindeki demetin bir sonraki öğesinden "
"okunur ve dönüştürülecek nesne, minimum alan genişliğinden ve isteğe bağlı "
"hassasiyetten sonra gelir."

#: library/stdtypes.rst:3583
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  If "
"specified as ``'*'`` (an asterisk), the actual precision is read from the next "
"element of the tuple in *values*, and the value to convert comes after the "
"precision."
msgstr ""
"Hassasiyet (isteğe bağlı), ``'.'`` (nokta) ve ardından hassasiyet olarak "
"verilir. ``'*'`` (yıldız işareti) olarak belirtilirse, gerçek duyarlık *values* "
"içindeki demetin bir sonraki öğesinden okunur ve dönüştürülecek değer "
"duyarlıktan sonra gelir."

#: library/stdtypes.rst:3588
msgid "Length modifier (optional)."
msgstr "Uzunluk değiştirici (isteğe bağlı)."

#: library/stdtypes.rst:3590
msgid "Conversion type."
msgstr "Dönüşüm türü."

#: library/stdtypes.rst:2374
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Doğru argüman bir sözlük (veya başka bir eşleme türü) olduğunda, dizedeki "
"formatlar *zorunludur*, o sözlüğe ``'%'`` karakterinden hemen sonra eklenen "
"parantez içinde bir eşleme anahtarı içermelidir. Eşleme anahtarı, eşlemeden "
"biçimlendirilecek değeri seçer. Örneğin:"

#: library/stdtypes.rst:3601
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"Bu durumda bir formatta hiçbir ``*`` belirtici bulunamaz (sıralı bir parametre "
"listesi gerektirdiklerinden)."

#: library/stdtypes.rst:3604
msgid "The conversion flag characters are:"
msgstr "Dönüşüm bayrağı karakterleri şunlardır:"

#: library/stdtypes.rst:3613
msgid "Flag"
msgstr "Bayrak"

#: library/stdtypes.rst:3615
msgid "``'#'``"
msgstr "``'#'``"

#: library/stdtypes.rst:3615
msgid "The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""
"Değer dönüşümü \"alternatif formu\" (aşağıda tanımlandığı yerde) kullanacaktır."

#: library/stdtypes.rst:3618
msgid "``'0'``"
msgstr "``'0'``"

#: library/stdtypes.rst:3618
msgid "The conversion will be zero padded for numeric values."
msgstr "Dönüşüm sayısal değerler için sıfır dolgulu olacaktır."

#: library/stdtypes.rst:3620
msgid "``'-'``"
msgstr "``'-'``"

#: library/stdtypes.rst:3620
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if both "
"are given)."
msgstr ""
"Dönüştürülen değer ayarlanmış olarak bırakılır (her ikisi de verilmişse ``'0'`` "
"dönüşümünü geçersiz kılar)."

#: library/stdtypes.rst:3623
msgid "``' '``"
msgstr "``' '``"

#: library/stdtypes.rst:3623
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(boşluk) İmzalı bir dönüştürme tarafından üretilen bir pozitif sayıdan (veya boş "
"dizeden) önce bir boşluk bırakılmalıdır."

#: library/stdtypes.rst:3626
msgid "``'+'``"
msgstr "``'+'``"

#: library/stdtypes.rst:3626
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides a "
"\"space\" flag)."
msgstr ""
"Dönüşümden önce bir işaret karakteri (\"''+''' veya \"'-'``) gelir (\"boşluk\" "
"işaretini geçersiz kılar)."

#: library/stdtypes.rst:3630
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as it "
"is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Bir uzunluk değiştirici (\"h\", \"l\" veya \"L\") mevcut olabilir, ancak Python "
"için gerekli olmadığı için göz ardı edilir -- yani örn. ``%ld``, ``%d`` ile "
"aynıdır."

#: library/stdtypes.rst:3633
msgid "The conversion types are:"
msgstr "Dönüşüm türleri şunlardır:"

#: library/stdtypes.rst:3636
msgid "Conversion"
msgstr "Dönüşüm"

#: library/stdtypes.rst:3638
msgid "``'d'``"
msgstr "``'d'``"

#: library/stdtypes.rst:2422 library/stdtypes.rst:3640
msgid "Signed integer decimal."
msgstr "İşaretli tamsayı ondalık."

#: library/stdtypes.rst:3640
msgid "``'i'``"
msgstr "``'i'``"

#: library/stdtypes.rst:3642
msgid "``'o'``"
msgstr "``'o'``"

#: library/stdtypes.rst:3642
msgid "Signed octal value."
msgstr "İşaretli sekizlik değer."

#: library/stdtypes.rst:3644
msgid "``'u'``"
msgstr "``'u'``"

#: library/stdtypes.rst:3644
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Eski tip -- ``'d'`` ile aynıdır."

#: library/stdtypes.rst:3646
msgid "``'x'``"
msgstr "``'x'``"

#: library/stdtypes.rst:3646
msgid "Signed hexadecimal (lowercase)."
msgstr "İmzalı onaltılık (küçük harf)."

#: library/stdtypes.rst:3648
msgid "``'X'``"
msgstr "``'X'``"

#: library/stdtypes.rst:3648
msgid "Signed hexadecimal (uppercase)."
msgstr "İmzalı onaltılık (büyük harf)."

#: library/stdtypes.rst:3650
msgid "``'e'``"
msgstr "``'e'``"

#: library/stdtypes.rst:3650
msgid "Floating point exponential format (lowercase)."
msgstr "Kayan noktalı üstel biçim (küçük harf)."

#: library/stdtypes.rst:3652
msgid "``'E'``"
msgstr "``'E'``"

#: library/stdtypes.rst:3652
msgid "Floating point exponential format (uppercase)."
msgstr "Kayan noktalı üstel biçim (büyük harf)."

#: library/stdtypes.rst:3654
msgid "``'f'``"
msgstr "``'f'``"

#: library/stdtypes.rst:2438 library/stdtypes.rst:3656
msgid "Floating point decimal format."
msgstr "Kayan noktalı ondalık biçim."

#: library/stdtypes.rst:3656
msgid "``'F'``"
msgstr "``'F'``"

#: library/stdtypes.rst:3658
msgid "``'g'``"
msgstr "``'g'``"

#: library/stdtypes.rst:3658
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Kayan nokta biçimi. Üs -4'ten küçükse veya kesinlikten az değilse küçük üstel "
"biçimi, aksi takdirde ondalık biçimi kullanır."

#: library/stdtypes.rst:3662
msgid "``'G'``"
msgstr "``'G'``"

#: library/stdtypes.rst:3662
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Kayan nokta biçimi. Üs -4'ten küçükse veya hassasiyetten az değilse büyük harfli "
"üstel formatı, aksi takdirde ondalık formatı kullanır."

#: library/stdtypes.rst:3666
msgid "``'c'``"
msgstr "``'c'``"

#: library/stdtypes.rst:2448
msgid "Single character (accepts integer or single character string)."
msgstr "Tek karakter (tamsayı veya tek karakter dizesini kabul eder)."

#: library/stdtypes.rst:3679
msgid "``'r'``"
msgstr "``'r'``"

#: library/stdtypes.rst:2451
msgid "String (converts any Python object using :func:`repr`)."
msgstr ""
"String ( :func:`repr` kullanarak herhangi bir Python nesnesini dönüştürür)."

#: library/stdtypes.rst:3673
msgid "``'s'``"
msgstr "``'s'``"

#: library/stdtypes.rst:2454
msgid "String (converts any Python object using :func:`str`)."
msgstr "String ( :func:`str` kullanarak herhangi bir Python nesnesini dönüştürür)."

#: library/stdtypes.rst:3676
msgid "``'a'``"
msgstr "``'a'``"

#: library/stdtypes.rst:2457
msgid "String (converts any Python object using :func:`ascii`)."
msgstr ""
"String ( :func:`ascii` kullanarak herhangi bir Python nesnesini dönüştürür)."

#: library/stdtypes.rst:3682
msgid "``'%'``"
msgstr "``'%'``"

#: library/stdtypes.rst:3682
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr "Hiçbir bağımsız değişken dönüştürülmez, sonuçta ``'%'`` karakteri oluşur."

#: library/stdtypes.rst:3689
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be inserted "
"before the first digit."
msgstr ""
"Alternatif form, ilk rakamdan önce önde gelen bir sekizli belirtecin (``'0o'``) "
"eklenmesine neden olur."

#: library/stdtypes.rst:3693
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on whether "
"the ``'x'`` or ``'X'`` format was used) to be inserted before the first digit."
msgstr ""
"Alternatif form, ilk rakamdan önce önde gelen bir ``'0x'`` veya ``'0X'`` "
"(``'x'`` veya ``'X'`` formatının kullanılmasına bağlı olarak) eklenmesine neden "
"olur."

#: library/stdtypes.rst:3697
msgid ""
"The alternate form causes the result to always contain a decimal point, even if "
"no digits follow it."
msgstr ""
"Alternatif form, ardından hiçbir rakam gelmese bile sonucun her zaman bir "
"ondalık nokta içermesine neden olur."

#: library/stdtypes.rst:3700
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"Hassasiyet, ondalık noktadan sonraki basamak sayısını belirler ve varsayılan "
"olarak 6'dır."

#: library/stdtypes.rst:3704
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"Alternatif form, sonucun her zaman ondalık nokta içermesine neden olur ve "
"sondaki sıfırlar normalde olduğu gibi kaldırılmaz."

#: library/stdtypes.rst:3707
msgid ""
"The precision determines the number of significant digits before and after the "
"decimal point and defaults to 6."
msgstr ""
"Hassasiyet, ondalık noktadan önceki ve sonraki anlamlı basamak sayısını belirler "
"ve varsayılan olarak 6'dır."

#: library/stdtypes.rst:3711
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "Hassasiyet ``N`` ise, çıktı ``N`` karaktere kadar kesilir."

#: library/stdtypes.rst:3720
msgid "See :pep:`237`."
msgstr "Bkz :pep:`237`."

#: library/stdtypes.rst:2494
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not assume "
"that ``'\\0'`` is the end of the string."
msgstr ""
"Python karakter dizilerinin açık bir uzunluğu olduğundan, ``%s`` dönüşümleri "
"``'\\0'`` karakter dizisinin sonu olduğunu varsaymaz."

#: library/stdtypes.rst:2499
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no longer "
"replaced by ``%g`` conversions."
msgstr ""
"Mutlak değeri 1e50'nin üzerinde olan sayılar için ``%f`` dönüşümlerinin yerini "
"artık ``%g`` dönüşümleri almıyor."

#: library/stdtypes.rst:2510
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:`memoryview`"
msgstr ""
"İkili Dizi Türleri --- :class:`bytes`, :class:`bytearray`, :class:`memoryview`"

#: library/stdtypes.rst:2518
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :ref:"
"`buffer protocol <bufferobjects>` to access the memory of other binary objects "
"without needing to make a copy."
msgstr ""
"İkili verileri işlemek için temel yerleşik türler :class:`bytes` ve :class:"
"`bytearray`dir. Bir kopya oluşturmaya gerek kalmadan diğer ikili nesnelerin "
"belleğine erişmek için :ref:`buffer protokolünü <bufferobjects>` kullanan :class:"
"`memoryview` tarafından desteklenirler."

#: library/stdtypes.rst:2523
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like 32-"
"bit integers and IEEE754 double-precision floating values."
msgstr ""
":mod:`array` modülü, 32 bitlik tamsayılar ve IEEE754 çift duyarlıklı kayan "
"değerler gibi temel veri türlerinin verimli bir şekilde depolanmasını destekler."

#: library/stdtypes.rst:2529
msgid "Bytes Objects"
msgstr "Bayt Nesneleri"

#: library/stdtypes.rst:2533
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major binary "
"protocols are based on the ASCII text encoding, bytes objects offer several "
"methods that are only valid when working with ASCII compatible data and are "
"closely related to string objects in a variety of other ways."
msgstr ""
"Bayt nesneleri, değişmez tek bayt dizileridir. Birçok büyük ikili protokol, "
"ASCII metin kodlamasına dayandığından, bayt nesneleri, yalnızca ASCII uyumlu "
"verilerle çalışırken geçerli olan ve çeşitli şekillerde dize nesneleriyle "
"yakından ilişkili olan birkaç yöntem sunar."

#: library/stdtypes.rst:2540
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for string "
"literals, except that a ``b`` prefix is added:"
msgstr ""
"İlk olarak, bayt hazır değerlerinin sözdizimi, bir \"b\" önekinin eklenmesi "
"dışında, dize değişmezleriyle büyük ölçüde aynıdır:"

#: library/stdtypes.rst:2543
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "Tek tırnak: ``b'hala gömülü \"çift\" tırnaklara izin verir'''"

#: library/stdtypes.rst:2544
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr "Çift tırnak: ``b\"gömülü 'tek' tırnak işaretlerine hâlâ izin veriyor\"``"

#: library/stdtypes.rst:2545
msgid "Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr "Üçlü alıntı: ``b'''3 tek tırnak'''``, ``b\"\"\"3 çift tırnak\"\"\"``"

#: library/stdtypes.rst:2547
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered into "
"bytes literals using the appropriate escape sequence."
msgstr ""
"Bayt hazır bilgilerinde yalnızca ASCII karakterlerine izin verilir (bildirilen "
"kaynak kodu kodlamasından bağımsız olarak). 127'nin üzerindeki herhangi bir "
"ikili değer, uygun çıkış dizisi kullanılarak bayt sabit değerlerine girilmelidir."

#: library/stdtypes.rst:2551
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to disable "
"processing of escape sequences. See :ref:`strings` for more about the various "
"forms of bytes literal, including supported escape sequences."
msgstr ""
"Dize değişmezlerinde olduğu gibi, bayt değişmezleri de kaçış dizilerinin "
"işlenmesini devre dışı bırakmak için bir \"r\" öneki kullanabilir. Desteklenen "
"çıkış dizileri de dahil olmak üzere çeşitli değişmez bayt biçimleri hakkında "
"daha fazla bilgi için :ref:`dizeleri` konusuna bakın."

#: library/stdtypes.rst:2555
msgid ""
"While bytes literals and representations are based on ASCII text, bytes objects "
"actually behave like immutable sequences of integers, with each value in the "
"sequence restricted such that ``0 <= x < 256`` (attempts to violate this "
"restriction will trigger :exc:`ValueError`). This is done deliberately to "
"emphasise that while many binary formats include ASCII based elements and can be "
"usefully manipulated with some text-oriented algorithms, this is not generally "
"the case for arbitrary binary data (blindly applying text processing algorithms "
"to binary data formats that are not ASCII compatible will usually lead to data "
"corruption)."
msgstr ""
"Bayt sabit değerleri ve gösterimleri ASCII metnine dayalı olsa da, bayt "
"nesneleri aslında değişmez tamsayı dizileri gibi davranır ve dizideki her değer "
"\"0 <= x < 256\" şeklinde kısıtlanır (bu kısıtlamayı ihlal etme girişimleri :exc "
"tetikler) :`DeğerHatası`). Bu, birçok ikili formatın ASCII tabanlı öğeler "
"içermesine ve bazı metin yönelimli algoritmalarla yararlı bir şekilde manipüle "
"edilebilmesine rağmen, bunun genellikle rastgele ikili veriler için geçerli "
"olmadığını (metin işleme algoritmalarını, metin işleme algoritmalarını, otomatik "
"olmayan ikili veri biçimlerine körü körüne uygulamak) vurgulamak için kasıtlı "
"olarak yapılır. ASCII uyumluluğu genellikle veri bozulmasına yol açar)."

#: library/stdtypes.rst:2565
msgid ""
"In addition to the literal forms, bytes objects can be created in a number of "
"other ways:"
msgstr ""
"Değişmez biçimlere ek olarak, bayt nesneleri bir dizi başka yolla da "
"oluşturulabilir:"

#: library/stdtypes.rst:2568
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr "Belirtilen uzunlukta sıfır doldurulmuş bayt nesnesi: ``bytes(10)``"

#: library/stdtypes.rst:2569
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "Yinelenen tamsayılardan: ``bytes(range(20))``"

#: library/stdtypes.rst:2570
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Mevcut ikili verileri arabellek protokolü aracılığıyla kopyalama: ``bytes(obj)``"

#: library/stdtypes.rst:2572
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "Ayrıca :ref:`bytes <func-bytes>` yerleşikine bakın."

#: library/stdtypes.rst:2574
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimal "
"numbers are a commonly used format for describing binary data. Accordingly, the "
"bytes type has an additional class method to read data in that format:"
msgstr ""
"2 onaltılık basamak tam olarak tek bir bayta karşılık geldiğinden, onaltılık "
"sayılar ikili verileri açıklamak için yaygın olarak kullanılan bir biçimdir. "
"Buna göre, bayt türü, verileri bu biçimde okumak için ek bir sınıf yöntemine "
"sahiptir:"

#: library/stdtypes.rst:2580
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, with "
"ASCII whitespace being ignored."
msgstr ""
"Bu :class:`bytes` sınıf yöntemi, verilen dize nesnesinin kodunu çözerek bir bayt "
"nesnesi döndürür. Dize, bayt başına iki onaltılık basamak içermelidir ve ASCII "
"boşluk yok sayılır."

#: library/stdtypes.rst:2587
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
":meth:`bytes.fromhex` artık dizgedeki tüm ASCII boşluklarını atlıyor, sadece "
"boşlukları değil."

#: library/stdtypes.rst:2591
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"Bir bayt nesnesini onaltılık gösterimine dönüştürmek için bir ters dönüştürme "
"işlevi vardır."

#: library/stdtypes.rst:2681
msgid ""
"Return a string object containing two hexadecimal digits for each byte in the "
"instance."
msgstr ""
"Örnekteki her bayt için iki onaltılık basamak içeren bir dize nesnesi döndürün."

#: library/stdtypes.rst:2602
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, this "
"separator will be included between each byte. A second optional *bytes_per_sep* "
"parameter controls the spacing. Positive values calculate the separator position "
"from the right, negative values from the left."
msgstr ""
"Onaltılı dizenin daha kolay okunmasını istiyorsanız, çıktıya dahil edilecek tek "
"karakter ayırıcı *sep* parametresini belirtebilirsiniz. Varsayılan olarak, bu "
"ayırıcı her bayt arasına dahil edilecektir. İkinci bir isteğe bağlı "
"*bytes_per_sep* parametresi, aralığı kontrol eder. Pozitif değerler ayırıcı "
"konumunu sağdan, negatif değerler soldan hesaplar."

#: library/stdtypes.rst:2619
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters to "
"insert separators between bytes in the hex output."
msgstr ""
":meth:`bytes.hex` artık isteğe bağlı *sep* ve *bytes_per_sep* parametrelerini "
"onaltılık çıktıda baytlar arasına ayırıcılar eklemek için destekliyor."

#: library/stdtypes.rst:2623
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes object "
"of length 1.  (This contrasts with text strings, where both indexing and slicing "
"will produce a string of length 1)"
msgstr ""
"Bayt nesneleri tamsayı dizileri olduğundan (bir demete benzer), bir bayt nesnesi "
"için *b*, \"b[0]\" bir tamsayı, \"b[0:1]\"\" ise bir bayt olacaktır. 1 "
"uzunluğunda nesne. (Bu, hem indekslemenin hem de dilimlemenin 1 uzunluğunda bir "
"dizi üreteceği metin dizeleriyle çelişir)"

#: library/stdtypes.rst:2628
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) since "
"it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can always "
"convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"Bayt nesnelerinin temsili, genellikle örn. ``bayt([46, 46, 46])``. ``list(b)`` "
"kullanarak bir bayt nesnesini her zaman bir tamsayılar listesine "
"dönüştürebilirsiniz."

#: library/stdtypes.rst:2636
msgid "Bytearray Objects"
msgstr "Bytearray Nesneleri"

#: library/stdtypes.rst:2640
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` objects."
msgstr ""
":class:`bytearray` nesneleri, :class:`bytes` nesnelerinin değişken karşılığıdır."

#: library/stdtypes.rst:2645
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"Bytearray nesneleri için özel bir sözdizimi yoktur, bunun yerine her zaman "
"yapıcı çağrılarak oluşturulurlar:"

#: library/stdtypes.rst:2648
msgid "Creating an empty instance: ``bytearray()``"
msgstr "Boş bir örnek oluşturuluyor: ``bytearray()``"

#: library/stdtypes.rst:2649
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr "Belirli bir uzunlukta sıfır dolgulu bir örnek oluşturma: ``bytearray(10)``"

#: library/stdtypes.rst:2650
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "Yinelenen tamsayılardan: ``bytearray(range(20))``"

#: library/stdtypes.rst:2651
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Mevcut ikili verileri arabellek protokolü aracılığıyla kopyalama: "
"``bytearray(b'Hi!')``"

#: library/stdtypes.rst:2653
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Bytearray nesneleri değiştirilebilir olduğundan, :ref:`bytes-methods`da "
"açıklanan ortak bayt ve bytearray işlemlerine ek olarak :ref:`mutable <typesseq-"
"mutable>` dizi işlemlerini desteklerler."

#: library/stdtypes.rst:2657
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr "Ayrıca :ref:`bytearray <func-bytearray>` yerleşikine de bakın."

#: library/stdtypes.rst:2659
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimal "
"numbers are a commonly used format for describing binary data. Accordingly, the "
"bytearray type has an additional class method to read data in that format:"
msgstr ""
"2 onaltılık basamak tam olarak tek bir bayta karşılık geldiğinden, onaltılık "
"sayılar ikili verileri tanımlamak için yaygın olarak kullanılan bir formattır. "
"Buna göre bytearray türü, bu formattaki verileri okumak için ek bir sınıf "
"yöntemine sahiptir:"

#: library/stdtypes.rst:2665
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Bu :class:`bytearray` sınıf yöntemi, verilen string nesnesinin kodunu çözerek "
"bytearray nesnesini döndürür. Dize, bayt başına iki onaltılık basamak "
"içermelidir ve ASCII boşluk yok sayılır."

#: library/stdtypes.rst:2672
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."

#: library/stdtypes.rst:2676
msgid ""
"A reverse conversion function exists to transform a bytearray object into its "
"hexadecimal representation."
msgstr ""
"Bir bytearray nesnesini onaltılık gösterimine dönüştürmek için bir ters "
"dönüştürme işlevi mevcuttur."

#: library/stdtypes.rst:2689
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional *sep* "
"and *bytes_per_sep* parameters to insert separators between bytes in the hex "
"output."
msgstr ""
":meth:`bytes.hex`e benzer şekilde, :meth:`bytearray.hex` artık onaltılık çıktıda "
"baytlar arasına ayırıcılar eklemek için isteğe bağlı *sep* ve *bytes_per_sep* "
"parametrelerini destekliyor."

#: library/stdtypes.rst:2694
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a "
"bytearray object of length 1.  (This contrasts with text strings, where both "
"indexing and slicing will produce a string of length 1)"
msgstr ""
":meth:`bytes.hex`e benzer şekilde, :meth:`bytearray.hex` artık onaltılık çıktıda "
"baytlar ayıranlar ayırmak için yatay bağlı *sep* ve *bytes_per_sep* paylaşımını "
"yapabilir."

#: library/stdtypes.rst:2699
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. ``bytearray([46, "
"46, 46])``.  You can always convert a bytearray object into a list of integers "
"using ``list(b)``."
msgstr ""
"Bytearray nesnelerinin temsili bytes değişmez formatını kullanır "
"(``bytearray(b'...')``), çünkü bu genellikle ör. \"bytearray([46, 46, 46])\". "
"Bir bytearray nesnesini her zaman ``list(b)`` kullanarak bir tamsayı listesine "
"dönüştürebilirsiniz."

#: library/stdtypes.rst:2708
msgid "Bytes and Bytearray Operations"
msgstr "Bayt ve Bytearray İşlemleri"

#: library/stdtypes.rst:2713
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same type, "
"but with any :term:`bytes-like object`. Due to this flexibility, they can be "
"freely mixed in operations without causing errors. However, the return type of "
"the result may depend on the order of operands."
msgstr ""
"Hem bayt hem de bytearray nesneleri :ref:`common <typesseq-common>` dizi "
"işlemlerini destekler. Yalnızca aynı türden işlenenlerle değil, herhangi bir :"
"term:`bayt benzeri nesneyle' birlikte çalışırlar. Bu esneklik nedeniyle, "
"operasyonlarda hataya neden olmadan serbestçe karıştırılabilirler. Ancak, "
"sonucun dönüş tipi, işlenenlerin sırasına bağlı olabilir."

#: library/stdtypes.rst:2721
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"Baytlar ve bayt dizisi nesneleri üzerindeki yöntemler, bağımsız değişkenleri "
"olarak dizeleri kabul etmez, tıpkı dizelerdeki yöntemlerin bağımsız değişkenleri "
"olarak baytları kabul etmemesi gibi. Örneğin, şunu yazmalısınız::"

#: library/stdtypes.rst:2728
msgid "and::"
msgstr "ve::"

#: library/stdtypes.rst:2733
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible binary "
"formats, and hence should be avoided when working with arbitrary binary data. "
"These restrictions are covered below."
msgstr ""
"Bazı baytlar ve bayt dizisi işlemleri, ASCII uyumlu ikili biçimlerin "
"kullanıldığını varsayar ve bu nedenle rastgele ikili verilerle çalışırken "
"kaçınılmalıdır. Bu kısıtlamalar aşağıda ele alınmıştır."

#: library/stdtypes.rst:2738
msgid ""
"Using these ASCII based operations to manipulate binary data that is not stored "
"in an ASCII based format may lead to data corruption."
msgstr ""
"ASCII tabanlı bir biçimde depolanmayan ikili verileri işlemek için bu ASCII "
"tabanlı işlemleri kullanmak, verilerin bozulmasına neden olabilir."

#: library/stdtypes.rst:2741
msgid ""
"The following methods on bytes and bytearray objects can be used with arbitrary "
"binary data."
msgstr ""
"Bayt ve bytearray nesneleri üzerindeki aşağıdaki yöntemler rastgele ikili "
"verilerle kullanılabilir."

#: library/stdtypes.rst:2747
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are interpreted as "
"in slice notation."
msgstr ""
"[*start*, *end*] aralığında *sub* alt dizesinin örtüşmeyen oluşumlarının "
"sayısını döndürür. İsteğe bağlı bağımsız değişkenler *start* ve *end*, dilim "
"notasyonunda olduğu gibi yorumlanır."

#: library/stdtypes.rst:2856 library/stdtypes.rst:2944 library/stdtypes.rst:2957
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an integer "
"in the range 0 to 255."
msgstr ""
"Aranacak alt dizi herhangi bir :term:`bytes-like object` veya 0 ila 255 "
"aralığında bir tamsayı olabilir."

#: library/stdtypes.rst:2754
msgid ""
"If *sub* is empty, returns the number of empty slices between characters which "
"is the length of the bytes object plus one."
msgstr ""
"Sub* boşsa, bytes nesnesinin uzunluğu artı bir olan karakterler arasındaki boş "
"dilimlerin sayısını döndürür."

#: library/stdtypes.rst:2868 library/stdtypes.rst:2947 library/stdtypes.rst:2960
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr "Ayrıca alt dizi olarak 0 ila 255 aralığında bir tamsayı kabul edin."

#: library/stdtypes.rst:2764
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary data::"
msgstr ""
"İkili veri *önek* dizesiyle başlıyorsa, ``bytes[len(prefix):]`` döndürün. Aksi "
"takdirde, orijinal ikili verilerin bir kopyasını döndürün::"

#: library/stdtypes.rst:2773
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr "*Önek* herhangi bir :term:`bayt benzeri nesne` olabilir."

#: library/stdtypes.rst:2799 library/stdtypes.rst:3025 library/stdtypes.rst:3070
#: library/stdtypes.rst:3126 library/stdtypes.rst:3214 library/stdtypes.rst:3381
#: library/stdtypes.rst:3479 library/stdtypes.rst:3522 library/stdtypes.rst:3724
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"Bu yöntemin bytearray versiyonu yerinde *çalışmaz* - hiçbir değişiklik "
"yapılmamış olsa bile her zaman yeni bir nesne üretir."

#: library/stdtypes.rst:2786
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not empty, "
"return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the original "
"binary data::"
msgstr ""
"İkili veri *sonek* dizesiyle bitiyorsa ve bu *sonek* boş değilse, ``bytes[:-"
"len(suffix)]`` döndürün. Aksi takdirde, orijinal ikili verilerin bir kopyasını "
"döndürün::"

#: library/stdtypes.rst:2795
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr "*Sonek* herhangi bir :term:`bayt benzeri nesne` olabilir."

#: library/stdtypes.rst:2808
msgid "Return the bytes decoded to a :class:`str`."
msgstr ":class:`bytes` olarak kodlanmış dizeyi döndürün."

#: library/stdtypes.rst:2813
msgid ""
"*errors* controls how decoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values are "
"``'ignore'``, ``'replace'``, and any other name registered via :func:`codecs."
"register_error`. See :ref:`error-handlers` for details."
msgstr ""
"*hatalar* kod çözme hatalarının nasıl ele alınacağını kontrol eder. ``'strict'`` "
"(varsayılan), bir :exc:`UnicodeError` istisnası oluşturulur. Diğer olası "
"değerler ``'ignore'``, ``'replace'`` ve :func:`codecs.register_error` "
"aracılığıyla kaydedilen diğer adlardır. Ayrıntılar için :ref:`error-handlers` "
"bölümüne bakın."

#: library/stdtypes.rst:2819
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless a decoding error actually occurs, :ref:`devmode` is enabled or a :ref:"
"`debug build <debug-build>` is used."
msgstr ""
"Performans nedenleriyle, gerçekten bir kodlama hatası oluşmadıkça, :ref:"
"`devmode` etkinleştirilmedikçe veya :ref:`debug build <debug-build>` "
"kullanılmadıkça *errors* değeri geçerlilik açısından kontrol edilmez."

#: library/stdtypes.rst:2825
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:`bytes-"
"like object` directly, without needing to make a temporary :class:`!bytes` or :"
"class:`!bytearray` object."
msgstr ""
"*kodlama* bağımsız değişkeninin :class:`str` öğesine iletilmesi, herhangi bir :"
"term:`bytes benzeri nesnenin' kodunun, geçici bir bayt veya bytearray nesnesi "
"oluşturmaya gerek kalmadan doğrudan çözülmesini sağlar."

#: library/stdtypes.rst:2840
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  With "
"optional *start*, test beginning at that position.  With optional *end*, stop "
"comparing at that position."
msgstr ""
"İkili veri belirtilen *sonek* ile bitiyorsa \"True\", aksi halde \"False\" "
"döndürün. *sonek* ayrıca aranacak bir dizi sonek olabilir. İsteğe bağlı "
"*başlangıç* ile, o konumdan başlayarak test edin. İsteğe bağlı *uç* ile, o "
"konumda karşılaştırmayı bırakın."

#: library/stdtypes.rst:2845
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr "Aranacak sonek(ler) herhangi bir :term:`bayt benzeri nesne` olabilir."

#: library/stdtypes.rst:2851
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, such "
"that *sub* is contained in the slice ``s[start:end]``.  Optional arguments "
"*start* and *end* are interpreted as in slice notation.  Return ``-1`` if *sub* "
"is not found."
msgstr ""
"*sub* alt dizisinin bulunduğu verideki en düşük dizini döndürün, öyle ki *sub* "
"``s[start:end]`` diliminde yer alıyor. İsteğe bağlı bağımsız değişkenler *start* "
"ve *end*, dilim notasyonundaki gibi yorumlanır. *alt* bulunmazsa ``-1`` döndürün."

#: library/stdtypes.rst:2861
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :keyword:"
"`in` operator::"
msgstr ""
":meth:`~bytes.find` yöntemi yalnızca *sub* konumunu bilmeniz gerekiyorsa "
"kullanılmalıdır. *sub*'nun bir alt dize olup olmadığını kontrol etmek için :"
"keyword:`in` operatörünü kullanın::"

#: library/stdtypes.rst:2875
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence is "
"not found."
msgstr ""
":meth:`~bytes.find` gibi, ancak alt dizi bulunamadığında :exc:`ValueError` "
"yükseltin."

#: library/stdtypes.rst:2888
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary data "
"sequences in *iterable*.  A :exc:`TypeError` will be raised if there are any "
"values in *iterable* that are not :term:`bytes-like objects <bytes-like "
"object>`, including :class:`str` objects.  The separator between elements is the "
"contents of the bytes or bytearray object providing this method."
msgstr ""
"*yinelenebilir*'deki ikili veri dizilerinin birleştirilmesi olan bir bayt veya "
"bytearray nesnesi döndürün. :class:`str` nesneleri dahil olmak üzere "
"*yinelenebilir* içinde :term:`bytes benzeri nesneler <bytes benzeri nesne>` "
"olmayan herhangi bir değer varsa :exc:`TypeError` yükseltilir. Öğeler arasındaki "
"ayırıcı, bu yöntemi sağlayan byte veya bytearray nesnesinin içeriğidir."

#: library/stdtypes.rst:2899
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the same "
"position in *to*; *from* and *to* must both be :term:`bytes-like objects <bytes-"
"like object>` and have the same length."
msgstr ""
"Bu statik yöntem :meth:`bytes.translate` için kullanılabilen, *from* içindeki "
"her karakteri *to* içindeki aynı konumdaki karaktere eşleyecek bir çeviri "
"tablosu döndürür; *from* ve *to* :term:`bayt benzeri nesneler <bayt benzeri "
"nesne>` olmalı ve aynı uzunluğa sahip olmalıdır."

#: library/stdtypes.rst:2910
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its bytearray "
"copy, and the part after the separator. If the separator is not found, return a "
"3-tuple containing a copy of the original sequence, followed by two empty bytes "
"or bytearray objects."
msgstr ""
"Diziyi *sep*'in ilk geçtiği yerde bölün ve ayırıcıdan önceki kısmı, ayırıcının "
"kendisini veya bytearray kopyasını ve ayırıcıdan sonraki kısmı içeren 3'lü bir "
"demet döndürün. Ayırıcı bulunamazsa, orijinal dizinin bir kopyasını içeren 3'lü "
"bir demet ve ardından iki boş bayt veya bytearray nesnesi döndürün."

#: library/stdtypes.rst:2974
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr "Aranacak ayırıcı herhangi bir :term:`bayt benzeri nesne` olabilir."

#: library/stdtypes.rst:2923
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"*eski* alt dizisinin tüm oluşumları *yeni* ile değiştirilerek dizinin bir "
"kopyasını döndürür. İsteğe bağlı *count* bağımsız değişkeni verilirse, yalnızca "
"ilk *count* oluşumları değiştirilir."

#: library/stdtypes.rst:2927
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-like "
"object`."
msgstr ""
"Aranacak alt dizi ve bunun değiştirilmesi herhangi bir :term:`bayt benzeri "
"nesne' olabilir."

#: library/stdtypes.rst:2939
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is found, "
"such that *sub* is contained within ``s[start:end]``.  Optional arguments "
"*start* and *end* are interpreted as in slice notation. Return ``-1`` on failure."
msgstr ""
"*sub* alt dizisinin bulunduğu dizideki en yüksek dizini, *sub* ``s[start:end]`` "
"içinde yer alacak şekilde döndürün. İsteğe bağlı bağımsız değişkenler *start* ve "
"*end*, dilim notasyonundaki gibi yorumlanır. Başarısızlık durumunda ``-1`` "
"döndürün."

#: library/stdtypes.rst:2954
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
":meth:`~bytes.rfind` gibi, ancak *sub* alt dizisi bulunamadığında :exc:"
"`ValueError` yükseltir."

#: library/stdtypes.rst:2967
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its bytearray "
"copy, and the part after the separator. If the separator is not found, return a "
"3-tuple containing two empty bytes or bytearray objects, followed by a copy of "
"the original sequence."
msgstr ""
"Diziyi *sep*'in son geçtiği yerde bölün ve ayırıcıdan önceki kısmı, ayırıcının "
"kendisini veya bytearray kopyasını ve ayırıcıdan sonraki kısmı içeren 3'lü bir "
"demet döndürün. Ayırıcı bulunamazsa, iki boş bayt veya bytearray nesnesi içeren "
"3'lü bir demet ve ardından orijinal dizinin bir kopyasını döndürün."

#: library/stdtypes.rst:2980
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, otherwise "
"return ``False``.  *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test beginning at that position.  With optional *end*, stop "
"comparing at that position."
msgstr ""
"İkili veri belirtilen * önek* ile başlıyorsa \"True\" döndürün, aksi takdirde "
"\"False\" döndürün. *önek* aranacak bir dizi önek de olabilir. İsteğe bağlı "
"*başlangıç* ile, o konumdan başlayarak test edin. İsteğe bağlı *uç* ile, o "
"konumda karşılaştırmayı bırakın."

#: library/stdtypes.rst:2985
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr "Aranacak önek(ler) herhangi bir :term:`bayt benzeri nesne` olabilir."

#: library/stdtypes.rst:2991
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in the "
"optional argument *delete* are removed, and the remaining bytes have been mapped "
"through the given translation table, which must be a bytes object of length 256."
msgstr ""
"İsteğe bağlı *delete* bağımsız değişkeninde bulunan tüm baytların kaldırıldığı "
"ve kalan baytların, 256 uzunluğunda bir bayt nesnesi olması gereken, verilen "
"çeviri tablosu aracılığıyla eşlendiği bayt veya bytearray nesnesinin bir "
"kopyasını döndürün."

#: library/stdtypes.rst:2996
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"Çeviri tablosu oluşturmak için :func:`bytes.maketrans` yöntemini "
"kullanabilirsiniz."

#: library/stdtypes.rst:2999
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"Yalnızca karakterleri silen çeviriler için *tablo* bağımsız değişkenini ``Yok`` "
"olarak ayarlayın::"

#: library/stdtypes.rst:3005
msgid "*delete* is now supported as a keyword argument."
msgstr ""
"*delete* artık bir anahtar kelime bağımsız değişkeni olarak desteklenmektedir."

#: library/stdtypes.rst:3009
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be used "
"with arbitrary binary data by passing appropriate arguments. Note that all of "
"the bytearray methods in this section do *not* operate in place, and instead "
"produce new objects."
msgstr ""
"Baytlar ve bayt dizisi nesneleri üzerindeki aşağıdaki yöntemler, ASCII uyumlu "
"ikili biçimlerin kullanıldığını varsayan varsayılan davranışlara sahiptir, ancak "
"yine de uygun bağımsız değişkenler iletilerek rasgele ikili verilerle "
"kullanılabilir. Bu bölümdeki tüm bytearray yöntemlerinin yerinde *çalışmadığını* "
"ve bunun yerine yeni nesneler ürettiğini unutmayın."

#: library/stdtypes.rst:3018
msgid ""
"Return a copy of the object centered in a sequence of length *width*. Padding is "
"done using the specified *fillbyte* (default is an ASCII space). For :class:"
"`bytes` objects, the original sequence is returned if *width* is less than or "
"equal to ``len(s)``."
msgstr ""
"Uzunluk *genişlik* dizisinde ortalanmış nesnenin bir kopyasını döndürün. Dolgu, "
"belirtilen *fillbyte* kullanılarak yapılır (varsayılan, bir ASCII alanıdır). :"
"class:`bytes` nesneleri için, *width* ``len(s)``den küçük veya ona eşitse "
"orijinal sıra döndürülür."

#: library/stdtypes.rst:3032
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). For :"
"class:`bytes` objects, the original sequence is returned if *width* is less than "
"or equal to ``len(s)``."
msgstr ""
"Nesnenin uzunluk *genişlik* dizisinde sola yaslanmış bir kopyasını döndürün. "
"Doldurma, belirtilen *fillbyte* kullanılarak yapılır (varsayılan, bir ASCII "
"alanıdır). :class:`bytes` nesneleri için, *width* ``len(s)``den küçük veya ona "
"eşitse orijinal sıra döndürülür."

#: library/stdtypes.rst:3046
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The *chars* "
"argument is a binary sequence specifying the set of byte values to be removed - "
"the name refers to the fact this method is usually used with ASCII characters.  "
"If omitted or ``None``, the *chars* argument defaults to removing ASCII "
"whitespace.  The *chars* argument is not a prefix; rather, all combinations of "
"its values are stripped::"
msgstr ""
"Belirtilen baştaki baytlar kaldırılmış olarak dizinin bir kopyasını döndürün. "
"*chars* bağımsız değişkeni, kaldırılacak bayt değerleri kümesini belirten ikili "
"bir dizidir - ad, bu yöntemin genellikle ASCII karakterleriyle kullanıldığı "
"gerçeğini ifade eder. Atlanırsa veya \"Yok\" ise, *karakterler* bağımsız "
"değişkeni varsayılan olarak ASCII boşluklarını kaldırır. *chars* bağımsız "
"değişkeni bir önek değildir; bunun yerine, değerlerinin tüm kombinasyonları "
"çıkarılır:"

#: library/stdtypes.rst:3058
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a single "
"prefix string rather than all of a set of characters.  For example::"
msgstr ""
"Kaldırılacak bayt değerlerinin ikili dizisi, herhangi bir :term:`bayt benzeri "
"nesne' olabilir. Tüm karakter kümesi yerine tek bir önek dizesini kaldıracak bir "
"yöntem için :meth:`~bytes.removeprefix` konusuna bakın. Örneğin::"

#: library/stdtypes.rst:3077
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). For :"
"class:`bytes` objects, the original sequence is returned if *width* is less than "
"or equal to ``len(s)``."
msgstr ""
"Nesnenin bir kopyasını uzunluk *genişlik* dizisinde sağa dayalı olarak döndürün. "
"Dolgu, belirtilen *fillbyte* kullanılarak yapılır (varsayılan, bir ASCII "
"alanıdır). :class:`bytes` nesneleri için, *width* ``len(s)``den küçük veya ona "
"eşitse orijinal sıra döndürülür."

#: library/stdtypes.rst:3091
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as the "
"delimiter string. If *maxsplit* is given, at most *maxsplit* splits are done, "
"the *rightmost* ones.  If *sep* is not specified or ``None``, any subsequence "
"consisting solely of ASCII whitespace is a separator. Except for splitting from "
"the right, :meth:`rsplit` behaves like :meth:`split` which is described in "
"detail below."
msgstr ""
"Ayırıcı dize olarak *sep* kullanarak ikili diziyi aynı türden alt dizilere "
"bölün. *maxsplit* verilirse en çok *maxsplit* split yapılır, *en sağdaki* "
"olanlardan. *bölme* belirtilmezse veya \"Yok\" ise, yalnızca ASCII boşluktan "
"oluşan herhangi bir alt dizi bir ayırıcıdır. Sağdan ayırma dışında :meth:"
"`rsplit`, aşağıda ayrıntılı olarak açıklanan :meth:`split` gibi davranır."

#: library/stdtypes.rst:3102
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to be "
"removed - the name refers to the fact this method is usually used with ASCII "
"characters.  If omitted or ``None``, the *chars* argument defaults to removing "
"ASCII whitespace.  The *chars* argument is not a suffix; rather, all "
"combinations of its values are stripped::"
msgstr ""
"Belirtilen sondaki baytlar kaldırılmış olarak dizinin bir kopyasını döndürün. "
"*chars* bağımsız değişkeni, kaldırılacak bayt değerleri kümesini belirten ikili "
"bir dizidir - ad, bu yöntemin genellikle ASCII karakterleriyle kullanıldığı "
"gerçeğini ifade eder. Atlanırsa veya \"Yok\" ise, *karakterler* bağımsız "
"değişkeni varsayılan olarak ASCII boşluklarını kaldırır. *chars* bağımsız "
"değişkeni bir sonek değildir; bunun yerine, değerlerinin tüm kombinasyonları "
"çıkarılır:"

#: library/stdtypes.rst:3114
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a single "
"suffix string rather than all of a set of characters.  For example::"
msgstr ""
"Kaldırılacak bayt değerlerinin ikili dizisi, herhangi bir :term:`bayt benzeri "
"nesne' olabilir. Tüm karakter kümesi yerine tek bir sonek dizesini kaldıracak "
"bir yöntem için :meth:`~bytes.removesuffix` konusuna bakın. Örneğin::"

#: library/stdtypes.rst:3133
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as the "
"delimiter string. If *maxsplit* is given and non-negative, at most *maxsplit* "
"splits are done (thus, the list will have at most ``maxsplit+1`` elements).  If "
"*maxsplit* is not specified or is ``-1``, then there is no limit on the number "
"of splits (all possible splits are made)."
msgstr ""
"Ayırıcı dize olarak *sep* kullanarak ikili diziyi aynı türden alt dizilere "
"bölün. *maxsplit* verilirse ve negatif değilse, en fazla *maxsplit* bölme "
"yapılır (böylece listede en fazla ``maxsplit+1`` öğe bulunur). *maxsplit* "
"belirtilmezse veya ``-1`` ise, bölme sayısında bir sınır yoktur (tüm olası "
"bölmeler yapılır)."

#: library/stdtypes.rst:3139
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a multibyte "
"sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns ``[b'1', b'2', "
"b'3']``). Splitting an empty sequence with a specified separator returns "
"``[b'']`` or ``[bytearray(b'')]`` depending on the type of object being split.  "
"The *sep* argument may be any :term:`bytes-like object`."
msgstr ""
"*böl* verilirse, ardışık sınırlayıcılar birlikte gruplandırılmaz ve boş alt "
"dizileri sınırladıkları kabul edilir (örneğin, ``b'1,,2'.split(b',')``, ``[b'1' "
"değerini döndürür. ', b'', b'2']``). *sep* bağımsız değişkeni çok baytlı bir "
"diziden oluşabilir (örneğin, ``b'1<>2<>3'.split(b'<>')``, ``[b'1', b'2'yi "
"döndürür ', b'3']``). Boş bir diziyi belirli bir ayırıcıyla bölmek, bölünen "
"nesnenin türüne bağlı olarak ``[b'']`` veya ``[bytearray(b'')]`` döndürür. *sep* "
"argümanı herhangi bir :term:`bayt benzeri nesne` olabilir."

#: library/stdtypes.rst:3157
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end if "
"the sequence has leading or trailing whitespace.  Consequently, splitting an "
"empty sequence or a sequence consisting solely of ASCII whitespace without a "
"specified separator returns ``[]``."
msgstr ""
"*bölme* belirtilmezse veya \"Yok\" ise, farklı bir bölme algoritması uygulanır: "
"ardışık ASCII boşluk çalıştırmaları, tek bir ayırıcı olarak kabul edilir ve "
"sonuç, dizi uygunsa, başında veya sonunda boş dizeler içermez. başında veya "
"sonunda boşluk var. Sonuç olarak, boş bir diziyi veya yalnızca ASCII "
"boşluklarından oluşan bir diziyi belirli bir ayırıcı olmadan bölmek \"[]\" "
"değerini döndürür."

#: library/stdtypes.rst:3178
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes removed. "
"The *chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with ASCII "
"characters.  If omitted or ``None``, the *chars* argument defaults to removing "
"ASCII whitespace. The *chars* argument is not a prefix or suffix; rather, all "
"combinations of its values are stripped::"
msgstr ""
"Belirtilen baştaki ve sondaki baytlar çıkarılmış olarak dizinin bir gidişatı "
"döndürün. *karakterler* bağımsız değişkeni, kaldırılacak bayt değerleri kümesini "
"kitaplar ikili bir dizidir - ad, bu yöntemin genellikle ASCII karakterleriyle "
"kullanılan gerçeğini ifade eder. Atlanırsa veya \"Yok\" ise, *karakterler* "
"bağımsız değişkeni genel olarak ASCII boşluklarını kaldırır. *chars* bağımsız "
"değişkeni bir önek veya sonek değildir; bunun yerine, değerlerinin tüm "
"kombinasyonları kaldırılır:"

#: library/stdtypes.rst:3191
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"Kaldırılacak bayt değerlerinin ikili dizisi, herhangi bir :term:`bayt benzeri "
"nesne' olabilir."

#: library/stdtypes.rst:3200
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary data. "
"Note that all of the bytearray methods in this section do *not* operate in "
"place, and instead produce new objects."
msgstr ""
"Baytlar ve bayt dizisi nesneleri üzerindeki aşağıdaki yöntemler, ASCII uyumlu "
"ikili biçimlerin kullanıldığını varsayar ve rastgele ikili verilere "
"uygulanmamalıdır. Bu bölümdeki tüm bytearray yöntemlerinin yerinde "
"*çalışmadığını* ve bunun yerine yeni nesneler ürettiğini unutmayın."

#: library/stdtypes.rst:3208
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII character, "
"and the first byte capitalized and the rest lowercased. Non-ASCII byte values "
"are passed through unchanged."
msgstr ""
"Her bayt bir ASCII karakteri olarak yorumlanmış ve ilk bayt büyük ve geri kalanı "
"küçük harfli olarak dizinin bir kopyasını döndürün. ASCII olmayan bayt değerleri "
"değiştirilmeden geçirilir."

#: library/stdtypes.rst:3221
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by one "
"or more ASCII spaces, depending on the current column and the given tab size.  "
"Tab positions occur every *tabsize* bytes (default is 8, giving tab positions at "
"columns 0, 8, 16 and so on).  To expand the sequence, the current column is set "
"to zero and the sequence is examined byte by byte.  If the byte is an ASCII tab "
"character (``b'\\t'``), one or more space characters are inserted in the result "
"until the current column is equal to the next tab position. (The tab character "
"itself is not copied.)  If the current byte is an ASCII newline (``b'\\n'``) or "
"carriage return (``b'\\r'``), it is copied and the current column is reset to "
"zero.  Any other byte value is copied unchanged and the current column is "
"incremented by one regardless of how the byte value is represented when printed::"
msgstr ""
"Geçerli sütuna ve verilen sekme boyutuna bağlı olarak, tüm ASCII sekme "
"karakterlerinin bir veya daha fazla ASCII boşluğuyla değiştirildiği dizinin bir "
"kopyasını döndürün. Sekme konumları her *tabsize* baytta bir gerçekleşir "
"(varsayılan 8'dir, 0, 8, 16 sütunlarında sekme konumları verir, vb.). Sırayı "
"genişletmek için mevcut sütun sıfıra ayarlanır ve sıra bayt bayt incelenir. Bayt "
"bir ASCII sekme karakteriyse (``b'\\t'``), geçerli sütun bir sonraki sekme "
"konumuna eşit olana kadar sonuca bir veya daha fazla boşluk karakteri eklenir. "
"(Sekme karakterinin kendisi kopyalanmaz.) Geçerli bayt bir ASCII yeni satır "
"(\"b'\\n''\") veya satırbaşı (\"b'\\r''\") ise, kopyalanır ve geçerli bayt sütun "
"sıfırlanır. Diğer tüm bayt değerleri değiştirilmeden kopyalanır ve geçerli "
"sütun, yazdırıldığında bayt değerinin nasıl temsil edildiğine bakılmaksızın bir "
"artırılır::"

#: library/stdtypes.rst:3249
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII characters "
"or ASCII decimal digits and the sequence is not empty, ``False`` otherwise. "
"Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Dizideki tüm baytlar alfabetik ASCII karakterleri veya ASCII ondalık "
"basamaklardan oluşuyorsa ve dizi boş değilse \"True\", aksi takdirde \"False\" "
"döndürün. Alfabetik ASCII karakterleri, "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'` dizisindeki bayt "
"değerleridir. ASCII ondalık basamakları, ``b'0123456789'` dizisindeki bayt "
"değerleridir."

#: library/stdtypes.rst:3266
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters and "
"the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII characters are "
"those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Dizideki tüm baytlar alfabetik ASCII karakterleriyse ve dizi boş değilse "
"\"True\", aksi takdirde \"False\" döndürün. Alfabetik ASCII karakterleri, "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'` dizisindeki bayt "
"değerleridir."

#: library/stdtypes.rst:3282
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are ASCII, "
"``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"Dizi boşsa veya dizideki tüm baytlar ASCII ise \"True\", aksi takdirde \"False\" "
"döndürün. ASCII baytları 0-0x7F aralığındadır."

#: library/stdtypes.rst:3292
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and the "
"sequence is not empty, ``False`` otherwise. ASCII decimal digits are those byte "
"values in the sequence ``b'0123456789'``."
msgstr ""
"Dizideki tüm baytlar ASCII ondalık basamaklardan oluşuyorsa ve dizi boş değilse "
"\"True\", aksi takdirde \"False\" döndürün. ASCII ondalık basamakları, "
"``b'0123456789'` dizisindeki bayt değerleridir."

#: library/stdtypes.rst:3307
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""
"Dizide en az bir küçük ASCII karakteri varsa ve büyük ASCII karakteri yoksa "
"\"True\", aksi takdirde \"False\" döndürün."

#: library/stdtypes.rst:3359 library/stdtypes.rst:3425 library/stdtypes.rst:3494
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Küçük harfli ASCII karakterleri, ``b'abcdefghijklmnopqrstuvwxyz'` dizisindeki "
"bayt değerleridir. Büyük ASCII karakterleri, ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'` "
"dizisindeki bayt değerleridir."

#: library/stdtypes.rst:3325
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Dizideki tüm baytlar ASCII boşluksa ve dizi boş değilse \"True\", aksi takdirde "
"\"False\" döndürün. ASCII boşluk karakterleri, ``b' \\t\\n\\r\\x0b\\f'`` "
"(boşluk, sekme, yeni satır, satırbaşı, dikey sekme, form besleme) dizisindeki "
"bayt değerleridir."

#: library/stdtypes.rst:3334
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Dizi ASCII başlık durumuysa ve dizi boş değilse \"True\", aksi takdirde "
"\"False\" döndürün. \"Başlık kasası\" tanımı hakkında daha fazla ayrıntı için :"
"meth:`bytes.title` konusuna bakın."

#: library/stdtypes.rst:3349
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII character in "
"the sequence and no lowercase ASCII characters, ``False`` otherwise."
msgstr ""
"Dizide en az bir büyük alfabetik ASCII karakteri varsa ve küçük ASCII karakteri "
"yoksa \"True\", aksi takdirde \"False\" döndürün."

#: library/stdtypes.rst:3367
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters converted "
"to their corresponding lowercase counterpart."
msgstr ""
"Tüm büyük ASCII karakterlerinin karşılık gelen küçük harflere dönüştürüldüğü "
"dizinin bir kopyasını döndürün."

#: library/stdtypes.rst:3392
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"İkili dizideki satırların bir listesini ASCII satır sınırlarında kırarak "
"döndürür. Bu yöntem, satırları bölmek için :term:`evrensel yeni satırlar` "
"yaklaşımını kullanır. Satır sonları, *keepends* verilmedikçe ve doğru olmadıkça "
"sonuç listesine dahil edilmez."

#: library/stdtypes.rst:3404
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this method "
"returns an empty list for the empty string, and a terminal line break does not "
"result in an extra line::"
msgstr ""
"Bir sınırlayıcı dize *sep* verildiğinde :meth:`~bytes.split`ten farklı olarak, "
"bu yöntem boş dize için boş bir liste döndürür ve uçbir satır sonu fazladan bir "
"satırla sonuçlanmaz::"

#: library/stdtypes.rst:3417
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters converted "
"to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Tüm küçük ASCII karakterlerinin karşılık gelen büyük harflere dönüştürüldüğü "
"dizinin bir kopyasını döndürün ve bunun tersi de geçerlidir."

#: library/stdtypes.rst:3429
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are symmetrical in "
"ASCII, even though that is not generally true for arbitrary Unicode code points."
msgstr ""
":func:`str.swapcase()`den farklı olarak, ikili sürümler için her zaman ``bin."
"swapcase().swapcase() == bin`` durumu söz konusudur. İsteğe bağlı Unicode kod "
"noktaları için genellikle doğru olmasa da, durum dönüştürmeleri ASCII'de "
"simetriktir."

#: library/stdtypes.rst:3443
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. Uncased "
"byte values are left unmodified."
msgstr ""
"Sözcüklerin büyük ASCII karakteriyle başladığı ve geri kalan karakterlerin küçük "
"harf olduğu ikili dizinin başlıklı bir sürümünü döndürün. Kasaya alınmamış bayt "
"değerleri değiştirilmeden bırakılır."

#: library/stdtypes.rst:3452
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte values "
"are uncased."
msgstr ""
"Küçük harfli ASCII karakterleri, ``b'abcdefghijklmnopqrstuvwxyz'` dizisindeki "
"bayt değerleridir. Büyük ASCII karakterleri, ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'` "
"dizisindeki bayt değerleridir. Diğer tüm bayt değerleri büyük/küçük harfe sahip "
"değildir."

#: library/stdtypes.rst:3465
msgid "A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Kesme işaretleri için geçici bir çözüm düzenli ifadeler kullanılarak "
"oluşturulabilir::"

#: library/stdtypes.rst:3486
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters converted "
"to their corresponding uppercase counterpart."
msgstr ""
"Karşılık gelen büyük harflere dönüştürülmüş tüm küçük ASCII karakterleriyle "
"dizinin bir kopyasını döndürün."

#: library/stdtypes.rst:3507
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make a "
"sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than before. "
"For :class:`bytes` objects, the original sequence is returned if *width* is less "
"than or equal to ``len(seq)``."
msgstr ""
"Uzunluk *genişlik* dizisi oluşturmak için ASCII ``b'0'`` rakamlarıyla dolu "
"bırakılan dizinin bir kopyasını döndürün. Baş işaret öneki (``b'+'``/``b'-'``), "
"işaret karakterinden önce değil *ardından* dolgu eklenerek işlenir. :class:"
"`bytes` nesneleri için, *width* ``len(seq)`` değerinden küçük veya ona eşitse "
"orijinal sıra döndürülür."

#: library/stdtypes.rst:3529
msgid "``printf``-style Bytes Formatting"
msgstr "``printf`` tarzı Bayt Biçimlendirmesi"

#: library/stdtypes.rst:3546
msgid ""
"The formatting operations described here exhibit a variety of quirks that lead "
"to a number of common errors (such as failing to display tuples and dictionaries "
"correctly).  If the value being printed may be a tuple or dictionary, wrap it in "
"a tuple."
msgstr ""
"Burada açıklanan biçimlendirme işlemleri, bir dizi yaygın hataya yol açan "
"(demetleri ve sözlükleri doğru şekilde görüntüleyememek gibi) çeşitli "
"tuhaflıklar sergiler. Yazdırılan değer bir demet veya sözlük olabilirse, onu bir "
"demet içine sarın."

#: library/stdtypes.rst:3551
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: the "
"``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a bytes "
"object), ``%`` conversion specifications in *format* are replaced with zero or "
"more elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""
"Bayt nesnelerinin (\"bytes\"/\"bytearray\") tek bir yerleşik işlemi vardır: \"%"
"\" işleci (modulo). Bu, bayt *biçimlendirme* veya *interpolasyon* operatörü "
"olarak da bilinir. Verilen ``biçim % değerleri'' (burada *format* bir bayt "
"nesnesidir), *format* içindeki ``%`` dönüştürme belirtimleri, sıfır veya daha "
"fazla *values* öğesiyle değiştirilir. Etki, C dilinde :c:func:`sprintf` "
"kullanımına benzer."

#: library/stdtypes.rst:3558
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"*format* tek bir argüman gerektiriyorsa, *values* demet olmayan tek bir nesne "
"olabilir. [5]_ Aksi takdirde, *değerler* tam olarak biçim bayt nesnesi "
"tarafından belirtilen öğe sayısına sahip bir grup veya tek bir eşleme nesnesi "
"(örneğin, bir sözlük) olmalıdır."

#: library/stdtypes.rst:3592
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Doğru bağımsız değişken bir sözlük (veya başka bir eşleme türü) olduğunda, bayt "
"nesnesindeki biçimler sözlüğe ``'%'`` karakterinden hemen sonra eklenen parantez "
"içinde bir eşleme anahtarı *içermelidir*. Eşleme anahtarı, eşlemeden "
"biçimlendirilecek değeri seçer. Örneğin:"

#: library/stdtypes.rst:3666
msgid "Single byte (accepts integer or single byte objects)."
msgstr "Tek bayt (tamsayı veya tek bayt nesneleri kabul eder)."

#: library/stdtypes.rst:3669
msgid "``'b'``"
msgstr "''b'''"

#: library/stdtypes.rst:3669
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`__bytes__`)."
msgstr ""
"Bayt ( :ref:`buffer protokolünü <bufferobjects>` takip eden veya :meth:"
"`__bytes__` içeren herhangi bir nesne)."

#: library/stdtypes.rst:3673
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code bases."
msgstr ""
"``'s'``, ``'b'`` için bir takma addır ve yalnızca Python2/3 kod tabanları için "
"kullanılmalıdır."

#: library/stdtypes.rst:3676
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""
"Bayt (``repr(obj).encode('ascii', 'backslashreplace')`` kullanarak herhangi bir "
"Python nesnesini dönüştürür)."

#: library/stdtypes.rst:3679
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code bases."
msgstr ""
"``'r'``, ``'a'`` için bir takma addır ve yalnızca Python2/3 kod tabanları için "
"kullanılmalıdır."

#: library/stdtypes.rst:3679
msgid "\\(7)"
msgstr "\\(7)"

#: library/stdtypes.rst:3714
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr ""
"''b'%s'`` kullanımdan kaldırılmıştır, ancak 3.x serisi sırasında "
"kaldırılmayacaktır."

#: library/stdtypes.rst:3717
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr ""
"''b'%r'`` kullanımdan kaldırılmıştır, ancak 3.x serisi sırasında "
"kaldırılmayacaktır."

#: library/stdtypes.rst:3729
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - Baytlara ve bytearray'e % formatlama ekleme"

#: library/stdtypes.rst:3736
msgid "Memory Views"
msgstr "Bellek Görünümleri"

#: library/stdtypes.rst:3738
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of an "
"object that supports the :ref:`buffer protocol <bufferobjects>` without copying."
msgstr ""
"class:`memoryview` nesneleri Python kodunun :ref:`buffer protocol "
"<bufferobjects>` destekleyen bir nesnenin dahili verilerine kopyalama yapmadan "
"erişmesini sağlar."

#: library/stdtypes.rst:3744
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must support "
"the buffer protocol.  Built-in objects that support the buffer protocol include :"
"class:`bytes` and :class:`bytearray`."
msgstr ""
"*nesneye* başvuran bir :class:`memoryview` oluşturun. *nesne* arabellek "
"protokolünü desteklemelidir. Tampon protokolünü destekleyen yerleşik nesneler "
"şunları içerir:class:`bytes` ve :class:`bytearray`."

#: library/stdtypes.rst:3748
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic memory "
"unit handled by the originating *object*.  For many simple types such as :class:"
"`bytes` and :class:`bytearray`, an element is a single byte, but other types "
"such as :class:`array.array` may have bigger elements."
msgstr ""
"Bir :class:`memoryview`, kaynak *nesne* tarafından yönetilen atomik bellek "
"birimi olan bir *element* kavramına sahiptir. :class:`bytes` ve :class:"
"`bytearray` gibi birçok basit tür için bir öğe tek bir bayttır, ancak :class:"
"`array.array` gibi diğer türler daha büyük öğelere sahip olabilir."

#: library/stdtypes.rst:3753
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`, which is "
"the nested list representation of the view. If ``view.ndim = 1``, this is equal "
"to the number of elements in the view."
msgstr ""
"``len(view)``, görünümün iç içe liste temsili olan :class:`~memoryview.tolist`in "
"uzunluğuna eşittir. ``view.ndim = 1`` ise bu, görünümdeki öğelerin sayısına "
"eşittir."

#: library/stdtypes.rst:3757
msgid ""
"If ``view.ndim == 0``, ``len(view)`` now raises :exc:`TypeError` instead of "
"returning 1."
msgstr ""
"``view.ndim == 0`` ise, ``len(view)`` artık 1 döndürmek yerine :exc:`TypeError` "
"değerini yükseltir."

#: library/stdtypes.rst:3760
msgid ""
"The :class:`~memoryview.itemsize` attribute will give you the number of bytes in "
"a single element."
msgstr ""
"``len(view)`` :class:`~memoryview.tolist` uzunluğuna eşittir. Eğer ``view.ndim = "
"0`` ise, uzunluk 1`dir. Eğer ``view.ndim = 1`` ise, uzunluk görünümdeki eleman "
"sayısına eşittir. Daha yüksek boyutlar için uzunluk, görünümün iç içe liste "
"gösteriminin uzunluğuna eşittir. Class:`~memoryview.itemsize` niteliği size tek "
"bir öğedeki bayt sayısını verecektir."

#: library/stdtypes.rst:3763
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
"Bir :class:`memoryview`, verilerini ortaya çıkarmak için dilimleme ve "
"indekslemeyi destekler. Tek boyutlu dilimleme bir alt görünümle sonuçlanacaktır::"

#: library/stdtypes.rst:3776
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from the :"
"mod:`struct` module, indexing with an integer or a tuple of integers is also "
"supported and returns a single *element* with the correct type.  One-dimensional "
"memoryviews can be indexed with an integer or a one-integer tuple.  Multi-"
"dimensional memoryviews can be indexed with tuples of exactly *ndim* integers "
"where *ndim* is the number of dimensions.  Zero-dimensional memoryviews can be "
"indexed with the empty tuple."
msgstr ""
"Eğer :class:`~memoryview.format`, :mod:`struct` modülündeki yerel format "
"belirleyicilerinden biriyse, bir tamsayı veya tamsayı çiftiyle indeksleme de "
"desteklenir ve doğru tipte tek bir *element* döndürür.  Tek boyutlu bellek "
"görünümleri bir tamsayı veya bir tamsayı çiftiyle indekslenebilir.  Çok boyutlu "
"bellek görünümleri, *ndim* boyut sayısı olmak üzere tam olarak *ndim* "
"tamsayılarından oluşan tuple'lar ile indekslenebilir.  Sıfır boyutlu bellek "
"görünümleri boş bir tuple ile indekslenebilir."

#: library/stdtypes.rst:3785
msgid "Here is an example with a non-byte format::"
msgstr "İşte bayt olmayan formatta bir örnek::"

#: library/stdtypes.rst:3797
msgid ""
"If the underlying object is writable, the memoryview supports one-dimensional "
"slice assignment. Resizing is not allowed::"
msgstr ""
"Altta yatan nesne yazılabilirse, memoryview tek boyutlu dilim atamasını "
"destekler. Yeniden boyutlandırmaya izin verilmez::"

#: library/stdtypes.rst:3818
msgid ""
"One-dimensional memoryviews of :term:`hashable` (read-only) types with formats "
"'B', 'b' or 'c' are also hashable. The hash is defined as ``hash(m) == hash(m."
"tobytes())``::"
msgstr ""
"'B', 'b' veya 'c' biçimli hashlenebilir (salt okunur) türlerin tek boyutlu "
"bellek görünümleri de hashlenebilir. Hash, ``hash(m) == hash(m.tobytes())``: "
"şeklinde tanımlanır:"

#: library/stdtypes.rst:3830
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews with "
"formats 'B', 'b' or 'c' are now :term:`hashable`."
msgstr ""
"Tek boyutlu bellek görünümleri artık dilimlenebilir. 'B', 'b' veya 'c' "
"formatlarına sahip tek boyutlu bellek görünümleri artık hashlenebilir."

#: library/stdtypes.rst:3834
msgid ""
"memoryview is now registered automatically with :class:`collections.abc.Sequence`"
msgstr ""
"memoryview artık :class:`collections.abc.Sequence` ile otomatik olarak kaydedilir"

#: library/stdtypes.rst:3838
msgid "memoryviews can now be indexed with tuple of integers."
msgstr "memoryviews artık tamsayılardan oluşan bir tuple ile indekslenebilir."

#: library/stdtypes.rst:3841
msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` birkaç yönteme sahiptir:"

#: library/stdtypes.rst:3845
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are equivalent "
"and if all corresponding values are equal when the operands' respective format "
"codes are interpreted using :mod:`struct` syntax."
msgstr ""
"Bir memoryview ve bir :pep:`3118` dışa aktarıcı, şekilleri eşdeğerse ve "
"işlenenlerin ilgili format kodları :mod:`struct` sözdizimi kullanılarak "
"yorumlandığında karşılık gelen tüm değerler eşitse eşittir."

#: library/stdtypes.rst:3849
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"Şu anda :meth:`tolist` tarafından desteklenen :mod:`struct` biçim dizelerinin "
"alt kümesi için, `v.tolist() == w.tolist() ise, ``v`` ve ``w`` eşittir. ``::"

#: library/stdtypes.rst:3868
msgid ""
"If either format string is not supported by the :mod:`struct` module, then the "
"objects will always compare as unequal (even if the format strings and buffer "
"contents are identical)::"
msgstr ""
"Biçim dizelerinden herhangi biri :mod:`struct` modülü tarafından "
"desteklenmiyorsa, nesneler her zaman eşit olmayan olarak karşılaştırılır (biçim "
"dizeleri ve arabellek içerikleri aynı olsa bile)::"

#: library/stdtypes.rst:3884
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v == "
"w`` for memoryview objects."
msgstr ""
"Kayan noktalı sayılarda olduğu gibi, \"v is w\" ifadesinin memoryview nesneleri "
"için \"v == w\" anlamına gelmediğini* unutmayın."

#: library/stdtypes.rst:3887
msgid ""
"Previous versions compared the raw memory disregarding the item format and the "
"logical array structure."
msgstr ""
"Önceki sürümler, öğe formatını ve mantıksal dizi yapısını göz ardı ederek ham "
"belleği karşılaştırdı."

#: library/stdtypes.rst:3893
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to calling "
"the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Tampondaki verileri bytestring olarak döndürün. Bu, bellek görünümünde :class:"
"`bytes` yapıcısını çağırmaya eşdeğerdir. ::"

#: library/stdtypes.rst:3902
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` supports "
"all format strings, including those that are not in :mod:`struct` module syntax."
msgstr ""
"Bitişik olmayan diziler için sonuç, tüm öğelerin bayta dönüştürüldüğü "
"düzleştirilmiş liste gösterimine eşittir. :meth:`tobytes`, :mod:`struct` "
"modülünün sözdiziminde olmayanlar da dahil olmak üzere tüm biçim dizelerini "
"destekler."

#: library/stdtypes.rst:3907
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory Fortran "
"order is preserved. For non-contiguous views, the data is converted to C first. "
"*order=None* is the same as *order='C'*."
msgstr ""
"*sipariş* {'C', 'F', 'A'} olabilir. *order* 'C' veya 'F' olduğunda, orijinal "
"dizinin verileri C veya Fortran sırasına dönüştürülür. Bitişik görünümler için "
"'A', fiziksel belleğin tam bir kopyasını döndürür. Özellikle bellek içi Fortran "
"düzeni korunur. Bitişik olmayan görünümler için veriler önce C'ye dönüştürülür. "
"*order=Yok*, *order='C'* ile aynıdır."

#: library/stdtypes.rst:3916
msgid ""
"Return a string object containing two hexadecimal digits for each byte in the "
"buffer. ::"
msgstr ""
"Arabellekteki her bayt için iki onaltılık basamak içeren bir dize nesnesi "
"döndürür. ::"

#: library/stdtypes.rst:3925
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional *sep* "
"and *bytes_per_sep* parameters to insert separators between bytes in the hex "
"output."
msgstr ""
":meth:`bytes.hex`e benzer şekilde, :meth:`memoryview.hex` artık onaltılık "
"çıktıda baytlar arasına ayırıcılar eklemek için isteğe bağlı *sep* ve "
"*bytes_per_sep* parametrelerini destekler."

#: library/stdtypes.rst:3932
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "Arabellekteki verileri bir öğe listesi olarak döndürün. ::"

#: library/stdtypes.rst:3942
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:`struct` "
"module syntax as well as multi-dimensional representations."
msgstr ""
":meth:`tolist` artık :mod:`struct` modülü sözdizimindeki tüm tek karakter yerel "
"formatlarını ve çok boyutlu gösterimleri destekliyor."

#: library/stdtypes.rst:3949
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""
"Memoryview nesnesinin salt okunur bir sürümünü döndürür. Orijinal memoryview "
"nesnesi değişmedi. ::"

#: library/stdtypes.rst:3968
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many objects "
"take special actions when a view is held on them (for example, a :class:"
"`bytearray` would temporarily forbid resizing); therefore, calling release() is "
"handy to remove these restrictions (and free any dangling resources) as soon as "
"possible."
msgstr ""
"Memoryview nesnesi tarafından sunulan temel arabelleği serbest bırakın. Birçok "
"nesne, üzerlerinde bir görünüm tutulduğunda özel eylemler gerçekleştirir "
"(örneğin, bir :class:'bytearray' yeniden boyutlandırmayı geçici olarak "
"yasaklar); bu nedenle, release() çağrılması, bu kısıtlamaları mümkün olan en "
"kısa sürede kaldırmak (ve sarkan kaynakları serbest bırakmak) için kullanışlıdır."

#: library/stdtypes.rst:3974
msgid ""
"After this method has been called, any further operation on the view raises a :"
"class:`ValueError` (except :meth:`release()` itself which can be called multiple "
"times)::"
msgstr ""
"Bu yöntem çağrıldıktan sonra, görünümdeki diğer işlemler bir :class:`ValueError` "
"oluşturur (birden çok kez çağrılabilen :meth:`release()` dışında)::"

#: library/stdtypes.rst:3985
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"Bağlam yönetimi protokolü, ``with`` ifadesi kullanılarak benzer bir etki için "
"kullanılabilir::"

#: library/stdtypes.rst:4001
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to ``[byte_length//"
"new_itemsize]``, which means that the result view will be one-dimensional. The "
"return value is a new memoryview, but the buffer itself is not copied. Supported "
"casts are 1D -> C-:term:`contiguous` and C-contiguous -> 1D."
msgstr ""
"Bir bellek görünümünü yeni bir biçime veya şekle dönüştürün. *shape* varsayılan "
"olarak ``[byte_length//new_itemsize]`` şeklindedir, bu da sonuç görünümünün tek "
"boyutlu olacağı anlamına gelir. Dönen değer, yeni bir bellek görünümüdür, ancak "
"arabelleğin kendisi kopyalanmaz. Desteklenen yayınlar 1D -> C-:term:`contiguous` "
"ve C-contiguous -> 1D'dir."

#: library/stdtypes.rst:4007
msgid ""
"The destination format is restricted to a single element native format in :mod:"
"`struct` syntax. One of the formats must be a byte format ('B', 'b' or 'c'). The "
"byte length of the result must be the same as the original length. Note that all "
"byte lengths may depend on the operating system."
msgstr ""
"Hedef format :mod:`struct` sözdiziminde tek öğeli yerel formatla sınırlıdır. "
"Formatlardan biri bayt formatı olmalıdır ('B', 'b' veya 'c'). Sonucun bayt "
"uzunluğu orijinal uzunlukla aynı olmalıdır. Tüm bayt uzunluklarının işletim "
"sistemine bağlı olabileceğini unutmayın."

#: library/stdtypes.rst:4013
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "1B/uzun ila 1B/işaretsiz baytları yayınla::"

#: library/stdtypes.rst:4036
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "1D/imzasız baytları 1D/char'a aktar::"

#: library/stdtypes.rst:4049
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "1D/baytları 3D'ye/ints'i 1D/signed char'a yayınla::"

#: library/stdtypes.rst:4075
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "1D/unsigned long'u 2D/unsigned long'a yayınla::"

#: library/stdtypes.rst:4089
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"Bir bayt görünümüne yayın yapılırken kaynak biçimi artık kısıtlanmamaktadır."

#: library/stdtypes.rst:4092
msgid "There are also several readonly attributes available:"
msgstr "Ayrıca birkaç salt okunur öznitelik mevcuttur:"

#: library/stdtypes.rst:4096
msgid "The underlying object of the memoryview::"
msgstr "Memoryview'in altında yatan nesne::"

#: library/stdtypes.rst:4107
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the amount "
"of space in bytes that the array would use in a contiguous representation. It is "
"not necessarily equal to ``len(m)``::"
msgstr ""
"``nbayt == ürün(şekil) * öğe boyutu == len(m.tobytes())``. Bu, dizinin bitişik "
"bir temsilde kullanacağı bayt cinsinden alan miktarıdır. ``len(m)`` değerine "
"eşit olması gerekmez::"

#: library/stdtypes.rst:4126
msgid "Multi-dimensional arrays::"
msgstr "Çok boyutlu diziler::"

#: library/stdtypes.rst:4143
msgid "A bool indicating whether the memory is read only."
msgstr "Belleğin salt okunur olup olmadığını gösteren bir bool."

#: library/stdtypes.rst:4147
msgid ""
"A string containing the format (in :mod:`struct` module style) for each element "
"in the view. A memoryview can be created from exporters with arbitrary format "
"strings, but some methods (e.g. :meth:`tolist`) are restricted to native single "
"element formats."
msgstr ""
"Görünümdeki her öğe için biçimi ( :mod:`struct` modül stilinde) içeren bir dize. "
"Rastgele biçim dizeleriyle dışa aktarıcılardan bir bellek görünümü "
"oluşturulabilir, ancak bazı yöntemler (ör. :meth:`tolist`) yerel tek öğe "
"biçimleriyle sınırlıdır."

#: library/stdtypes.rst:4152
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This means "
"that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"``'B'`` formatı artık yapı modülü sözdizimine göre işleniyor. Bu, "
"``memoryview(b'abc')[0] == b'abc'[0] == 97`` anlamına gelir."

#: library/stdtypes.rst:4158
msgid "The size in bytes of each element of the memoryview::"
msgstr "Bellek görünümündeki her bir öğenin bayt cinsinden boyutu::"

#: library/stdtypes.rst:4171
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Belleğin çok boyutlu bir dizinin kaç boyutunu temsil ettiğini gösteren bir "
"tamsayı."

#: library/stdtypes.rst:4176
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the memory as "
"an N-dimensional array."
msgstr ""
"Belleğin şeklini N boyutlu bir dizi olarak veren :attr:`ndim` uzunluğunda bir "
"tam sayı demeti."

#: library/stdtypes.rst:4187
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "Ndim = 0 olduğunda ``None`` yerine boş bir demetdir."

#: library/stdtypes.rst:4184
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
":attr:`ndim` uzunluğunda, dizinin her boyutu için her bir öğeye erişmek için "
"boyutu bayt cinsinden veren bir tamsayı demeti."

#: library/stdtypes.rst:4192
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""
"PIL tarzı diziler için dahili olarak kullanılır. Değer yalnızca bilgi amaçlıdır."

#: library/stdtypes.rst:4196
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "Belleğin C-:term:`contiguous` olup olmadığını gösteren bir bool."

#: library/stdtypes.rst:4202
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "Belleğin Fortran :term:`contiguous` olup olmadığını gösteren bir bool."

#: library/stdtypes.rst:4208
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "Belleğin :term:`contiguous` olup olmadığını gösteren bir bool."

#: library/stdtypes.rst:4216
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Set Türleri --- :class:`set`, :class:`frozenset`"

#: library/stdtypes.rst:4220
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-in :"
"class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Bir :dfn:`set` nesnesi, farklı :term:`hashable` nesnelerinin sıralanmamış bir "
"koleksiyonudur. Yaygın kullanımları arasında üyelik sınaması, bir diziden "
"yinelenenlerin kaldırılması ve kesişim, birleşim, fark ve simetrik fark gibi "
"matematiksel işlemlerin hesaplanması yer alır. (Diğer kapsayıcılar için "
"yerleşik :class:`dict`, :class:`list` ve :class:`tuple` sınıflarına ve :mod:"
"`collections` modülüne bakın)"

#: library/stdtypes.rst:4227
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x in "
"set``.  Being an unordered collection, sets do not record element position or "
"order of insertion.  Accordingly, sets do not support indexing, slicing, or "
"other sequence-like behavior."
msgstr ""
"Diğer koleksiyonlar gibi, kümeler de ``x in set``, ``len(set)``, ve ``for x in "
"set`` özelliklerini destekler.  Sırasız bir koleksiyon olan kümeler, eleman "
"konumunu veya ekleme sırasını kaydetmez.  Buna göre, kümeler dizinleme, "
"dilimleme veya sıra benzeri davranışları desteklemez."

#: library/stdtypes.rst:4232
msgid ""
"There are currently two built-in set types, :class:`set` and :class:`frozenset`. "
"The :class:`set` type is mutable --- the contents can be changed using methods "
"like :meth:`~set.add` and :meth:`~set.remove`.  Since it is mutable, it has no "
"hash value and cannot be used as either a dictionary key or as an element of "
"another set.  The :class:`frozenset` type is immutable and :term:`hashable` --- "
"its contents cannot be altered after it is created; it can therefore be used as "
"a dictionary key or as an element of another set."
msgstr ""
"Şu anda iki yerleşik set türü vardır, :class:`set` ve :class:`frozenset`. :class:"
"`set` türü değişkendir --- içeriği :meth:`~set.add` ve :meth:`~set.remove` gibi "
"yöntemler kullanılarak değiştirilebilir.  Değiştirilebilir olduğu için hash "
"değeri yoktur ve bir sözlük anahtarı ya da başka bir kümenin elemanı olarak "
"kullanılamaz. :class:`frozenset` türü değişmezdir ve :term:`hashable` --- "
"içeriği oluşturulduktan sonra değiştirilemez; bu nedenle bir sözlük anahtarı "
"veya başka bir kümenin öğesi olarak kullanılabilir."

#: library/stdtypes.rst:4240
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated list "
"of elements within braces, for example: ``{'jack', 'sjoerd'}``, in addition to "
"the :class:`set` constructor."
msgstr ""
"Boş olmayan kümeler (frozensetler değil), :class:`set` yapıcısına ek olarak "
"parantez içine virgülle ayrılmış bir öğe listesi yerleştirilerek "
"oluşturulabilir, örneğin: ``{'jack', 'sjoerd'}``."

#: library/stdtypes.rst:4244
msgid "The constructors for both classes work the same:"
msgstr "Her iki sınıfın kurucuları aynı şekilde çalışır:"

#: library/stdtypes.rst:4249
msgid ""
"Return a new set or frozenset object whose elements are taken from *iterable*.  "
"The elements of a set must be :term:`hashable`.  To represent sets of sets, the "
"inner sets must be :class:`frozenset` objects.  If *iterable* is not specified, "
"a new empty set is returned."
msgstr ""
"Elemanları *iterable* öğesinden alınan yeni bir küme veya frozenset nesnesi "
"döndürür.  Bir kümenin elemanları :term:`hashable` olmalıdır.  Kümelerin "
"kümelerini temsil etmek için, iç kümeler :class:`frozenset` nesneleri "
"olmalıdır.  Eğer *iterable* belirtilmemişse, yeni bir boş küme döndürülür."

#: library/stdtypes.rst:4255
msgid "Sets can be created by several means:"
msgstr "Setler çeşitli yollarla oluşturulabilir:"

#: library/stdtypes.rst:4257
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr ""
"Parantez içinde virgülle ayrılmış bir öğe listesi kullanın: ``{'jack', 'sjoerd'}"
"``"

#: library/stdtypes.rst:4258
msgid "Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr ""
"Bir küme kavrayışı kullanın: ``{c for c in 'abracadabra' if c not in 'abc'}``"

#: library/stdtypes.rst:4259
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""
"Tür kurucusunu kullanın: ``set()``, ``set('foobar')``, ``set(['a', 'b', 'foo'])``"

#: library/stdtypes.rst:4261
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ":class:`set` ve :class:`frozenset` örnekleri aşağıdaki işlemleri sağlar:"

#: library/stdtypes.rst:4266
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "*s* kümesindeki eleman sayısını döndürür (*s*'nin kardinalitesi)."

#: library/stdtypes.rst:4270
msgid "Test *x* for membership in *s*."
msgstr "*x*'i *s* üyeliği için test edin."

#: library/stdtypes.rst:4274
msgid "Test *x* for non-membership in *s*."
msgstr "*x*'in *s*'ye üye olup olmadığını test edin."

#: library/stdtypes.rst:4278
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Kümenin *other* kümelerle ortak hiçbir elemanı yoksa ``True`` döndürür.  "
"Kümeler, ancak ve ancak kesişimleri boş küme ise ayrıktır."

#: library/stdtypes.rst:4284
msgid "Test whether every element in the set is in *other*."
msgstr "Kümedeki her elemanın *other* içinde olup olmadığını test edin."

#: library/stdtypes.rst:4288
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other and "
"set != other``."
msgstr ""
"Kümenin *other* kümenin uygun bir alt kümesi olup olmadığını, yani ``set <= "
"other and set != other`` olup olmadığını test eder."

#: library/stdtypes.rst:4294
msgid "Test whether every element in *other* is in the set."
msgstr "Kümedeki her elemanın *other* içinde olup olmadığını test edin."

#: library/stdtypes.rst:4298
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= other "
"and set != other``."
msgstr ""
"Kümenin *other* kümenin uygun bir üst kümesi olup olmadığını, yani ``set >= "
"other and set != other`` olup olmadığını test edin."

#: library/stdtypes.rst:4304
msgid "Return a new set with elements from the set and all others."
msgstr ""
"Kümedeki ve diğer tüm kümelerdeki elemanları içeren yeni bir küme döndürür."

#: library/stdtypes.rst:4309
msgid "Return a new set with elements common to the set and all others."
msgstr "Küme ve diğer tüm kümeler için ortak öğeler içeren yeni bir küme döndürür."

#: library/stdtypes.rst:4314
msgid "Return a new set with elements in the set that are not in the others."
msgstr "Küme içinde diğerlerinde olmayan elemanlar içeren yeni bir küme döndürür."

#: library/stdtypes.rst:4319
msgid "Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Elemanları ya kümede ya da *diğer* kümede olan ancak her ikisinde de olmayan "
"yeni bir küme döndürür."

#: library/stdtypes.rst:4323
msgid "Return a shallow copy of the set."
msgstr "Kümenin yüzeysel bir kopyasını döndürür."

#: library/stdtypes.rst:4326
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :meth:"
"`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and :meth:"
"`issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of the "
"more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Not: :meth:`union`, :meth:`intersection`, :meth:`difference`, :meth:"
"`symmetric_difference`, :meth:`issubset` ve :meth:`issuperset` metotlarının "
"operatörsüz versiyonları herhangi bir yinelenebiliri argüman olarak kabul "
"edecektir.  Buna karşılık, operatör tabanlı benzerleri argümanlarının küme "
"olmasını gerektirir.  Bu, daha okunabilir ``set('abc').intersection('cbs')`` "
"yerine ``set('abc') & 'cbs'`` gibi hataya açık yapıları engeller.\n"
"\n"
"Translated with www.DeepL.com/Translator (free version)"

#: library/stdtypes.rst:4333
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but is "
"not equal). A set is greater than another set if and only if the first set is a "
"proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"Hem :class:`set` hem de :class:`frozenset` kümeden kümeye karşılaştırmaları "
"destekler. İki küme, ancak ve ancak her kümenin her elemanı diğerinin içinde "
"bulunuyorsa (her biri diğerinin alt kümesi ise) eşittir. Bir küme başka bir "
"kümeden ancak ve ancak birinci küme ikinci kümenin uygun bir alt kümesi ise (bir "
"alt kümedir, ancak eşit değildir) küçüktür. Bir küme, ancak ve ancak birinci "
"küme ikinci kümenin uygun bir üst kümesi ise (bir üst kümedir, ancak eşit "
"değildir) başka bir kümeden büyüktür.\n"
"\n"
"Translated with www.DeepL.com/Translator (free version)"

#: library/stdtypes.rst:4340
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` based "
"on their members.  For example, ``set('abc') == frozenset('abc')`` returns "
"``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
":class:`set` örnekleri, üyelerine göre :class:`frozenset` örnekleriyle "
"karşılaştırılır.  Örneğin, ``set('abc') == frozenset('abc')`` ``True`` döndürür "
"ve ``set('abc') in set([frozenset('abc')])`` de öyle."

#: library/stdtypes.rst:4344
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are not "
"subsets of each other, so *all* of the following return ``False``: ``a<b``, "
"``a==b``, or ``a>b``."
msgstr ""
"Alt küme ve eşitlik karşılaştırmaları toplam sıralama fonksiyonuna "
"genelleştirilemez.  Örneğin, boş olmayan herhangi iki ayrık küme eşit değildir "
"ve birbirinin alt kümesi değildir, bu nedenle aşağıdakilerin *all* ``Yanlış`` "
"döndürür: ``a<b``, ``a==b`` veya ``a>b``."

#: library/stdtypes.rst:4349
msgid ""
"Since sets only define partial ordering (subset relationships), the output of "
"the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Kümeler yalnızca kısmi sıralama (alt küme ilişkileri) tanımladığından, :meth:"
"`list.sort` yönteminin çıktısı küme listeleri için tanımsızdır."

#: library/stdtypes.rst:4352
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr "Sözlük anahtarları gibi küme öğeleri de :term:`hashable` olmalıdır."

#: library/stdtypes.rst:4354
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` return "
"the type of the first operand.  For example: ``frozenset('ab') | set('bc')`` "
"returns an instance of :class:`frozenset`."
msgstr ""
":class:`set` örneklerini :class:`frozenset` ile karıştıran ikili işlemler ilk "
"işlenenin türünü döndürür.  Örneğin: ``frozenset('ab') | set('bc')`` bir :class:"
"`frozenset` örneği döndürür."

#: library/stdtypes.rst:4358
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"Aşağıdaki tabloda :class:`set` için kullanılabilen ve :class:`frozenset` 'in "
"değişmez örneklerine uygulanmayan işlemler listelenmektedir:"

#: library/stdtypes.rst:4364
msgid "Update the set, adding elements from all others."
msgstr "Diğer tüm öğeleri ekleyerek seti güncelleyin."

#: library/stdtypes.rst:4369
msgid "Update the set, keeping only elements found in it and all others."
msgstr "Yalnızca içinde bulunan öğeleri ve diğerlerini koruyarak seti güncelleyin."

#: library/stdtypes.rst:4374
msgid "Update the set, removing elements found in others."
msgstr "Diğerlerinde bulunan öğeleri kaldırarak kümeyi güncelleyin."

#: library/stdtypes.rst:4379
msgid "Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Kümeyi güncelleyin, yalnızca her iki kümede de bulunan öğeleri saklayın, ancak "
"her ikisinde de bulunmayın."

#: library/stdtypes.rst:4383
msgid "Add element *elem* to the set."
msgstr "Kümeye *elem* öğesini ekleyin."

#: library/stdtypes.rst:4387
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Kümeden *elem* elemanını kaldırır.  Eğer *elem* kümede bulunmuyorsa :exc:"
"`KeyError` değerini yükseltir."

#: library/stdtypes.rst:4392
msgid "Remove element *elem* from the set if it is present."
msgstr "Eğer varsa *elem* öğesini kümeden kaldırır."

#: library/stdtypes.rst:4396
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` if "
"the set is empty."
msgstr ""
"Kümeden rastgele bir elemanı kaldırır ve döndürür.  Küme boşsa :exc:`KeyError` "
"değerini yükseltir."

#: library/stdtypes.rst:4401
msgid "Remove all elements from the set."
msgstr "Kümeden tüm öğeleri kaldırın."

#: library/stdtypes.rst:4404
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an argument."
msgstr ""
"Not: :meth:`update`, :meth:`intersection_update`, :meth:`difference_update` ve :"
"meth:`symmetric_difference_update` metotlarının operatör olmayan versiyonları "
"herhangi bir iterable'ı argüman olarak kabul edecektir."

#: library/stdtypes.rst:4409
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :meth:"
"`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""
"Not: :meth:`__contains__`, :meth:`remove` ve :meth:`discard` yöntemlerinin "
"*elem* argümanı bir küme olabilir.  Eş değer bir frozenset aramayı desteklemek "
"için, *elem*'den geçici bir tane oluşturulur."

#: library/stdtypes.rst:4417
msgid "Mapping Types --- :class:`dict`"
msgstr "Mapping Types --- :class:`dict`"

#: library/stdtypes.rst:4427
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Bir :term:`mapping` nesnesi :term:`hashable` değerlerini rastgele nesnelere "
"eşler. Eşlemeler değiştirilebilir nesnelerdir.  Şu anda sadece bir standart "
"eşleme türü vardır, :dfn:`dictionary`.  (Diğer kapsayıcılar için yerleşik :class:"
"`list`, :class:`set` ve :class:`tuple` sınıflarına ve :mod:`collections` "
"modülüne bakın)."

#: library/stdtypes.rst:4433
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :term:"
"`hashable`, that is, values containing lists, dictionaries or other mutable "
"types (that are compared by value rather than by object identity) may not be "
"used as keys. Values that compare equal (such as ``1``, ``1.0``, and ``True``) "
"can be used interchangeably to index the same dictionary entry."
msgstr ""
"Bir sözlüğün anahtarları *neredeyse* rastgele değerlerdir. :term:`hashable` "
"olmayan değerler, yani listeler, sözlükler veya diğer değişken türleri içeren "
"değerler (nesne kimliği yerine değere göre karşılaştırılan) anahtar olarak "
"kullanılamaz. Eşit karşılaştırılan değerler (``1``, ``1.0`` ve ``True`` gibi) "
"aynı sözlük girdisini indekslemek için birbirinin yerine kullanılabilir."

#: library/stdtypes.rst:4444
msgid ""
"Return a new dictionary initialized from an optional positional argument and a "
"possibly empty set of keyword arguments."
msgstr ""
"İsteğe bağlı bir konumsal bağımsız değişken ve muhtemelen boş bir anahtar sözcük "
"bağımsız değişken kümesinden başlatılan yeni bir sözlük döndürür."

#: library/stdtypes.rst:4447
msgid "Dictionaries can be created by several means:"
msgstr "Sözlükler çeşitli yollarla oluşturulabilir:"

#: library/stdtypes.rst:4449
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"Parantez içinde ``anahtar: değer`` çiftlerinin virgülle ayrılmış bir listesini "
"kullanın: ``{'jack': 4098, 'sjoerd': 4127}`` veya ``{4098: 'jack', 4127: "
"'sjoerd'}``"

#: library/stdtypes.rst:4451
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr "Bir dict anlayışı kullanın: ``{}``, ``{x: x ** 2 for x in range(10)}``"

#: library/stdtypes.rst:4452
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', 200)])``, "
"``dict(foo=100, bar=200)``"
msgstr ""
"Tür oluşturucusunu kullanın: ``dict()``, ``dict([('foo', 100), ('bar', 200)])``, "
"``dict(foo=100, bar=200)``"

#: library/stdtypes.rst:4455
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is created "
"with the same key-value pairs as the mapping object.  Otherwise, the positional "
"argument must be an :term:`iterable` object.  Each item in the iterable must "
"itself be an iterable with exactly two objects.  The first object of each item "
"becomes a key in the new dictionary, and the second object the corresponding "
"value.  If a key occurs more than once, the last value for that key becomes the "
"corresponding value in the new dictionary."
msgstr ""
"Konumsal bağımsız değişken verilmezse, boş bir sözlük oluşturulur. Konumsal bir "
"bağımsız değişken verilmişse ve bu bir eşleme nesnesiyse, eşleme nesnesiyle aynı "
"anahtar-değer çiftlerine sahip bir sözlük oluşturulur.  Aksi takdirde, konumsal "
"argüman bir :term:`iterable` nesnesi olmalıdır.  Yinelenebilirdeki her öğenin "
"kendisi tam olarak iki nesneli bir yinelenebilir olmalıdır.  Her öğenin ilk "
"nesnesi yeni sözlükte bir anahtar, ikinci nesnesi ise karşılık gelen değer "
"olur.  Bir anahtar birden fazla kez geçerse, bu anahtar için son değer yeni "
"sözlükte karşılık gelen değer olur."

#: library/stdtypes.rst:4465
msgid ""
"If keyword arguments are given, the keyword arguments and their values are added "
"to the dictionary created from the positional argument.  If a key being added is "
"already present, the value from the keyword argument replaces the value from the "
"positional argument."
msgstr ""
"Anahtar sözcük bağımsız değişkenleri verilirse, anahtar sözcük bağımsız "
"değişkenleri ve değerleri, konumsal bağımsız değişkenden oluşturulan sözlüğe "
"eklenir.  Eklenen bir anahtar zaten mevcutsa, anahtar sözcük bağımsız "
"değişkenindeki değer, konumsal bağımsız değişkendeki değerin yerini alır."

#: library/stdtypes.rst:4470
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Örnek olarak, aşağıdaki örneklerin tümü ``{\"one\") eşit bir sözlük döndürür: 1, "
"\"iki\": 2, \"üç\": 3}``::"

#: library/stdtypes.rst:4482
msgid ""
"Providing keyword arguments as in the first example only works for keys that are "
"valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"İlk örnekteki gibi anahtar kelime argümanları sağlamak yalnızca geçerli Python "
"tanımlayıcıları olan anahtarlar için çalışır.  Aksi takdirde, herhangi bir "
"geçerli anahtar kullanılabilir."

#: library/stdtypes.rst:4486
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Bunlar sözlüklerin desteklediği işlemlerdir (ve bu nedenle özel eşleme "
"türlerinin de desteklemesi gerekir):"

#: library/stdtypes.rst:4491
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr "D* sözlüğünde kullanılan tüm anahtarların bir listesini döndürür."

#: library/stdtypes.rst:4495
msgid "Return the number of items in the dictionary *d*."
msgstr "Sözlükteki öğelerin sayısını döndürür *d*."

#: library/stdtypes.rst:4499
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is not "
"in the map."
msgstr ""
"*d* öğesinin öğesini *key* tuşuyla döndürün. *key* haritada yoksa bir :exc:"
"`KeyError` oluşturur."

#: library/stdtypes.rst:4504
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is returned "
"or raised by the ``__missing__(key)`` call. No other operations or methods "
"invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :exc:"
"`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be an "
"instance variable::"
msgstr ""
"Bir dict alt sınıfı, bir yöntemi :meth:`__missing__` ve *key* tanımlıyorsa, "
"``d[key]`` işlemi, argüman olarak *key* anahtarıyla bu yöntemi çağırır. Ardından "
"\"d[key]\" işlemi, \"__missing__(key)\" çağrısı tarafından döndürülen veya "
"yükseltilen her şeyi döndürür veya yükseltir. Başka hiçbir işlem veya yöntem :"
"meth:`__missing__` çağırmaz. :meth:`__missing__` tanımlı değilse, :exc:"
"`KeyError` yükseltilir. :meth:`__missing__` bir yöntem olmalıdır; bir örnek "
"değişken olamaz::"

#: library/stdtypes.rst:4523
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"Yukarıdaki örnek, :class:`collections.Counter` uygulamasının bir bölümünü "
"göstermektedir. :class:`collections.defaultdict` tarafından farklı bir "
"''__missing__'' yöntemi kullanılıyor."

#: library/stdtypes.rst:4529
msgid "Set ``d[key]`` to *value*."
msgstr "``d[key]`` değerini *değer* olarak ayarlayın."

#: library/stdtypes.rst:4533
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the map."
msgstr ""
"*d*'den ``d[key]`` ifadesini kaldırın. *key* haritada yoksa bir :exc:`KeyError` "
"oluşturur."

#: library/stdtypes.rst:4538
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""
"*d* bir *key* anahtarına sahipse ``True``, aksi takdirde ``False`` döndürün."

#: library/stdtypes.rst:4542
msgid "Equivalent to ``not key in d``."
msgstr "``not key in d`` ile eşdeğerdir."

#: library/stdtypes.rst:4546
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Sözlüğün anahtarları üzerinden bir yineleyici döndürün. Bu, ``iter(d.keys())`` "
"için bir kısayoldur."

#: library/stdtypes.rst:4551
msgid "Remove all items from the dictionary."
msgstr "Sözlükten tüm öğeleri kaldırın."

#: library/stdtypes.rst:4555
msgid "Return a shallow copy of the dictionary."
msgstr "Sözlüğün sığ bir kopyasını döndürün."

#: library/stdtypes.rst:4559
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"*iterable* anahtarları ve *value* olarak ayarlanmış değerlerle yeni bir sözlük "
"oluşturun."

#: library/stdtypes.rst:4561
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so it "
"generally doesn't make sense for *value* to be a mutable object such as an empty "
"list.  To get distinct values, use a :ref:`dict comprehension <dict>` instead."
msgstr ""
":meth:`fromkeys`, yeni bir sözlük döndüren bir sınıf yöntemidir. *değer* "
"varsayılan olarak \"Yok\" şeklindedir. Tüm değerler yalnızca tek bir örneğe "
"atıfta bulunur, bu nedenle *değerin* boş bir liste gibi değişken bir nesne "
"olması genellikle mantıklı değildir. Farklı değerler elde etmek için bunun "
"yerine bir :ref:`dict anlayışı <dict>` kullanın."

#: library/stdtypes.rst:4569
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"*key* sözlükteyse *key* için değer döndürür, aksi takdirde *varsayılan*. "
"*varsayılan* belirtilmezse, varsayılan olarak \"Yok\" olur, böylece bu yöntem "
"hiçbir zaman bir :exc:\"KeyError\" oluşturmaz."

#: library/stdtypes.rst:4575
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See the :"
"ref:`documentation of view objects <dict-views>`."
msgstr ""
"Sözlüğün öğelerinin (``(anahtar, değer)`` çiftleri) yeni bir görünümünü "
"döndürür. :ref:`görünüm nesnelerinin <dict-views> belgelerine bakın."

#: library/stdtypes.rst:4580
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of view "
"objects <dict-views>`."
msgstr ""
"Sözlük anahtarlarının yeni bir görünümünü döndürür. :ref:`görünüm nesnelerinin "
"<dict-views> belgelerine bakın."

#: library/stdtypes.rst:4585
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :exc:"
"`KeyError` is raised."
msgstr ""
"*anahtar* sözlükteyse, kaldırın ve değerini döndürün, aksi takdirde "
"*varsayılanı* döndürün. *varsayılan* verilmemişse ve *key* sözlükte yoksa :exc:"
"`KeyError` ortaya çıkar."

#: library/stdtypes.rst:4591
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"Sözlükten bir ``(anahtar, değer)`` çiftini kaldırın ve döndürün. Çiftler :abbr:"
"`LIFO (son giren ilk çıkar)` sırasına göre döndürülür."

#: library/stdtypes.rst:4594
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as often "
"used in set algorithms.  If the dictionary is empty, calling :meth:`popitem` "
"raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem`, küme algoritmalarında sıklıkla kullanıldığı gibi, bir sözlük "
"üzerinde yıkıcı bir şekilde yineleme yapmak için kullanışlıdır. Sözlük boşsa, :"
"meth:`popitem` çağrısı bir :exc:`KeyError` oluşturur."

#: library/stdtypes.rst:4598
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would return an "
"arbitrary key/value pair."
msgstr ""
"LIFO siparişi artık garantilidir. Önceki sürümlerde :meth:`popitem` rastgele bir "
"anahtar/değer çifti döndürürdü."

#: library/stdtypes.rst:4604
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a shortcut "
"for ``reversed(d.keys())``."
msgstr ""
"Sözlüğün anahtarları üzerinde bir ters yineleyici döndürün. Bu, ``reversed(d."
"keys())`` için bir kısayoldur."

#: library/stdtypes.rst:4611
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with a "
"value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"*key* sözlükteyse, değerini döndürün. Değilse, *default* değeriyle *key* girin "
"ve *default* değerini döndürün. *varsayılan* varsayılan değer \"Yok\" "
"şeklindedir."

#: library/stdtypes.rst:4617
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Mevcut anahtarların üzerine yazarak sözlüğü *diğer* öğesinden anahtar/değer "
"çiftleriyle güncelleyin. ``Yok`` döndürün."

#: library/stdtypes.rst:4620
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of key/"
"value pairs (as tuples or other iterables of length two).  If keyword arguments "
"are specified, the dictionary is then updated with those key/value pairs: ``d."
"update(red=1, blue=2)``."
msgstr ""
":meth:`update`, başka bir sözlük nesnesini veya bir yinelemeli anahtar/değer "
"çiftlerini (demetler veya iki uzunluktaki diğer yinelemeler olarak) kabul eder. "
"Anahtar kelime bağımsız değişkenleri belirtilirse, sözlük şu anahtar/değer "
"çiftleriyle güncellenir: ``d.update(red=1, blue=2)``."

#: library/stdtypes.rst:4627
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Sözlüğün değerlerinin yeni bir görünümünü döndürür. :ref:`görünüm nesnelerinin "
"<dict-views> belgelerine bakın."

#: library/stdtypes.rst:4630
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` to "
"itself::"
msgstr ""
"Bir \"dict.values()\" görünümü ile diğeri arasındaki eşitlik karşılaştırması her "
"zaman \"False\" döndürür. Bu, ``dict.values()`` kendisiyle karşılaştırılırken de "
"geçerlidir::"

#: library/stdtypes.rst:4640
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when *d* "
"and *other* share keys."
msgstr ""
"Her ikisi de sözlük olması gereken birleştirilmiş *d* ve *other* anahtarları ve "
"değerleriyle yeni bir sözlük oluşturun. *d* ve *other* anahtarları paylaştığında "
"*other* değerleri önceliklidir."

#: library/stdtypes.rst:4648
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be either "
"a :term:`mapping` or an :term:`iterable` of key/value pairs. The values of "
"*other* take priority when *d* and *other* share keys."
msgstr ""
"*d* sözlüğünü, bir :term:'mapping' veya :term:'iterable' anahtar/değer çiftleri "
"olabilen *other*'dan gelen anahtarlar ve değerlerle güncelleyin. *d* ve *other* "
"anahtarları paylaştığında *other* değerleri önceliklidir."

#: library/stdtypes.rst:4654
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, value)`` "
"pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', '>') raise :"
"exc:`TypeError`."
msgstr ""
"Sözlükler, ancak ve ancak aynı ``(anahtar, değer)`` çiftlerine sahiplerse "
"(sıralamadan bağımsız olarak) eşit karşılaştırırlar. Sipariş karşılaştırmaları "
"('<', '<=', '>=', '>') :exc:`TypeError` yükseltir."

#: library/stdtypes.rst:4658
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not affect "
"the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"Sözlükler ekleme sırasını korur. Bir anahtarı güncellemenin sırayı "
"etkilemediğini unutmayın. Silme işleminden sonra eklenen anahtarlar en sona "
"eklenir. ::"

#: library/stdtypes.rst:4676
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"Sözlük siparişinin kampanya siparişi olması garanti edilir. Bu davranış, 3.6'dan "
"CPython'un bir uygulama detayıydı."

#: library/stdtypes.rst:4680
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr "Sözlükler ve sözlük görünümleri tersine çevrilebilir. ::"

#: library/stdtypes.rst:4692
msgid "Dictionaries are now reversible."
msgstr "Sözlükler artık tersine çevrilebilir."

#: library/stdtypes.rst:4697
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
":class:`types.MappingProxyType`, bir :class:`dict` öğesinin salt okunur bir "
"görünümünü oluşturmak için kullanılabilir."

#: library/stdtypes.rst:4704
msgid "Dictionary view objects"
msgstr "Sözlük görünümü nesneleri"

#: library/stdtypes.rst:4706
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:`dict."
"items` are *view objects*.  They provide a dynamic view on the dictionary's "
"entries, which means that when the dictionary changes, the view reflects these "
"changes."
msgstr ""
":meth:`dict.keys`, :meth:`dict.values` ve :meth:`dict.items` tarafından "
"döndürülen nesneler *görünüm nesneleridir*. Sözlüğün girişleri üzerinde dinamik "
"bir görünüm sağlarlar; bu, sözlük değiştiğinde görünümün bu değişiklikleri "
"yansıttığı anlamına gelir."

#: library/stdtypes.rst:4711
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Sözlük görünümleri, ilgili verilerini elde etmek ve üyelik testlerini "
"desteklemek için yinelenebilir:"

#: library/stdtypes.rst:4716
msgid "Return the number of entries in the dictionary."
msgstr "Sözlükteki girişlerin sayısını döndürür."

#: library/stdtypes.rst:4720
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Sözlükteki anahtarlar, değerler veya öğeler (\"(anahtar, değer)\" demetleri "
"olarak temsil edilir) üzerinde bir yineleyici döndürün."

#: library/stdtypes.rst:4723
msgid ""
"Keys and values are iterated over in insertion order. This allows the creation "
"of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d.values(), d."
"keys())``.  Another way to create the same list is ``pairs = [(v, k) for (k, v) "
"in d.items()]``."
msgstr ""
"Anahtarlar ve değerler, ekleme sırasına göre yinelenir. Bu, :func:`zip`: ``pairs "
"= zip(d.values(), d.keys())`` kullanılarak ''(değer, anahtar)`` çiftlerinin "
"oluşturulmasına izin verir. Aynı listeyi oluşturmanın başka bir yolu da "
"\"çiftler = [(v, k) for (k, v) in d.items()]\" şeklindedir."

#: library/stdtypes.rst:4728
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise a :"
"exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Sözlüğe girdi eklerken veya silerken görünümleri yinelemek, bir :exc:"
"`RuntimeError` oluşmasına neden olabilir veya tüm girdileri yinelemede başarısız "
"olabilir."

#: library/stdtypes.rst:4731
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "Sözlük siparişinin kampanya siparişi olması garanti edilir."

#: library/stdtypes.rst:4736
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or items "
"(in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"*x* temel alınan sözlüğün anahtarlarında, değerlerinde veya öğelerindeyse "
"``True'' döndürün (ikinci durumda, *x* bir ``(key, value)`` demet olmalıdır)."

#: library/stdtypes.rst:4741
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. The "
"view will be iterated in reverse order of the insertion."
msgstr ""
"Sözlüğün anahtarları, değerleri veya öğeleri üzerinde bir ters yineleyici "
"döndürün. Görünüm, eklemenin tersi sırayla yinelenir."

#: library/stdtypes.rst:4744
msgid "Dictionary views are now reversible."
msgstr "Sözlük görünümleri artık tersine çevrilebilir."

#: library/stdtypes.rst:4749
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary to "
"which the view refers."
msgstr ""
"Görünümün başvurduğu orijinal sözlüğü saran bir :class:`types.MappingProxyType` "
"döndürür."

#: library/stdtypes.rst:4754
msgid ""
"Keys views are set-like since their entries are unique and :term:`hashable`.  If "
"all values are hashable, so that ``(key, value)`` pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-like "
"since the entries are generally not unique.)  For set-like views, all of the "
"operations defined for the abstract base class :class:`collections.abc.Set` are "
"available (for example, ``==``, ``<``, or ``^``).  While using set operators, "
"set-like views accept any iterable as the other operand, unlike sets which only "
"accept sets as the input."
msgstr ""
"Anahtar görünümleri, girişleri benzersiz olduğundan ve :term:`hashable` "
"olduğundan set benzeridir. Tüm değerler karıştırılabilirse, yani ``(anahtar, "
"değer)`` çiftleri benzersiz ve karıştırılabilirse, o zaman öğeler görünümü de "
"küme benzeri olur. (Değer görünümleri, girişler genellikle benzersiz "
"olmadığından küme benzeri olarak değerlendirilmez.) Küme benzeri görünümler "
"için, soyut temel sınıf :class:`collections.abc.Set` için tanımlanan tüm "
"işlemler mevcuttur (örneğin, , ``==``, ``<`` veya ``^``). Küme işleçlerini "
"kullanırken, küme benzeri görünümler, yalnızca kümeleri girdi olarak kabul eden "
"kümelerin aksine, yinelenebilir herhangi bir öğeyi diğer işlenen olarak kabul "
"eder."

#: library/stdtypes.rst:4763
msgid "An example of dictionary view usage::"
msgstr "Sözlük görünümü kullanımına bir örnek::"

#: library/stdtypes.rst:4807
msgid "Context Manager Types"
msgstr "Bağlam Yöneticisi Türleri"

#: library/stdtypes.rst:4814
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods that "
"allow user-defined classes to define a runtime context that is entered before "
"the statement body is executed and exited when the statement ends:"
msgstr ""
"Python'un :keyword:`with` deyimi, bir bağlam yöneticisi tarafından tanımlanan "
"çalışma zamanı bağlamı kavramını destekler.  Bu, kullanıcı tanımlı sınıfların "
"deyim gövdesi yürütülmeden önce girilen ve deyim sona erdiğinde çıkılan bir "
"çalışma zamanı bağlamı tanımlamasına olanak tanıyan bir çift yöntem kullanılarak "
"uygulanır:"

#: library/stdtypes.rst:4822
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound to "
"the identifier in the :keyword:`!as` clause of :keyword:`with` statements using "
"this context manager."
msgstr ""
"Çalışma zamanı bağlamını girin ve ya bu nesneyi ya da çalışma zamanı bağlamıyla "
"ilgili başka bir nesneyi döndürün. Bu yöntem tarafından döndürülen değer, bu "
"bağlam yöneticisini kullanan :keyword:`with` deyimlerinin :keyword:`!as` "
"cümlesindeki tanımlayıcıya bağlanır."

#: library/stdtypes.rst:4827
msgid ""
"An example of a context manager that returns itself is a :term:`file object`. "
"File objects return themselves from __enter__() to allow :func:`open` to be used "
"as the context expression in a :keyword:`with` statement."
msgstr ""
"Kendisini döndüren bir bağlam yöneticisine örnek olarak :term:`file nesnesi` "
"verilebilir. Dosya nesneleri, :func:`open` ifadesinin bir :keyword:`with` "
"ifadesinde bağlam ifadesi olarak kullanılmasına izin vermek için __enter__() "
"işlevinden kendilerini döndürürler."

#: library/stdtypes.rst:4831
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active decimal "
"context to a copy of the original decimal context and then return the copy. This "
"allows changes to be made to the current decimal context in the body of the :"
"keyword:`with` statement without affecting code outside the :keyword:`!with` "
"statement."
msgstr ""
"İlgili bir nesne döndüren bir bağlam yöneticisi örneği :func:`decimal."
"localcontext` tarafından döndürülendir. Bu yöneticiler etkin ondalık bağlamı "
"orijinal ondalık bağlamın bir kopyasına ayarlar ve ardından kopyayı döndürür. "
"Bu, :keyword:`with` deyiminin gövdesinde, :keyword:`!with` deyiminin dışındaki "
"kodu etkilemeden geçerli ondalık bağlamda değişiklik yapılmasına olanak tanır."

#: library/stdtypes.rst:4841
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any exception "
"that occurred should be suppressed. If an exception occurred while executing the "
"body of the :keyword:`with` statement, the arguments contain the exception type, "
"value and traceback information. Otherwise, all three arguments are ``None``."
msgstr ""
"Çalışma zamanı bağlamından çıkın ve meydana gelen herhangi bir istisnanın "
"bastırılması gerekip gerekmediğini belirten bir Boole bayrağı döndürün. :keyword:"
"`with` ifadesinin gövdesi yürütülürken bir istisna meydana gelirse, argümanlar "
"istisna tipini, değeri ve geri izleme bilgilerini içerir. Aksi takdirde, üç "
"bağımsız değişken de ``Yok`` olur."

#: library/stdtypes.rst:4846
msgid ""
"Returning a true value from this method will cause the :keyword:`with` statement "
"to suppress the exception and continue execution with the statement immediately "
"following the :keyword:`!with` statement. Otherwise the exception continues "
"propagating after this method has finished executing. Exceptions that occur "
"during execution of this method will replace any exception that occurred in the "
"body of the :keyword:`!with` statement."
msgstr ""
"Bu yöntemden gerçek bir değer döndürmek, :keyword:`with` deyiminin istisnayı "
"bastırmasına ve :keyword:`!with` deyiminin hemen ardından gelen deyimle "
"yürütmeye devam etmesine neden olur. Aksi takdirde, bu yöntemin yürütülmesi "
"tamamlandıktan sonra istisna yayılmaya devam eder. Bu yöntemin yürütülmesi "
"sırasında ortaya çıkan istisnalar, :keyword:`!with` ifadesinin gövdesinde "
"meydana gelen herhangi bir istisnanın yerini alacaktır."

#: library/stdtypes.rst:4853
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`__exit__` "
"method has actually failed."
msgstr ""
"Geçirilen istisna asla açıkça yeniden yükseltilmemelidir - bunun yerine, bu "
"yöntem, yöntemin başarıyla tamamlandığını ve ortaya çıkan istisnayı bastırmak "
"istemediğini belirtmek için yanlış bir değer döndürmelidir. Bu, bağlam yönetimi "
"kodunun bir :meth:`__exit__` yönteminin gerçekten başarısız olup olmadığını "
"kolayca algılamasını sağlar."

#: library/stdtypes.rst:4859
msgid ""
"Python defines several context managers to support easy thread synchronisation, "
"prompt closure of files or other objects, and simpler manipulation of the active "
"decimal arithmetic context. The specific types are not treated specially beyond "
"their implementation of the context management protocol. See the :mod:"
"`contextlib` module for some examples."
msgstr ""
"Python, kolay iş parçacığı senkronizasyonunu, dosyaların veya diğer nesnelerin "
"hızlı kapatılmasını ve etkin ondalık aritmetik bağlamın daha basit şekilde "
"değiştirilmesini desteklemek için çeşitli bağlam yöneticileri tanımlar. Belirli "
"türler, bağlam yönetimi protokolünün uygulanmasının ötesinde özel olarak ele "
"alınmaz. Bazı örnekler için :mod:`contextlib` modülüne bakın."

#: library/stdtypes.rst:4865
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a generator "
"function is decorated with the :class:`contextlib.contextmanager` decorator, it "
"will return a context manager implementing the necessary :meth:`~contextmanager."
"__enter__` and :meth:`~contextmanager.__exit__` methods, rather than the "
"iterator produced by an undecorated generator function."
msgstr ""
"Python'un :term:`generator`\\s ve :class:`contextlib.contextmanager` dekoratörü, "
"bu protokolleri uygulamak için uygun bir yol sağlar. Bir oluşturucu işlevi :"
"class:`contextlib.contextmanager` dekoratörü ile dekore edilmişse, gerekli :meth:"
"`~contextmanager.__enter__` ve :meth:`~contextmanager.__exit__` yöntemlerini "
"yerine uygulayan bir bağlam yöneticisi döndürür. süslenmemiş bir oluşturucu "
"işlevi tarafından üretilen yineleyici."

#: library/stdtypes.rst:4872
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of a "
"single class dictionary lookup is negligible."
msgstr ""
"Python/C API'sindeki Python nesnelerinin tür yapısında bu yöntemlerden herhangi "
"biri için belirli bir yuva bulunmadığına dikkat edin. Bu yöntemleri tanımlamak "
"isteyen uzantı türleri, onları normal bir Python erişilebilir yöntemi olarak "
"sağlamalıdır. Çalışma zamanı bağlamını ayarlama ek yüküyle karşılaştırıldığında, "
"tek bir sınıf sözlüğü aramasının ek yükü ihmal edilebilir düzeydedir."

#: library/stdtypes.rst:4880
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:`Union "
"<types-union>`"
msgstr ""
"Tür Ek Açıklama Türleri --- :ref:`Genel Diğer Ad <türler-genericalias>`, :ref:"
"`Union <türler-birliği>`"

#: library/stdtypes.rst:4885
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
":term:`tür açıklamaları <annotation>` için temel yerleşik tipler :ref:`Generic "
"Alias ​​<types-genericalias>` ve :ref:`Union <types-union>`dır."

#: library/stdtypes.rst:4892
msgid "Generic Alias Type"
msgstr "Genel Takma Ad Türü"

#: library/stdtypes.rst:4898
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container classes "
"<sequence-types>`, such as :class:`list` or :class:`dict`. For example, "
"``list[int]`` is a ``GenericAlias`` object created by subscripting the ``list`` "
"class with the argument :class:`int`. ``GenericAlias`` objects are intended "
"primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"``GenericAlias`` nesneleri genellikle :ref:`bir sınıfa abone olarak "
"<subscriptions>` tarafından oluşturulur. Genellikle :ref:`container classs "
"<sequence-types>` ile birlikte kullanılırlar, örneğin :class:`list` veya :class:"
"`dict`. Örneğin, \"list[int]\", \"list\" sınıfına :class:\"int\" argümanıyla "
"abone olunarak oluşturulan bir \"GenericAlias\" nesnesidir. ``GenericAlias`` "
"nesnelerinin birincil olarak :term:`tür açıklamaları <annotation>` ile "
"kullanılması amaçlanmıştır."

#: library/stdtypes.rst:4908
msgid ""
"It is generally only possible to subscript a class if the class implements the "
"special method :meth:`~object.__class_getitem__`."
msgstr ""
"Bir sınıfa abone olmak genellikle yalnızca, sınıf :meth:`~object."
"__class_getitem__` özel yöntemini uygularsa mümkündür."

#: library/stdtypes.rst:4911
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr ""
"Bir ``GenericAlias`` nesnesi, :term:`generic type` için bir vekil olarak hareket "
"eder ve *parameterized generics* uygular."

#: library/stdtypes.rst:4914
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an object "
"contains. For example, ``set[bytes]`` can be used in type annotations to signify "
"a :class:`set` in which all the elements are of type :class:`bytes`."
msgstr ""
"Bir taşıyıcı sınıf için, sınıfın bir :ref:`subscription <subscriptions>` öğesine "
"sağlanan argüman(lar), bir nesnenin içerdiği öğelerin tip(ler)ini gösterebilir. "
"Örneğin, \"set[bytes]\", tür ek açıklamalarında, içindeki tüm öğelerin :class:"
"\"bytes\" türünde olduğu bir :class:\"set\"i belirtmek için kullanılabilir."

#: library/stdtypes.rst:4920
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will often "
"indicate the return type(s) of one or more methods defined on an object. For "
"example, :mod:`regular expressions <re>` can be used on both the :class:`str` "
"data type and the :class:`bytes` data type:"
msgstr ""
":meth:`~object.__class_getitem__` tanımlayan ancak kapsayıcı olmayan bir sınıf "
"için, sınıfın aboneliğine sağlanan bağımsız değişken(ler) genellikle bir nesne "
"üzerinde tanımlanan bir veya daha fazla yöntemin dönüş tipini/türlerini "
"gösterir. . Örneğin, :mod:`normal ifadeler <re>` hem :class:`str` veri tipinde "
"hem de :class:`bytes` veri tipinde kullanılabilir:"

#: library/stdtypes.rst:4926
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"``x = re.search('foo', 'foo')`` ise, `x` bir :ref:`re.Match <match-objects>` "
"nesnesi olacaktır; burada ``x'in dönüş değerleri .group(0)`` ve ``x[0]`` her "
"ikisi de :class:`str` türünde olacaktır. Bu tür nesneleri tip ek açıklamalarında "
"``GenericAlias`` ``re.Match[str]`` ile temsil edebiliriz."

#: library/stdtypes.rst:4932
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), ``y`` "
"will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-objects>` "
"objects with ``re.Match[bytes]``."
msgstr ""
"``y = re.search(b'bar', b'bar')`` ise ( :class:`bytes` için ''b``ye dikkat "
"edin), ``y`` aynı zamanda \"re.Match\", ancak \"y.group(0)\" ve \"y[0]\" dönüş "
"değerlerinin her ikisi de :class:\"bytes\" türünde olacaktır. Tip ek "
"açıklamalarında, bu çeşitli :ref:`re.Match <match-objects>` nesneleri ``re."
"Match[bytes]`` ile temsil ederiz."

#: library/stdtypes.rst:4938
msgid ""
"``GenericAlias`` objects are instances of the class :class:`types.GenericAlias`, "
"which can also be used to create ``GenericAlias`` objects directly."
msgstr ""
"``GenericAlias`` nesneleri, doğrudan ``GenericAlias`` nesneleri oluşturmak için "
"de kullanılabilen :class:`types.GenericAlias` sınıfının örnekleridir."

#: library/stdtypes.rst:4944
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types *X*, "
"*Y*, and more depending on the ``T`` used. For example, a function expecting a :"
"class:`list` containing :class:`float` elements::"
msgstr ""
"Kullanılan ``T`` türüne bağlı olarak *X*, *Y* ve daha fazla tür tarafından "
"parametrelenen bir ``T`` türünü temsil eden bir ``GenericAlias`` oluşturur. "
"Örneğin, :class:`float` elemanları içeren bir :class:`list` bekleyen bir "
"fonksiyon::"

#: library/stdtypes.rst:4952
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is a "
"generic type expecting two type parameters representing the key type and the "
"value type.  In this example, the function expects a ``dict`` with keys of type :"
"class:`str` and values of type :class:`int`::"
msgstr ""
"Anahtar türünü ve değer türünü temsil eden iki tür parametresi bekleyen genel "
"bir tür olan :class:`dict` kullanarak :term:`mapping` nesneleri için başka bir "
"örnek.  Bu örnekte, fonksiyon :class:`str` türünde anahtarları ve :class:`int` "
"türünde değerleri olan bir ``dict`` bekler::"

#: library/stdtypes.rst:4960
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not accept "
"``GenericAlias`` types for their second argument::"
msgstr ""
"Yerleşik :func:`isinstance` ve :func:`issubclass` işlevleri ikinci argümanları "
"için ``GenericAlias`` türlerini kabul etmez::"

#: library/stdtypes.rst:4968
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. This "
"extends to generic types and their type parameters. When creating a container "
"object from a ``GenericAlias``, the elements in the container are not checked "
"against their type. For example, the following code is discouraged, but will run "
"without errors::"
msgstr ""
"Python çalışma zamanı :term:`tip anotasyonları <annotation>` 'nı zorlamaz. Bu, "
"genel türleri ve bunların tür parametrelerini de kapsar. Bir ``GenericAlias`` "
"türünden bir konteyner nesnesi oluştururken, konteynerdeki elemanlar türlerine "
"göre kontrol edilmez. Örneğin, aşağıdaki kod tavsiye edilmez, ancak hatasız "
"çalışacaktır::"

#: library/stdtypes.rst:4978
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr ""
"Ayrıca, parametrelendirilmiş jenerikler nesne oluşturma sırasında tip "
"parametrelerini siler::"

#: library/stdtypes.rst:4989
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized type::"
msgstr ""
"Bir jenerik üzerinde :func:`repr` veya :func:`str` çağrısı parametrelendirilmiş "
"türü gösterir::"

#: library/stdtypes.rst:4997
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"Genel kapsayıcıların :meth:`~object.__getitem__` metodu, ``dict[str][str]`` gibi "
"hatalara izin vermemek için bir istisna oluşturacaktır::"

#: library/stdtypes.rst:5005
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` are "
"used.  The index must have as many elements as there are type variable items in "
"the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"Ancak, bu tür ifadeler :ref:`type variables <generics>` kullanıldığında "
"geçerlidir.  Dizin, ``GenericAlias`` nesnesinin :attr:`~genericalias.__args__` "
"öğesindeki tür değişkeni öğeleri kadar öğeye sahip olmalıdır::"

#: library/stdtypes.rst:5016
msgid "Standard Generic Classes"
msgstr "Standart Jenerik Sınıflar"

#: library/stdtypes.rst:5018
msgid ""
"The following standard library classes support parameterized generics. This list "
"is non-exhaustive."
msgstr ""
"Bu standart kütüphane sınıfları parametrelendirilmiş jenerikleri destekler. Bu "
"liste kapsamlı değildir."

#: library/stdtypes.rst:5021
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: library/stdtypes.rst:5022
msgid ":class:`list`"
msgstr ":class:`list`"

#: library/stdtypes.rst:5023
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: library/stdtypes.rst:5024
msgid ":class:`set`"
msgstr ":class:`set`"

#: library/stdtypes.rst:5025
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: library/stdtypes.rst:5026
msgid ":class:`type`"
msgstr ":class:`type`"

#: library/stdtypes.rst:5027
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: library/stdtypes.rst:5028
msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

#: library/stdtypes.rst:5029
msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

#: library/stdtypes.rst:5030
msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

#: library/stdtypes.rst:5031
msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

#: library/stdtypes.rst:5032
msgid ":class:`collections.abc.Awaitable`"
msgstr ":class:`collections.abc.Awaitable`"

#: library/stdtypes.rst:5033
msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

#: library/stdtypes.rst:5034
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: library/stdtypes.rst:5035
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterator`"

#: library/stdtypes.rst:5036
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

#: library/stdtypes.rst:5037
msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

#: library/stdtypes.rst:5038
msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

#: library/stdtypes.rst:5039
msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

#: library/stdtypes.rst:5040
msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

#: library/stdtypes.rst:5041
msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

#: library/stdtypes.rst:5042
msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

#: library/stdtypes.rst:5043
msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

#: library/stdtypes.rst:5044
msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

#: library/stdtypes.rst:5045
msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

#: library/stdtypes.rst:5046
msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

#: library/stdtypes.rst:5047
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

#: library/stdtypes.rst:5048
msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

#: library/stdtypes.rst:5049
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

#: library/stdtypes.rst:5050
msgid ":class:`collections.abc.ByteString`"
msgstr ":class:`collections.abc.ByteString`"

#: library/stdtypes.rst:5051
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

#: library/stdtypes.rst:5052
msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

#: library/stdtypes.rst:5053
msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

#: library/stdtypes.rst:5054
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

#: library/stdtypes.rst:5055
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

#: library/stdtypes.rst:5056
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

#: library/stdtypes.rst:5057
msgid ":class:`dataclasses.Field`"
msgstr ":class:`dataclasses.Field`"

#: library/stdtypes.rst:5058
msgid ":class:`functools.cached_property`"
msgstr ":class:`functools.cached_property`"

#: library/stdtypes.rst:5059
msgid ":class:`functools.partialmethod`"
msgstr ":class:`functools.partialmethod`"

#: library/stdtypes.rst:5060
msgid ":class:`os.PathLike`"
msgstr ":class:`os.PathLike`"

#: library/stdtypes.rst:5061
msgid ":class:`queue.LifoQueue`"
msgstr ":class:`queue.LifoQueue`"

#: library/stdtypes.rst:5062
msgid ":class:`queue.Queue`"
msgstr ":class:`queue.Queue`"

#: library/stdtypes.rst:5063
msgid ":class:`queue.PriorityQueue`"
msgstr ":class:`queue.PriorityQueue`"

#: library/stdtypes.rst:5064
msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`tuple`"

#: library/stdtypes.rst:5065
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Pattern <re-objects>`"

#: library/stdtypes.rst:5066
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: library/stdtypes.rst:5067
msgid ":class:`shelve.BsdDbShelf`"
msgstr ":class:`shelve.BsdDbShelf`"

#: library/stdtypes.rst:5068
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":class:`shelve.DbfilenameShelf`"

#: library/stdtypes.rst:5069
msgid ":class:`shelve.Shelf`"
msgstr ":class:`shelve.Shelf`"

#: library/stdtypes.rst:5070
msgid ":class:`types.MappingProxyType`"
msgstr ":class:`types.MappingProxyType`"

#: library/stdtypes.rst:5071
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":class:`weakref.WeakKeyDictionary`"

#: library/stdtypes.rst:5072
msgid ":class:`weakref.WeakMethod`"
msgstr ":class:`weakref.WeakMethod`"

#: library/stdtypes.rst:5073
msgid ":class:`weakref.WeakSet`"
msgstr ":class:`weakref.WeakSet`"

#: library/stdtypes.rst:5074
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":class:`weakref.WeakValueDictionary`"

#: library/stdtypes.rst:5079
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "``GenericAlias`` objesinin Özel Öznitelikleri"

#: library/stdtypes.rst:5081
msgid "All parameterized generics implement special read-only attributes."
msgstr "Tüm parametreli jenerikler özel salt okunur öznitelikler uygular."

#: library/stdtypes.rst:5085
msgid "This attribute points at the non-parameterized generic class::"
msgstr "Bu öznitelik, parametrelendirilmemiş genel sınıfa işaret eder::"

#: library/stdtypes.rst:5093
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic class::"
msgstr ""
"Bu öznitelik, jenerik sınıfın orijinal :meth:`~object.__class_getitem__` öğesine "
"iletilen jenerik tiplerinden bir :class:`tuple` 'dır (muhtemelen 1 uzunluğunda)::"

#: library/stdtypes.rst:5103
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr ""
"Bu öznitelik, ''__args__'' içinde bulunan benzersiz tür değişkenlerin tembel bir "
"şekilde hesaplanmış bir demetidir (muhtemelen boş):"

#: library/stdtypes.rst:5114
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not have "
"correct ``__parameters__`` after substitution because :class:`typing.ParamSpec` "
"is intended primarily for static type checking."
msgstr ""
"``GenericAlias`` nesnesi ile :class:`typing.ParamSpec` parametreleri "
"değiştirildikten sonra doğru ``__parameters__`` olmayabilir çünkü :class:`typing."
"ParamSpec` öncelikle statik tip kontrolü için tasarlanmıştır."

#: library/stdtypes.rst:5121
msgid ""
"A boolean that is true if the alias has been unpacked using the ``*`` operator "
"(see :data:`~typing.TypeVarTuple`)."
msgstr ""
"Takma ad ``*`` işleci kullanılarak açıldıysa doğru olan bir boolean (bkz. :data:"
"`~typing.TypeVarTuple`)."

#: library/stdtypes.rst:5130
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Tip İpuçları"

#: library/stdtypes.rst:5130
msgid "Introducing Python's framework for type annotations."
msgstr "Tip ek açıklamaları için Python çerçevesiyle tanışın."

#: library/stdtypes.rst:5135
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ""
":pep:`585` - Standart Koleksiyonlarda Tip İma Etme (Type Hinting) Jenerikleri"

#: library/stdtypes.rst:5133
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr ""
":meth:`~object.__class_getitem__` özel sınıf yöntemini uygulamaları koşuluyla, "
"standart kitaplık sınıflarını yerel olarak parametreleştirme yeteneğiyle tanışın."

#: library/stdtypes.rst:5138
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :class:"
"`typing.Generic`"
msgstr ""
":ref:`Jenerics`, :ref:`kullanıcı tanımlı jenerikler <user-defined-generics>` ve :"
"class:`typing.Generic`"

#: library/stdtypes.rst:5138
msgid ""
"Documentation on how to implement generic classes that can be parameterized at "
"runtime and understood by static type-checkers."
msgstr ""
"Çalışma zamanında parametrelendirilebilen ve statik tür denetleyiciler "
"tarafından anlaşılabilen genel sınıfların nasıl uygulanacağına ilişkin belgeler."

#: library/stdtypes.rst:5147
msgid "Union Type"
msgstr "Sendika Türü"

#: library/stdtypes.rst:5153
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on multiple :"
"ref:`type objects <bltin-type-objects>`.  These types are intended primarily "
"for :term:`type annotations <annotation>`. The union type expression enables "
"cleaner type hinting syntax compared to :data:`typing.Union`."
msgstr ""
"Bir birleşim nesnesi, birden çok :ref:`type objects <bltin-type-objects>` "
"üzerinde ``|`` (bitsel veya) işleminin değerini tutar. Bu türler öncelikle "
"aşağıdakiler için tasarlanmıştır :term:`type annotations <annotation>`. Birleşim "
"türü ifadesi, aşağıdakilere kıyasla daha temiz tür ipucu sözdizimi sağlar :data:"
"`typing.Union`."

#: library/stdtypes.rst:5160
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` means "
"either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For example, the "
"following function expects an argument of type :class:`int` or :class:`float`::"
msgstr ""
"*X*, *Y* vb. türleri tutan bir birleşim nesnesi tanımlar. ``X | Y`` X veya Y "
"anlamına gelir.  Bu, ``typing.Union[X, Y]`` ile eş değerdir. Örneğin, aşağıdaki "
"işlev :class:`int` veya :class:`float`::"

#: library/stdtypes.rst:5170
msgid ""
"The ``|`` operand cannot be used at runtime to define unions where one or more "
"members is a forward reference. For example, ``int | \"Foo\"``, where "
"``\"Foo\"`` is a reference to a class not yet defined, will fail at runtime. For "
"unions which include forward references, present the whole expression as a "
"string, e.g. ``\"int | Foo\"``."
msgstr ""
"``|`` işleneni çalışma zamanında bir veya daha fazla üyenin ileri başvuru olduğu "
"birleşimleri tanımlamak için kullanılamaz. Örneğin, ``int | Henüz tanımlanmamış "
"bir sınıfa referans olan \"Foo\"``, burada ``\"Foo\"`` çalışma zamanında "
"başarısız olur. İleriye doğru referanslar içeren birleşimler için ifadenin "
"tamamını bir dize olarak sunun; ``\"int | Foo\"``."

#: library/stdtypes.rst:5178
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr ""
"Birlik nesneleri, diğer birlik nesneleriyle eşitlik açısından test edilebilir.  "
"Detaylar:"

#: library/stdtypes.rst:5180
msgid "Unions of unions are flattened::"
msgstr "Birliklerin birlikleri düzleştirimiştir::"

#: library/stdtypes.rst:5184
msgid "Redundant types are removed::"
msgstr "Gereksiz türler kaldırılır::"

#: library/stdtypes.rst:5188
msgid "When comparing unions, the order is ignored::"
msgstr "Birlikleri karşılaştırırken, sipariş göz ardı edilir::"

#: library/stdtypes.rst:5192
msgid "It is compatible with :data:`typing.Union`::"
msgstr ":data:`typing.Union`:: ile uyumludur:"

#: library/stdtypes.rst:5196
msgid "Optional types can be spelled as a union with ``None``::"
msgstr "İsteğe bağlı türler ``None``:: ile bir birlik olarak yazılabilir:"

#: library/stdtypes.rst:5203
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr ""
":func:`isinstance` ve :func:`issubclass` çağrıları da bir birlik nesnesiyle "
"desteklenir::"

#: library/stdtypes.rst:5209
msgid ""
"However, :ref:`parameterized generics <types-genericalias>` in union objects "
"cannot be checked::"
msgstr ""
"-Ancak, birleşim nesnelerindeki :ref:`parametreli jenerikler <types-"
"genericalias>` kontrol edilemez::"

#: library/stdtypes.rst:5219
msgid ""
"The user-exposed type for the union object can be accessed from :data:`types."
"UnionType` and used for :func:`isinstance` checks.  An object cannot be "
"instantiated from the type::"
msgstr ""
"Union nesnesinin kullanıcıya açık türüne :data:`types.UnionType` adresinden "
"erişilebilir ve :func:`isinstance` kontrolleri için kullanılabilir.  Bir nesne "
"şu türden örneklenemez::"

#: library/stdtypes.rst:5232
msgid ""
"The :meth:`__or__` method for type objects was added to support the syntax ``X | "
"Y``.  If a metaclass implements :meth:`__or__`, the Union may override it::"
msgstr ""
"Tür nesneleri için :meth:`__or__` yöntemi, ``X | Y`` sözdizimini desteklemek "
"için eklendi.  Eğer bir metaclass :meth:`__or__` metodunu uygularsa, Union bunu "
"geçersiz kılabilir::"

#: library/stdtypes.rst:5250
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` -- ``X | Y`` sözdizimini ve Birlik türünü öneren PEP."

#: library/stdtypes.rst:5258
msgid "Other Built-in Types"
msgstr "Diğer Yerleşik Tipler"

#: library/stdtypes.rst:5260
msgid ""
"The interpreter supports several other kinds of objects. Most of these support "
"only one or two operations."
msgstr ""
"Yorumlayıcı başka nesne türlerini de destekler. Bunların çoğu yalnızca bir veya "
"iki işlemi destekler."

#: library/stdtypes.rst:5267
msgid "Modules"
msgstr "Modüller"

#: library/stdtypes.rst:5269
msgid ""
"The only special operation on a module is attribute access: ``m.name``, where "
"*m* is a module and *name* accesses a name defined in *m*'s symbol table. Module "
"attributes can be assigned to.  (Note that the :keyword:`import` statement is "
"not, strictly speaking, an operation on a module object; ``import foo`` does not "
"require a module object named *foo* to exist, rather it requires an (external) "
"*definition* for a module named *foo* somewhere.)"
msgstr ""
"Bir modül üzerindeki tek özel işlem öznitelik erişimidir: ``m.name``, burada *m* "
"bir modüldür ve *name*, *m*'nin sembol tablosunda tanımlanan bir isme erişir. "
"Modül nitelikleri atanabilir.  (:keyword:`import` deyiminin kesinlikle bir modül "
"nesnesi üzerinde bir işlem olmadığına dikkat edin; ``import foo`` *foo* adında "
"bir modül nesnesinin var olmasını gerektirmez, bunun yerine bir yerlerde *foo* "
"adında bir modül için (harici) bir *tanımlama* gerektirir)"

#: library/stdtypes.rst:5276
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary will "
"actually change the module's symbol table, but direct assignment to the :attr:"
"`~object.__dict__` attribute is not possible (you can write ``m.__dict__['a'] = "
"1``, which defines ``m.a`` to be ``1``, but you can't write ``m.__dict__ = {}"
"``).  Modifying :attr:`~object.__dict__` directly is not recommended."
msgstr ""
"Her modülün özel bir niteliği :attr:`~object.__dict__` 'dir. Bu, modülün sembol "
"tablosunu içeren sözlüktür. Bu sözlüğü değiştirmek aslında modülün sembol "
"tablosunu değiştirecektir, ancak :attr:`~object.__dict__` niteliğine doğrudan "
"atama yapmak mümkün değildir (``m.__dict__['a'] = 1`` yazabilirsiniz, bu ``m.a`` "
"yı ``1`` olarak tanımlar, ancak ``m.__dict__ = {}`` yazamazsınız).  :attr:"
"`~object.__dict__` öğesinin doğrudan değiştirilmesi önerilmez."

#: library/stdtypes.rst:5284
msgid ""
"Modules built into the interpreter are written like this: ``<module 'sys' (built-"
"in)>``.  If loaded from a file, they are written as ``<module 'os' from '/usr/"
"local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Yorumlayıcıda yerleşik olarak bulunan modüller şu şekilde yazılır: ``<module "
"'sys' (built-in)>``.  Eğer bir dosyadan yüklenmişlerse, ``<module 'os' from '/"
"usr/local/lib/pythonX.Y/os.pyc'>`` şeklinde yazılırlar."

#: library/stdtypes.rst:5292
msgid "Classes and Class Instances"
msgstr "Sınıflar ve Sınıf Örnekleri"

#: library/stdtypes.rst:5294
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Bunlar için :ref:`class` ve :ref:`objects`  bakın."

#: library/stdtypes.rst:5300
msgid "Functions"
msgstr "Fonksiyonlar"

#: library/stdtypes.rst:5302
msgid ""
"Function objects are created by function definitions.  The only operation on a "
"function object is to call it: ``func(argument-list)``."
msgstr ""
"Fonksiyon nesneleri fonksiyon tanımları tarafından oluşturulur.  Bir fonksiyon "
"nesnesi üzerindeki tek işlem onu çağırmaktır: ``func(argument-list)``."

#: library/stdtypes.rst:5305
msgid ""
"There are really two flavors of function objects: built-in functions and user-"
"defined functions.  Both support the same operation (to call the function), but "
"the implementation is different, hence the different object types."
msgstr ""
"Fonksiyon nesnelerinin gerçekten iki çeşidi vardır: yerleşik fonksiyonlar ve "
"kullanıcı tanımlı fonksiyonlar.  Her ikisi de aynı işlemi destekler (işlevi "
"çağırmak için), ancak uygulama farklıdır, dolayısıyla farklı nesne türleri "
"vardır."

#: library/stdtypes.rst:5309
msgid "See :ref:`function` for more information."
msgstr "Daha fazla bilgi için :ref:`function` bölümüne bakınız."

#: library/stdtypes.rst:5315
msgid "Methods"
msgstr "Yöntemler"

#: library/stdtypes.rst:5319
msgid ""
"Methods are functions that are called using the attribute notation. There are "
"two flavors: built-in methods (such as :meth:`append` on lists) and class "
"instance methods.  Built-in methods are described with the types that support "
"them."
msgstr ""
"Yöntemler, nitelik gösterimi kullanılarak çağrılan işlevlerdir. İki çeşidi "
"vardır: yerleşik yöntemler (listelerde :meth:`append` gibi) ve sınıf örneği "
"yöntemleri.  Yerleşik yöntemler, onları destekleyen türlerle birlikte tanımlanır."

#: library/stdtypes.rst:5324
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to the "
"argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is the "
"function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-n)`` is "
"completely equivalent to calling ``m.__func__(m.__self__, arg-1, arg-2, ..., arg-"
"n)``."
msgstr ""
"Bir yönteme (bir sınıf ad alanında tanımlanmış bir fonksiyon) bir örnek "
"üzerinden erişirseniz, özel bir nesne elde edersiniz: bir :dfn:`bound method` "
"(ayrıca :dfn:`instance method` olarak da adlandırılır) nesnesi. Çağrıldığında, "
"``self`` argümanını argüman listesine ekleyecektir.  Bağlı metotların iki özel "
"salt okunur niteliği vardır: ``m.__self__`` metodun üzerinde çalıştığı nesne ve "
"``m.__func__`` metodu uygulayan fonksiyondur.  ``m(arg-1, arg-2, ..., arg-n)`` "
"çağrısı tamamen ``m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)`` çağrısına "
"eş değerdir."

#: library/stdtypes.rst:5333
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method results "
"in an :exc:`AttributeError` being raised.  In order to set a method attribute, "
"you need to explicitly set it on the underlying function object::"
msgstr ""
"Fonksiyon nesneleri gibi, bağlı metot nesneleri de keyfi nitelikler almayı "
"destekler.  Ancak, yöntem nitelikleri aslında temel işlev nesnesinde (``meth."
"__func__``) saklandığından, bağlı yöntemlerde yöntem niteliklerinin "
"ayarlanmasına izin verilmez.  Bir yöntem üzerinde bir öznitelik ayarlamaya "
"çalışmak :exc:`AttributeError` ile sonuçlanır.  Bir yöntem özniteliğini "
"ayarlamak için, bunu temel işlev nesnesi üzerinde açıkça ayarlamanız gerekir::"

#: library/stdtypes.rst:5384
msgid "See :ref:`types` for more information."
msgstr "Daha fazla bilgi için :ref:`types` sayfasına bakın."

#: library/stdtypes.rst:5361
msgid "Code Objects"
msgstr "Kod Nesneleri"

#: library/stdtypes.rst:5367
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` function "
"and can be extracted from function objects through their :attr:`__code__` "
"attribute. See also the :mod:`code` module."
msgstr ""
"Kod nesneleri, uygulama tarafından bir fonksiyon gövdesi gibi \"sözde "
"derlenmiş\" çalıştırılabilir Python kodunu temsil etmek için kullanılır. "
"Fonksiyon nesnelerinden farklıdırlar çünkü global yürütme ortamlarına bir "
"referans içermezler.  Kod nesneleri yerleşik :func:`compile` işlevi tarafından "
"döndürülür ve  :attr:`__code__` niteliği aracılığıyla işlev nesnelerinden "
"çıkarılabilir. Ayrıca :mod:`code` modülüne de bakınız."

#: library/stdtypes.rst:5374
msgid ""
"Accessing ``__code__`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"__code__\"``."
msgstr ""
"``__code__`` 'e erişmek,``obj`` ve ``\"__code__\"`` argümanlarıyla :ref:`denetim "
"etkinliği <auditing>` ``object.__getattr__`` oluşturur."

#: library/stdtypes.rst:5381
msgid ""
"A code object can be executed or evaluated by passing it (instead of a source "
"string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Bir kod nesnesi (kaynak dize yerine) :func:`exec` veya :func:`eval` yerleşik "
"işlevlerine geçirilerek yürütülebilir veya değerlendirilebilir."

#: library/stdtypes.rst:5390
msgid "Type Objects"
msgstr "Type Objects"

#: library/stdtypes.rst:5396
msgid ""
"Type objects represent the various object types.  An object's type is accessed "
"by the built-in function :func:`type`.  There are no special operations on "
"types.  The standard module :mod:`types` defines names for all standard built-in "
"types."
msgstr ""
"Type nesneleri çeşitli nesne türlerini temsil eder.  Bir nesnenin türüne "
"yerleşik işlev :func:`type` tarafından erişilir.  Türler üzerinde özel bir işlem "
"yoktur.  Standart modül :mod:`types` tüm standart yerleşik türler için isimleri "
"tanımlar."

#: library/stdtypes.rst:5401
msgid "Types are written like this: ``<class 'int'>``."
msgstr "Türler şu şekilde yazılır: ``<class 'int'>``."

#: library/stdtypes.rst:5407
msgid "The Null Object"
msgstr "Null Nesne"

#: library/stdtypes.rst:5409
msgid ""
"This object is returned by functions that don't explicitly return a value.  It "
"supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Bu nesne, açıkça bir değer döndürmeyen işlevler tarafından döndürülür.  Özel "
"operasyonları desteklemez.  Tam olarak ``None`` (yerleşik bir ad) adlı bir null "
"nesne vardır.  ``type(None)()`` aynı singleton'u üretir."

#: library/stdtypes.rst:5413
msgid "It is written as ``None``."
msgstr "''Yok'' olarak yazılmıştır."

#: library/stdtypes.rst:5420
msgid "The Ellipsis Object"
msgstr "Üç Nokta Nesnesi"

#: library/stdtypes.rst:5422
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports no "
"special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Bu nesne genellikle dilimleme tarafından kullanılır (bkz. :ref:`slicings`).  "
"Özel operasyonları desteklemez.  Tam olarak :const:`Ellipsis` (yerleşik bir ad) "
"adında bir elips nesnesi vardır.  ``type(Ellipsis)()``, :const:`Ellipsis` "
"singletonunu üretir."

#: library/stdtypes.rst:5427
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "``Ellipsis`` veya ``...`` olarak yazılmıştır."

#: library/stdtypes.rst:5433
msgid "The NotImplemented Object"
msgstr "NotImplemented Nesnesi"

#: library/stdtypes.rst:5435
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for more "
"information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"Bu nesne, desteklemedikleri türlerde çalışmaları istendiğinde "
"karşılaştırmalardan ve ikili işlemlerden döndürülür. Daha fazla bilgi için :ref:"
"`comparisons` sayfasına bakın.  Tam olarak bir ``NotImplemented`` nesnesi "
"vardır. ``type(NotImplemented)()``, singleton örneğini üretir."

#: library/stdtypes.rst:5440
msgid "It is written as ``NotImplemented``."
msgstr "''NotImplemented'' olarak yazılmıştır."

#: library/stdtypes.rst:5446
msgid "Internal Objects"
msgstr "İç Nesneler"

#: library/stdtypes.rst:5448
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"Bu bilgi için :ref:`types` sayfasına bakın.  Yığın çerçeve nesnelerini, geri "
"izleme nesnelerini ve dilim nesnelerini açıklar."

#: library/stdtypes.rst:5455
msgid "Special Attributes"
msgstr "Özel Özellikler"

#: library/stdtypes.rst:5457
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"Uygulama, ilgili oldukları çeşitli nesne türlerine birkaç özel salt okunur "
"öznitelik ekler.  Bunlardan bazıları :func:`dir` yerleşik işlevi tarafından "
"bildirilmez."

#: library/stdtypes.rst:5464
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"Bir nesnenin (yazılabilir) özniteliklerini depolamak için kullanılan sözlük veya "
"başka bir eşleme nesnesi."

#: library/stdtypes.rst:5470
msgid "The class to which a class instance belongs."
msgstr "Bir sınıf örneğinin ait olduğu sınıf."

#: library/stdtypes.rst:5475
msgid "The tuple of base classes of a class object."
msgstr "Bir sınıf elemanının temel sınıflarının kümesi."

#: library/stdtypes.rst:5480
msgid "The name of the class, function, method, descriptor, or generator instance."
msgstr "Sınıf, fonksiyon, yöntem, tanımlayıcı veya üretici örneğinin adı."

#: library/stdtypes.rst:5486
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
"Sınıf, fonksiyon, yöntem, tanımlayıcı veya üretici örneğinin :term:`qualified "
"name`."

#: library/stdtypes.rst:5494
msgid ""
"The :ref:`type parameters <type-params>` of generic classes, functions, and :ref:"
"`type aliases <type-aliases>`."
msgstr ""
"Genel sınıfların, işlevlerin ve :ref:`tip takma adları <tip-takma adlar>`ın :ref:"
"`tip parametreleri <tip-params>`."

#: library/stdtypes.rst:5502
msgid ""
"This attribute is a tuple of classes that are considered when looking for base "
"classes during method resolution."
msgstr ""
"Bu öznitelik, yöntem çözümlemesi sırasında temel sınıfları ararken dikkate "
"alınan bir sınıf kümesidir."

#: library/stdtypes.rst:5508
msgid ""
"This method can be overridden by a metaclass to customize the method resolution "
"order for its instances.  It is called at class instantiation, and its result is "
"stored in :attr:`~class.__mro__`."
msgstr ""
"Bu yöntem, örneklerinin yöntem çözümleme sırasını özelleştirmek için bir meta "
"sınıf tarafından geçersiz kılınabilir.  Sınıf örneğinde çağrılır ve sonucu :attr:"
"`~class.__mro__` içinde depolanır."

#: library/stdtypes.rst:5515
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  This "
"method returns a list of all those references still alive.  The list is in "
"definition order.  Example::"
msgstr ""
"Her sınıf, kendi alt sınıflarına yapılan zayıf referansların bir listesini "
"tutar.  Bu yöntem, hala var olan tüm bu başvuruların bir listesini döndürür.  "
"Liste tanım sırasına göredir.  Örnek::"

#: library/stdtypes.rst:5526
msgid "Integer string conversion length limitation"
msgstr "Tamsayı dizisi dönüştürme uzunluğu sınırlaması"

#: library/stdtypes.rst:5528
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:`str` "
"to mitigate denial of service attacks. This limit *only* applies to decimal or "
"other non-power-of-two number bases. Hexadecimal, octal, and binary conversions "
"are unlimited. The limit can be configured."
msgstr ""
"CPython, hizmet reddi saldırılarını azaltmak için :class:`int` ve :class:`str` "
"arasında dönüştürme için genel bir sınıra sahiptir. Bu sınır *yalnızca* ondalık "
"veya ikinin katı olmayan diğer sayı tabanları için geçerlidir. Onaltılık, "
"sekizlik ve ikili dönüştürmeler sınırsızdır. Sınır yapılandırılabilir."

#: library/stdtypes.rst:5533
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in binary "
"form (commonly known as a \"bignum\"). There exists no algorithm that can "
"convert a string to a binary integer or a binary integer to a string in linear "
"time, *unless* the base is a power of 2. Even the best known algorithms for base "
"10 have sub-quadratic complexity. Converting a large value such as ``int('1' * "
"500_000)`` can take over a second on a fast CPU."
msgstr ""
"CPython'daki :class:`int` türü, ikili biçimde (genellikle \"bignum\" olarak "
"bilinir) saklanan bir abitrary uzunluklu sayıdır. Tabanı 2'nin kuvveti olmadığı "
"sürece, bir diziyi ikili tamsayıya veya ikili tamsayıyı lineer zamanda bir "
"diziye dönüştürebilen hiçbir algoritma yoktur. 10 tabanı için en iyi bilinen "
"algoritmalar bile ikinci dereceden karmaşıklığa sahiptir. ``int('1' * 500_000)`` "
"gibi büyük bir değerin dönüştürülmesi, hızlı bir CPU'da bir saniyeden fazla "
"zaman alabilir."

#: library/stdtypes.rst:5540
msgid ""
"Limiting conversion size offers a practical way to avoid `CVE-2020-10735 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735>`_."
msgstr ""
"Dönüşüm boyutunu sınırlamak, `CVE-2020-10735 <https://cve.mitre.org/cgi-bin/"
"cvename.cgi?name=CVE-2020-10735>`_ önlemek için pratik bir yol sunar."

#: library/stdtypes.rst:5543
msgid ""
"The limit is applied to the number of digit characters in the input or output "
"string when a non-linear conversion algorithm would be involved.  Underscores "
"and the sign are not counted towards the limit."
msgstr ""
"Sınır, doğrusal olmayan bir dönüştürme algoritması söz konusu olduğunda giriş "
"veya çıkış dizisindeki basamak karakterlerinin sayısına uygulanır. Alt çizgiler "
"ve işaret, sınıra dahil edilmez."

#: library/stdtypes.rst:5547
msgid "When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr "Bir işlem sınırı aştığında, bir :exc:`ValueError` oluşturulur:"

#: library/stdtypes.rst:5569
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be configured "
"is 640 digits as provided in :data:`sys.int_info.str_digits_check_threshold <sys."
"int_info>`."
msgstr ""
"Varsayılan sınır, :data:`sys.int_info.default_max_str_digits <sys.int_info>` "
"içinde sağlanan 4300 basamaktır. Yapılandırılabilecek en düşük sınır, :data:`sys."
"int_info.str_digits_check_threshold <sys.int_info>` içinde sağlanan şekilde 640 "
"basamaktır."

#: library/stdtypes.rst:5574
msgid "Verification:"
msgstr "Doğrulama:"

#: library/stdtypes.rst:5589
msgid "Affected APIs"
msgstr "Etkilenen API'ler"

#: library/stdtypes.rst:5591
msgid ""
"The limitation only applies to potentially slow conversions between :class:`int` "
"and :class:`str` or :class:`bytes`:"
msgstr ""
"Sınırlama yalnızca :class:`int` ve :class:`str` veya :class:`bytes` arasındaki "
"potansiyel olarak yavaş dönüşümler için geçerlidir:"

#: library/stdtypes.rst:5594
msgid "``int(string)`` with default base 10."
msgstr "``int(string)``, varsayılan taban 10."

#: library/stdtypes.rst:5595
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr "2'nin kuvveti olmayan tüm tabanlar için \"int(string, base)\"."

#: library/stdtypes.rst:5596
msgid "``str(integer)``."
msgstr "``str(integer)``."

#: library/stdtypes.rst:5597
msgid "``repr(integer)``."
msgstr "``repr(tamsayı)``."

#: library/stdtypes.rst:5598
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, ``\"{}\"."
"format(integer)``, or ``b\"%d\" % integer``."
msgstr ""
"10 tabanına başka herhangi bir dize dönüştürme, örneğin ``f\"{integer}\"``, "
"``\"{}\".format(integer)`` veya ``b\"%d\" % integer``."

#: library/stdtypes.rst:5601
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr "Sınırlamalar, doğrusal algoritmalı işlevler için geçerli değildir:"

#: library/stdtypes.rst:5603
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr "2, 4, 8, 16 veya 32 tabanlı \"int(string, base)\"."

#: library/stdtypes.rst:5604
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ":func:`int.from_bytes` ve :func:`int.to_bytes`."

#: library/stdtypes.rst:5605
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ":func:`hex`, :func:`oct`, :func:`bin`."

#: library/stdtypes.rst:5606
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ":ref:`formatspec` onaltılı, sekizli ve ikili sayılar için."

#: library/stdtypes.rst:5607
msgid ":class:`str` to :class:`float`."
msgstr ":class:`str`den :class:`float`a."

#: library/stdtypes.rst:5608
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ":class:`str` - :class:`decimal.Decimal`."

#: library/stdtypes.rst:5611
msgid "Configuring the limit"
msgstr "Limiti yapılandırma"

#: library/stdtypes.rst:5613
msgid ""
"Before Python starts up you can use an environment variable or an interpreter "
"command line flag to configure the limit:"
msgstr ""
"Python başlamadan önce, sınırı yapılandırmak için bir ortam değişkeni veya "
"yorumlayıcı komut satırı işareti kullanabilirsiniz:"

#: library/stdtypes.rst:5616
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` to "
"set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable the "
"limitation."
msgstr ""
":envvar:`PYTHONINTMAXSTRDIGITS`, örn. Sınırı 640 olarak ayarlamak için "
"``PYTHONINTMAXSTRDIGITS=640 python3`` veya sınırlamayı devre dışı bırakmak için "
"``PYTHONINTMAXSTRDIGITS=0 python3``."

#: library/stdtypes.rst:5619
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X int_max_str_digits=640``"
msgstr ""
":seçenek:`-X int_max_str_digits <-X>`, örn. ``python3 -X int_max_str_digits=640``"

#: library/stdtypes.rst:5621
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the env "
"var and the ``-X`` option are set, the ``-X`` option takes precedence. A value "
"of *-1* indicates that both were unset, thus a value of :data:`sys.int_info."
"default_max_str_digits` was used during initialization."
msgstr ""
":data:`sys.flags.int_max_str_digits`, :envvar:`PYTHONINTMAXSTRDIGITS` veya :"
"option:`-X int_max_str_digits <-X>` değerini içerir. Hem env var hem de \"-X\" "
"seçeneği ayarlanmışsa, \"-X\" seçeneği önceliklidir. *-1* değeri, her ikisinin "
"de ayarlanmamış olduğunu gösterir, dolayısıyla başlatma sırasında :data:`sys."
"int_info.default_max_str_digits` değeri kullanılmıştır."

#: library/stdtypes.rst:5627
msgid ""
"From code, you can inspect the current limit and set a new one using these :mod:"
"`sys` APIs:"
msgstr ""
"Koddan, şu :mod:`sys` API'lerini kullanarak geçerli sınırı inceleyebilir ve yeni "
"bir sınır belirleyebilirsiniz:"

#: library/stdtypes.rst:5630
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` are a "
"getter and setter for the interpreter-wide limit. Subinterpreters have their own "
"limit."
msgstr ""
":func:`sys.get_int_max_str_digits` ve :func:`sys.set_int_max_str_digits`, "
"yorumlayıcı genelinde sınır için bir alıcı ve ayarlayıcıdır. Yardımcı "
"tercümanların kendi limitleri vardır."

#: library/stdtypes.rst:5634
msgid ""
"Information about the default and minimum can be found in :data:`sys.int_info`:"
msgstr ""
"Varsayılan ve minimum hakkında bilgi şu adreste bulunabilir:attr:`sys.int_info`:"

#: library/stdtypes.rst:5636
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-in "
"default limit."
msgstr ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` derlenmiş varsayılan "
"sınırdır."

#: library/stdtypes.rst:5638
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""
"data:`sys.int_info.str_digits_check_threshold <sys.int_info>` sınır için kabul "
"edilen en düşük değerdir (sınırı devre dışı bırakan 0 dışında)."

#: library/stdtypes.rst:5645
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the minimum "
"threshold. A consequence of setting the limit is that Python source code "
"containing decimal integer literals longer than the limit will encounter an "
"error during parsing, usually at startup time or import time or even at "
"installation time - anytime an up to date ``.pyc`` does not already exist for "
"the code. A workaround for source that contains such large constants is to "
"convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""
"Düşük bir limit ayarlamak * sorunlara yol açabilir. Nadir olmakla birlikte, "
"kaynağında minimum eşiği aşan ondalık tamsayı sabitleri içeren kod mevcuttur. "
"Sınırı ayarlamanın bir sonucu olarak, sınırdan daha uzun ondalık tamsayı sabit "
"değerleri içeren Python kaynak kodu, ayrıştırma sırasında, genellikle başlatma "
"zamanında veya içe aktarma zamanında ve hatta kurulum zamanında - herhangi bir "
"güncel ``.pyc`` hatasıyla karşılaşacaktır. kod için zaten mevcut değil. Bu kadar "
"büyük sabitler içeren kaynak için geçici bir çözüm, sınırı olmadığı için onları "
"\"0x\" onaltılık biçime dönüştürmektir."

#: library/stdtypes.rst:5654
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests run "
"with the limit set early via the environment or flag so that it applies during "
"startup and even during any installation step that may invoke Python to "
"precompile ``.py`` sources to ``.pyc`` files."
msgstr ""
"Düşük bir limit kullanıyorsanız, uygulamanızı kapsamlı bir şekilde test edin. "
"Başlangıç ​​sırasında ve hatta ``.py`` kaynaklarını ``.pyc`` dosyalarına önceden "
"derlemek için Python'u çağırabilecek herhangi bir kurulum adımı sırasında "
"geçerli olması için testlerinizin ortam veya bayrak aracılığıyla erken ayarlanan "
"sınırla çalıştığından emin olun."

#: library/stdtypes.rst:5660
msgid "Recommended configuration"
msgstr "Önerilen yapılandırma"

#: library/stdtypes.rst:5662
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code as "
"these APIs were added in security patch releases in versions before 3.12."
msgstr ""
"Varsayılan :data:`sys.int_info.default_max_str_digits` değerinin çoğu uygulama "
"için makul olması beklenir. Uygulamanız farklı bir sınır gerektiriyorsa, bu "
"API'ler 3.11'den önceki sürümlerde güvenlik düzeltme eki sürümlerine "
"eklendiğinden, Python sürüm agnostik kodunu kullanarak ana giriş noktanızdan "
"ayarlayın."

#: library/stdtypes.rst:5667
msgid "Example::"
msgstr "Örnek::"

#: library/stdtypes.rst:5679
msgid "If you need to disable it entirely, set it to ``0``."
msgstr "Tamamen devre dışı bırakmanız gerekirse, \"0\" olarak ayarlayın."

#: library/stdtypes.rst:5683
msgid "Footnotes"
msgstr "Dipnotlar"

#: library/stdtypes.rst:5684
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Bu özel yöntemler hakkında daha fazla bilgi Python Referans El Kitabında (:ref:"
"`customization`) bulunabilir."

#: library/stdtypes.rst:5687
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, and "
"similarly for tuples."
msgstr ""
"Sonuç olarak, ``[1, 2]`` listesi ``[1.0, 2.0]`` ve benzer şekilde demetler için "
"eşit kabul edilir."

#: library/stdtypes.rst:5690
msgid "They must have since the parser can't tell the type of the operands."
msgstr "Ayrıştırıcı, işlenenlerin türünü söyleyemediğinden sahip olmaları gerekir."

#: library/stdtypes.rst:5692
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Harfli karakterler, genel kategori özelliği \"Lu\" (Harf, büyük), \"Ll\" (Harf, "
"küçük harf) veya \"Lt\" (Harf, başlık) karakterlerinden biri olan karakterlerdir."

#: library/stdtypes.rst:5695
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose only "
"element is the tuple to be formatted."
msgstr ""
"Bu nedenle, yalnızca bir tuple(demet) biçimlendirmek için, tek öğesi "
"biçimlendirilecek tuple(demet) olan tek bir tuple(demet) sağlamanız gerekir."

#: library/stdtypes.rst:13
msgid "built-in"
msgstr "yerleşik"

#: library/stdtypes.rst:315 library/stdtypes.rst:948 library/stdtypes.rst:1137
#: library/stdtypes.rst:4419 library/stdtypes.rst:5392
msgid "types"
msgstr "türleri"

#: library/stdtypes.rst:1152 library/stdtypes.rst:4419
msgid "statement"
msgstr "ifade"

#: library/stdtypes.rst:34
msgid "if"
msgstr "eğer"

#: library/stdtypes.rst:34
msgid "while"
msgstr "sırasında"

#: library/stdtypes.rst:34
msgid "truth"
msgstr "gerçek"

#: library/stdtypes.rst:34
msgid "value"
msgstr "değer"

#: library/stdtypes.rst:80 library/stdtypes.rst:815
msgid "Boolean"
msgstr "Boolean"

#: library/stdtypes.rst:80 library/stdtypes.rst:392
msgid "operations"
msgstr "operasyonlar"

#: library/stdtypes.rst:34
msgid "false"
msgstr "yanlış"

#: library/stdtypes.rst:44
msgid "true"
msgstr "doğru"

#: library/stdtypes.rst:51
msgid "None (Built-in object)"
msgstr "Yok (Yerleşik nesne)"

#: library/stdtypes.rst:51
msgid "False (Built-in object)"
msgstr "Yanlış (Yerleşik nesne)"

#: library/stdtypes.rst:97 library/stdtypes.rst:194 library/stdtypes.rst:392
#: library/stdtypes.rst:948
msgid "operator"
msgstr "operatör"

#: library/stdtypes.rst:97
msgid "or"
msgstr "ya da"

#: library/stdtypes.rst:97
msgid "and"
msgstr "ve"

#: library/stdtypes.rst:815
msgid "False"
msgstr "Yanlış"

#: library/stdtypes.rst:815
msgid "True"
msgstr "Doğru"

#: library/stdtypes.rst:97
msgid "not"
msgstr "değil"

#: library/stdtypes.rst:122
msgid "chaining"
msgstr "zincirleme"

#: library/stdtypes.rst:122
msgid "comparisons"
msgstr "karşılaştırmalar"

#: library/stdtypes.rst:122
msgid "comparison"
msgstr "karşılaştırma"

#: library/stdtypes.rst:122
msgid "=="
msgstr "=="

#: library/stdtypes.rst:122
msgid "< (less)"
msgstr "< (daha az)"

#: library/stdtypes.rst:122
msgid "<="
msgstr "<="

#: library/stdtypes.rst:122
msgid "> (greater)"
msgstr "> (daha büyük)"

#: library/stdtypes.rst:122
msgid ">="
msgstr ">="

#: library/stdtypes.rst:122
msgid "!="
msgstr "!="

#: library/stdtypes.rst:122
msgid "is"
msgstr "dır-dir"

#: library/stdtypes.rst:122
msgid "is not"
msgstr "değil"

#: library/stdtypes.rst:207 library/stdtypes.rst:1115 library/stdtypes.rst:1257
#: library/stdtypes.rst:1380 library/stdtypes.rst:1538 library/stdtypes.rst:2531
#: library/stdtypes.rst:4218 library/stdtypes.rst:4894 library/stdtypes.rst:5317
#: library/stdtypes.rst:5356
msgid "object"
msgstr "kod Nesneleri"

#: library/stdtypes.rst:207 library/stdtypes.rst:315 library/stdtypes.rst:334
msgid "numeric"
msgstr "numerik"

#: library/stdtypes.rst:162
msgid "objects"
msgstr "kod Nesneleri"

#: library/stdtypes.rst:162
msgid "comparing"
msgstr "karşılaştırmalar"

#: library/stdtypes.rst:172
msgid "__eq__() (instance method)"
msgstr "__eq__() (örnek yöntemi)"

#: library/stdtypes.rst:172
msgid "__ne__() (instance method)"
msgstr "__ne__() (örnek yöntemi)"

#: library/stdtypes.rst:172
msgid "__lt__() (instance method)"
msgstr "__lt__() (örnek yöntemi)"

#: library/stdtypes.rst:172
msgid "__le__() (instance method)"
msgstr "__le__() (örnek yöntemi)"

#: library/stdtypes.rst:172
msgid "__gt__() (instance method)"
msgstr "__gt__() (örnek yöntemi)"

#: library/stdtypes.rst:172
msgid "__ge__() (instance method)"
msgstr "__ge__() (örnek yöntemi)"

#: library/stdtypes.rst:948
msgid "in"
msgstr "içinde"

#: library/stdtypes.rst:948
msgid "not in"
msgstr "değil"

#: library/stdtypes.rst:228 library/stdtypes.rst:392
msgid "integer"
msgstr "tamsayı"

#: library/stdtypes.rst:228
msgid "floating point"
msgstr "kayan nokta"

#: library/stdtypes.rst:228
msgid "complex number"
msgstr "karmaşık sayı"

#: library/stdtypes.rst:207
msgid "C"
msgstr "C"

#: library/stdtypes.rst:207
msgid "language"
msgstr "dil"

#: library/stdtypes.rst:228
msgid "literals"
msgstr "değişmez harfler"

#: library/stdtypes.rst:228
msgid "hexadecimal"
msgstr "hexadecimal"

#: library/stdtypes.rst:228
msgid "octal"
msgstr "sekizli"

#: library/stdtypes.rst:228
msgid "binary"
msgstr "ikili"

#: library/stdtypes.rst:245
msgid "arithmetic"
msgstr "aritmetik"

#: library/stdtypes.rst:948 library/stdtypes.rst:4419 library/stdtypes.rst:5377
#: library/stdtypes.rst:5392
msgid "built-in function"
msgstr "yerleşik işlev"

#: library/stdtypes.rst:245
msgid "int"
msgstr "int"

#: library/stdtypes.rst:245
msgid "float"
msgstr "float"

#: library/stdtypes.rst:245
msgid "complex"
msgstr "complex"

#: library/stdtypes.rst:2388 library/stdtypes.rst:3606
msgid "+ (plus)"
msgstr "+(artı)"

#: library/stdtypes.rst:245
msgid "unary operator"
msgstr "tekli operatör"

#: library/stdtypes.rst:245
msgid "binary operator"
msgstr "ikili operatör"

#: library/stdtypes.rst:2388 library/stdtypes.rst:3606
msgid "- (minus)"
msgstr "-(eksi)"

#: library/stdtypes.rst:2345 library/stdtypes.rst:3563
msgid "* (asterisk)"
msgstr "* (yıldız işareti)"

#: library/stdtypes.rst:245
msgid "/ (slash)"
msgstr "/ (eğik çizgi)"

#: library/stdtypes.rst:245
msgid "//"
msgstr "//"

#: library/stdtypes.rst:2315 library/stdtypes.rst:3531
msgid "% (percent)"
msgstr "% (yüzde)"

#: library/stdtypes.rst:245
msgid "**"
msgstr "**"

#: library/stdtypes.rst:392 library/stdtypes.rst:1152 library/stdtypes.rst:4419
msgid "operations on"
msgstr "üzerinde yapılan işlemler"

#: library/stdtypes.rst:315
msgid "conjugate() (complex number method)"
msgstr "conjugate() (karmaşık sayı yöntemi)"

#: library/stdtypes.rst:1604 library/stdtypes.rst:5392
msgid "module"
msgstr "modül"

#: library/stdtypes.rst:334
msgid "math"
msgstr "matematik"

#: library/stdtypes.rst:334
msgid "floor() (in module math)"
msgstr "floor() (modül matematiğinde)"

#: library/stdtypes.rst:334
msgid "ceil() (in module math)"
msgstr "ceil() (in module math)"

#: library/stdtypes.rst:334
msgid "trunc() (in module math)"
msgstr "trunc() (modül matematiğinde)"

#: library/stdtypes.rst:334
msgid "conversions"
msgstr "dönüşümler"

#: library/stdtypes.rst:392
msgid "bitwise"
msgstr "bit düzeyinde"

#: library/stdtypes.rst:392
msgid "shifting"
msgstr "değişen"

#: library/stdtypes.rst:392
msgid "masking"
msgstr "maskeleme"

#: library/stdtypes.rst:392
msgid "| (vertical bar)"
msgstr "| (dikey çubuk)"

#: library/stdtypes.rst:392
msgid "^ (caret)"
msgstr "^ (şapka)"

#: library/stdtypes.rst:392
msgid "& (ampersand)"
msgstr "& (ve işareti)"

#: library/stdtypes.rst:392
msgid "<<"
msgstr "<<"

#: library/stdtypes.rst:392
msgid ">>"
msgstr ">>"

#: library/stdtypes.rst:392
msgid "~ (tilde)"
msgstr "~ (tilde)"

#: library/stdtypes.rst:815
msgid "values"
msgstr "değerler"

#: library/stdtypes.rst:845
msgid "iterator protocol"
msgstr "yineleyici protokolü"

#: library/stdtypes.rst:4809
msgid "protocol"
msgstr "protokol"

#: library/stdtypes.rst:845
msgid "iterator"
msgstr "yineleyeci"

#: library/stdtypes.rst:932 library/stdtypes.rst:1115 library/stdtypes.rst:1152
msgid "sequence"
msgstr "sekans"

#: library/stdtypes.rst:845
msgid "iteration"
msgstr "tekrarlama"

#: library/stdtypes.rst:845
msgid "container"
msgstr "konteyner"

#: library/stdtypes.rst:845
msgid "iteration over"
msgstr "yineleme bitti"

#: library/stdtypes.rst:4419
msgid "len"
msgstr "uzunluk"

#: library/stdtypes.rst:948
msgid "min"
msgstr "minimum"

#: library/stdtypes.rst:948
msgid "max"
msgstr "maksimum"

#: library/stdtypes.rst:948
msgid "concatenation"
msgstr "birleştirme"

#: library/stdtypes.rst:948
msgid "operation"
msgstr "işlem"

#: library/stdtypes.rst:948
msgid "repetition"
msgstr "tekrarlama"

#: library/stdtypes.rst:1152
msgid "subscript"
msgstr "alt simge"

#: library/stdtypes.rst:1152
msgid "slice"
msgstr "dilim"

#: library/stdtypes.rst:948
msgid "count() (sequence method)"
msgstr "count() (sıra yöntemi)"

#: library/stdtypes.rst:948
msgid "index() (sequence method)"
msgstr "index() (sıra yöntemi)"

#: library/stdtypes.rst:1004
msgid "loop"
msgstr "döngü"

#: library/stdtypes.rst:1004
msgid "over mutable sequence"
msgstr "aşırı değişken dizi"

#: library/stdtypes.rst:1004
msgid "mutable sequence"
msgstr "değişken dizi"

#: library/stdtypes.rst:1004
msgid "loop over"
msgstr "döngüye girmek"

#: library/stdtypes.rst:1115
msgid "immutable"
msgstr "değişmez"

#: library/stdtypes.rst:1336
msgid "tuple"
msgstr "demet"

#: library/stdtypes.rst:1115
msgid "hash"
msgstr "hash"

#: library/stdtypes.rst:1137
msgid "mutable"
msgstr "değişken"

#: library/stdtypes.rst:1152 library/stdtypes.rst:1257
msgid "list"
msgstr "liste"

#: library/stdtypes.rst:2512 library/stdtypes.rst:2710 library/stdtypes.rst:3531
msgid "bytearray"
msgstr "bytearraybytearray"

#: library/stdtypes.rst:4419 library/stdtypes.rst:5392
msgid "type"
msgstr "tip"

#: library/stdtypes.rst:1152
msgid "assignment"
msgstr "atama"

#: library/stdtypes.rst:4419
msgid "del"
msgstr "del"

#: library/stdtypes.rst:1152
msgid "append() (sequence method)"
msgstr "append() (sıra yöntemi)"

#: library/stdtypes.rst:1152
msgid "clear() (sequence method)"
msgstr "clear() (sıra yöntemi)"

#: library/stdtypes.rst:1152
msgid "copy() (sequence method)"
msgstr "copy() (sıra yöntemi)"

#: library/stdtypes.rst:1152
msgid "extend() (sequence method)"
msgstr "extend() (sıra yöntemi)"

#: library/stdtypes.rst:1152
msgid "insert() (sequence method)"
msgstr "insert() (sıra yöntemi)"

#: library/stdtypes.rst:1152
msgid "pop() (sequence method)"
msgstr "pop() (sıra yöntemi)"

#: library/stdtypes.rst:1152
msgid "remove() (sequence method)"
msgstr "kaldır() (sıra yöntemi)"

#: library/stdtypes.rst:1152
msgid "reverse() (sequence method)"
msgstr "ters() (sıra yöntemi)"

#: library/stdtypes.rst:1380
msgid "range"
msgstr "aralık"

#: library/stdtypes.rst:1551 library/stdtypes.rst:2315
msgid "string"
msgstr "dizi"

#: library/stdtypes.rst:1502
msgid "text sequence type"
msgstr "değiştirilebilir dizi tipleri"

#: library/stdtypes.rst:1551 library/stdtypes.rst:1569
msgid "str (built-in class)"
msgstr "str (yerleşik sınıf)"

#: library/stdtypes.rst:1502
msgid "(see also string)"
msgstr "(ayrıca bkz. dize)"

#: library/stdtypes.rst:1538
msgid "io.StringIO"
msgstr "io.StringIO"

#: library/stdtypes.rst:2504
msgid "buffer protocol"
msgstr "tampon protokolü"

#: library/stdtypes.rst:2512 library/stdtypes.rst:2710 library/stdtypes.rst:3531
msgid "bytes"
msgstr "bytes"

#: library/stdtypes.rst:2710
msgid "methods"
msgstr "yöntemler"

#: library/stdtypes.rst:1604
msgid "re"
msgstr "tekrar"

#: library/stdtypes.rst:3385
msgid "universal newlines"
msgstr "evrensel yeni satırlar"

#: library/stdtypes.rst:2123
msgid "str.splitlines method"
msgstr "str.splitlines yöntemi"

#: library/stdtypes.rst:2315
msgid "formatting, string (%)"
msgstr "biçimlendirme, dize (%)"

#: library/stdtypes.rst:2315
msgid "interpolation, string (%)"
msgstr "enterpolasyon, dize (%)"

#: library/stdtypes.rst:2315
msgid "formatting, printf"
msgstr "biçimlendirme, printf"

#: library/stdtypes.rst:2315
msgid "interpolation, printf"
msgstr "enterpolasyon, printf"

#: library/stdtypes.rst:3531
msgid "printf-style formatting"
msgstr "printf tarzı biçimlendirme"

#: library/stdtypes.rst:3531
msgid "sprintf-style formatting"
msgstr "sprintf tarzı biçimlendirme"

#: library/stdtypes.rst:3563
msgid "() (parentheses)"
msgstr "() (parentez)"

#: library/stdtypes.rst:2388 library/stdtypes.rst:3606
msgid "in printf-style formatting"
msgstr "printf tarzı biçimlendirmede"

#: library/stdtypes.rst:3563
msgid ". (dot)"
msgstr ".(nokta)"

#: library/stdtypes.rst:3606
msgid "# (hash)"
msgstr "# (hash)"

#: library/stdtypes.rst:3606
msgid "space"
msgstr "boşluk"

#: library/stdtypes.rst:2504
msgid "binary sequence types"
msgstr "ikili dizi türleri"

#: library/stdtypes.rst:2512
msgid "memoryview"
msgstr "bellek görünümü"

#: library/stdtypes.rst:2512
msgid "array"
msgstr "sıralamak"

#: library/stdtypes.rst:3385
msgid "bytes.splitlines method"
msgstr "bytes.splitlines yöntemi"

#: library/stdtypes.rst:3385
msgid "bytearray.splitlines method"
msgstr "bytearray.splitlines yöntemi"

#: library/stdtypes.rst:3531
msgid "formatting"
msgstr "biçimlendirme"

#: library/stdtypes.rst:3531
msgid "bytes (%)"
msgstr "bytes (%)"

#: library/stdtypes.rst:3531
msgid "bytearray (%)"
msgstr "bytearray (%)"

#: library/stdtypes.rst:3531
msgid "interpolation"
msgstr "satır tablolama"

#: library/stdtypes.rst:4218
msgid "set"
msgstr "ayarlamak"

#: library/stdtypes.rst:4419
msgid "mapping"
msgstr "haritalama"

#: library/stdtypes.rst:4419
msgid "dictionary"
msgstr "sözlük"

#: library/stdtypes.rst:4502
msgid "__missing__()"
msgstr "__eksik__()"

#: library/stdtypes.rst:4809
msgid "context manager"
msgstr "bağlam yöneticisi"

#: library/stdtypes.rst:4809
msgid "context management protocol"
msgstr "bağlam yönetimi protokolü"

#: library/stdtypes.rst:4809
msgid "context management"
msgstr "bağlam yönetimi"

#: library/stdtypes.rst:4882
msgid "annotation"
msgstr "dipnot"

#: library/stdtypes.rst:4882
msgid "type annotation; type hint"
msgstr "açıklama yazın; ipucu yazın"

#: library/stdtypes.rst:4894
msgid "GenericAlias"
msgstr "Genel Takma Ad"

#: library/stdtypes.rst:4894
msgid "Generic"
msgstr "Genel"

#: library/stdtypes.rst:4894
msgid "Alias"
msgstr "Takma ad"

#: library/stdtypes.rst:5149
msgid "Union"
msgstr "Birlik"

#: library/stdtypes.rst:5149
msgid "union"
msgstr "birlik"

#: library/stdtypes.rst:5317
msgid "method"
msgstr "yöntemler"

#: library/stdtypes.rst:5356
msgid "code"
msgstr "kod"

#: library/stdtypes.rst:5356
msgid "code object"
msgstr "kod Nesneleri"

#: library/stdtypes.rst:5363
msgid "compile"
msgstr "derlemek"

#: library/stdtypes.rst:5363
msgid "__code__ (function object attribute)"
msgstr "__code__ (işlev nesnesi niteliği)"

#: library/stdtypes.rst:5377
msgid "exec"
msgstr "yönetici"

#: library/stdtypes.rst:5377
msgid "eval"
msgstr "değerlendirmek"

#: library/stdtypes.rst:5416
msgid "..."
msgstr "..."

#: library/stdtypes.rst:5416
msgid "ellipsis literal"
msgstr "üç nokta değişmezi"

#~ msgid "Boolean Values"
#~ msgstr "Boolean Değerleri"

#~ msgid ""
#~ "Boolean values are the two constant objects ``False`` and ``True``.  They are "
#~ "used to represent truth values (although other values can also be considered "
#~ "false or true).  In numeric contexts (for example when used as the argument "
#~ "to an arithmetic operator), they behave like the integers 0 and 1, "
#~ "respectively. The built-in function :func:`bool` can be used to convert any "
#~ "value to a Boolean, if the value can be interpreted as a truth value (see "
#~ "section :ref:`truth` above)."
#~ msgstr ""
#~ "Boolean değerleri, ``Yanlış`` ve ``Doğru`` olmak üzere iki sabit nesnedir.  "
#~ "Doğruluk değerlerini temsil etmek için kullanılırlar (diğer değerler de "
#~ "yanlış veya doğru olarak kabul edilebilir).  Sayısal bağlamlarda (örneğin, "
#~ "bir aritmetik işlecinin bağımsız değişkeni olarak kullanıldığında), sırasıyla "
#~ "0 ve 1 tamsayıları gibi davranırlar. Yerleşik işlev :func:`bool`, değer bir "
#~ "doğruluk değeri olarak yorumlanabiliyorsa, herhangi bir değeri bir Boolean'a "
#~ "dönüştürmek için kullanılabilir (yukarıdaki bölüm :ref:`truth` a bakın)."

#~ msgid "They are written as ``False`` and ``True``, respectively."
#~ msgstr "Sırasıyla ``Yanlış`` ve ``Doğru`` olarak yazılırlar."

#~ msgid "if *x* is false, then *y*, else *x*"
#~ msgstr "*x* yanlışsa, *y*, aksi halde *x*"

#~ msgid ""
#~ "By default, the *errors* argument is not checked for best performances, but "
#~ "only used at the first encoding error. Enable the :ref:`Python Development "
#~ "Mode <devmode>`, or use a :ref:`debug build <debug-build>` to check *errors*."
#~ msgstr ""
#~ "Varsayılan olarak, *error* argümanı en iyi performans için kontrol edilmez, "
#~ "sadece ilk kodlama hatasında kullanılır. :ref:`Python Geliştirme Modu "
#~ "<devmode>` öğesini etkinleştirin veya *hataları* kontrol etmek için bir :ref:"
#~ "`hata ayıklama derlemesi <debug-build>` kullanın."

#~ msgid "Support for keyword arguments added."
#~ msgstr "Anahtar kelime argümanları için destek eklendi."

#~ msgid ""
#~ "Dictionaries can be created by placing a comma-separated list of ``key: "
#~ "value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}`` "
#~ "or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
#~ msgstr ""
#~ "Sözlükler, ``key: value`` çiftlerinin virgülle ayrılmış bir listesini "
#~ "parantez içine yerleştirerek oluşturulabilir, örneğin: ``{'jack': 4098, "
#~ "'sjoerd': 4127}`` veya ``{4098: 'jack', 4127: 'sjoerd'}`` veya :class:`dict` "
#~ "yapıcısı ile oluşturulabilir."

#~ msgid ""
#~ "``GenericAlias`` objects are created by subscripting a class (usually a "
#~ "container), such as ``list[int]``.  They are intended primarily for :term:"
#~ "`type annotations <annotation>`."
#~ msgstr ""
#~ "``GenericAlias`` nesneleri, ``list[int]`` gibi bir sınıfın (genellikle bir "
#~ "kapsayıcı) alt kodlanmasıyla oluşturulur.  Bunlar öncelikle :term:`type "
#~ "annotations <annotation>` için tasarlanmıştır."

#~ msgid ""
#~ "Usually, the :ref:`subscription <subscriptions>` of container objects calls "
#~ "the method :meth:`__getitem__` of the object.  However, the subscription of "
#~ "some containers' classes may call the classmethod :meth:`__class_getitem__` "
#~ "of the class instead. The classmethod :meth:`__class_getitem__` should return "
#~ "a ``GenericAlias`` object."
#~ msgstr ""
#~ "Genellikle, kapsayıcı nesnelerinin :ref:`subscription <subscriptions>`, "
#~ "nesnenin :meth:`__getitem__` yöntemini çağırır.  Ancak, bazı konteyner "
#~ "sınıflarının aboneliğinin içinde sınıfın :meth:`__class_getitem__` sınıf "
#~ "metodunu çağırabilir. :meth:`__class_getitem__` sınıf yöntemi bir "
#~ "``GenerAlias`` nesnesine döndürmeli."

#~ msgid ""
#~ "If the :meth:`__getitem__` of the class' metaclass is present, it will take "
#~ "precedence over the :meth:`__class_getitem__` defined in the class (see :pep:"
#~ "`560` for more details)."
#~ msgstr ""
#~ "Sınıfın üst sınıfının :meth:`__getitem__`'i mevcutsa, sınıfta tanımlanan :"
#~ "meth:`__class_getitem__`'e göre öncelikli olacaktır (daha fazla ayrıntı için :"
#~ "pep:`560`'a bakın)."

#~ msgid ":meth:`__class_getitem__` -- Used to implement parameterized generics."
#~ msgstr ""
#~ ":meth:`__class_getitem__` -- Parametreli jenerikleri uygulamak için "
#~ "kullanılır."

#~ msgid ":ref:`generics` -- Generics in the :mod:`typing` module."
#~ msgstr ":ref:`generics` -- :mod:`typing` modülündeki jenerikler."
