# Python Documentation Turkish Translation
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-05 18:31+0300\n"
"PO-Revision-Date: 2022-08-15 20:14+0300\n"
"Last-Translator: \n"
"Language-Team: TURKISH <python.docs.tr@gmail.com>\n"
"Language: tr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.0.1\n"

#: library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Gömülü Türler"

#: library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"Aşağıdaki bölümlerde, yorumlayıcıda yerleşik olarak yer alan standart türler "
"açıklanmaktadır."

#: library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"Başlıca gömülü türler sayısallar, diziler, eşleşmeler, sınıflar, örnekler ve "
"kural dışı durumlardır."

#: library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Bazı koleksiyon sınıfları değişebilirdir.  Üyelerini yerinde ekleyen, "
"çıkaran veya yeniden düzenleyen ve belirli bir öğe döndürmeyen metotlar, her "
"zaman koleksiyon örneğini değil ``None`` değerini döndürür."

#: library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"Bazı işlemler birkaç nesne türü tarafından desteklenir; özellikle, tüm "
"nesneler eşitlik için karşılaştırılabilir, doğruluk değeri için test "
"edilebilir ve bir dizeye dönüştürülebilir (:func:`repr` fonksiyonu veya "
"hafif farklı olan :func:`str` fonksiyonu ile).  İkinci fonksiyon, bir nesne :"
"func:`print` ile yazdırıldığında dolaylı olarak kullanılır."

#: library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Doğruluk Değeri Testi"

#: library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Herhangi bir nesne, :keyword:`if` veya :keyword:`while` koşulunda veya "
"aşağıdaki Boolean işlemlerinin işleneni olarak kullanımında doğruluk değeri "
"için test edilebilir."

#: library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`__bool__` method that returns ``False`` or a :meth:`__len__` method "
"that returns zero, when called with the object. [1]_  Here are most of the "
"built-in objects considered false:"
msgstr ""
"Varsayılan olarak, bir nesne, sınıfı \"False\" döndüren bir :meth:`__bool__` "
"metodunu veya nesneyle birlikte çağrıldığında sıfır döndüren bir :meth:"
"`__len__` metodunu tanımlamadıkça doğru kabul edilir. [1]_ Yanlış olarak "
"kabul edilen yerleşik nesnelerin çoğu:"

#: library/stdtypes.rst:55
msgid "constants defined to be false: ``None`` and ``False``."
msgstr "false olarak tanımlanan sabitler: ``None`` ve ``False``."

#: library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"herhangi bir sayısal türden sıfır: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"

#: library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"boş diziler ve koleksiyonlar: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"

#: library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Boolean sonucu olan işlemler ve gömülü fonksiyonlar, aksi belirtilmedikçe "
"her zaman false için \"0\" veya \"False\" ve true için \"1\" veya \"True\" "
"döndürür. (Önemli istisna: Boolean işlemleri \"or\" ve \"and\" her zaman "
"işlenenlerinden birini döndürür.)"

#: library/stdtypes.rst:78
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr "Boolean İşlemleri --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"

#: library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "Bunlar artan önceliğe göre sıralanmış Boolean işlemleridir:"

#: library/stdtypes.rst:143 library/stdtypes.rst:364
#: library/stdtypes.rst:883 library/stdtypes.rst:1088
msgid "Operation"
msgstr "İşlem"

#: library/stdtypes.rst:275 library/stdtypes.rst:414
#: library/stdtypes.rst:1088
msgid "Result"
msgstr "Sonuç"

#: library/stdtypes.rst:275 library/stdtypes.rst:883
#: library/stdtypes.rst:2328 library/stdtypes.rst:3543
msgid "Notes"
msgstr "Notlar"

#: library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: library/stdtypes.rst:87
msgid "if *x* is false, then *y*, else *x*"
msgstr "*x* yanlışsa, *y*, aksi halde *x*"

#: library/stdtypes.rst:285 library/stdtypes.rst:888
#: library/stdtypes.rst:2334 library/stdtypes.rst:3549
msgid "\\(1)"
msgstr "\\(1)"

#: library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "*x* yanlışsa, *x*, aksi halde *y*"

#: library/stdtypes.rst:288 library/stdtypes.rst:1127
#: library/stdtypes.rst:2340 library/stdtypes.rst:3555
msgid "\\(2)"
msgstr "\\(2)"

#: library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "*x* yanlışsa, ``True``, aksi halde ``False``"

#: library/stdtypes.rst:897 library/stdtypes.rst:2342
#: library/stdtypes.rst:2346 library/stdtypes.rst:3557
#: library/stdtypes.rst:3561 library/stdtypes.rst:3563
msgid "\\(3)"
msgstr "\\(3)"

#: library/stdtypes.rst:319 library/stdtypes.rst:934
#: library/stdtypes.rst:2374 library/stdtypes.rst:3593
msgid "Notes:"
msgstr "Notlar:"

#: library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Bu bir kısa devre operatörüdür, bu nedenle ikinci argümanı yalnızca "
"birincisi yanlışsa değerlendirir."

#: library/stdtypes.rst:109
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Bu bir kısa devre operatörüdür, bu nedenle sadece ilki doğruysa ikinci "
"argümanı değerlendirir."

#: library/stdtypes.rst:113
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` Boolean olmayan operatörlerden daha düşük bir önceliğe sahiptir, bu "
"nedenle ``not a == b``, ``not (a == b)`` olarak yorumlanır bu sebeple ``a == "
"not b`` bir söz dizimi hatasıdır."

#: library/stdtypes.rst:120
msgid "Comparisons"
msgstr "Karşılaştırmalar"

#: library/stdtypes.rst:134
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Python'da sekiz karşılaştırma işlemi vardır.  Hepsinin önceliği aynıdır "
"(Boolean işlemlerinden daha önceliklidir).  Karşılaştırmalar isteğe bağlı "
"olarak zincirlenebilir; örneğin, ``x < y <= z``, ``x < y and y <= z`` ile eş "
"değerdir, ancak *y* yalnızca bir kez değerlendirilir (ancak her iki durumda "
"da ``x < y`` yanlış olduğu tespit edildiğinde *z* hiç değerlendirilmez)."

#: library/stdtypes.rst:140
msgid "This table summarizes the comparison operations:"
msgstr "Bu tablo karşılaştırma operatörlerini özetlemektedir:"

#: library/stdtypes.rst:2305 library/stdtypes.rst:3520
#: library/stdtypes.rst:3543
msgid "Meaning"
msgstr "Anlamı"

#: library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: library/stdtypes.rst:145
msgid "strictly less than"
msgstr "kesinlikle daha az"

#: library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: library/stdtypes.rst:147
msgid "less than or equal"
msgstr "daha az veya eşit"

#: library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "kesinlikle daha büyük"

#: library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "daha büyük veya eşit"

#: library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: library/stdtypes.rst:153
msgid "equal"
msgstr "eşit"

#: library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: library/stdtypes.rst:155
msgid "not equal"
msgstr "eşit değil"

#: library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: library/stdtypes.rst:157
msgid "object identity"
msgstr "nesne kimliği"

#: library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: library/stdtypes.rst:159
msgid "negated object identity"
msgstr "olumsuz nesne kimliği"

#: library/stdtypes.rst:166
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"Farklı sayısal türler dışında, farklı türdeki nesneler hiçbir zaman eşit "
"olarak karşılaştırılmaz. ``==`` operatörü her zaman tanımlanır, ancak bazı "
"nesne türleri için (örneğin, sınıf nesneleri) :keyword:`is` ile eş değerdir. "
"``<``, ``<=``, ``>`` ve ``>=`` operatörleri yalnızca anlamlı oldukları yerde "
"tanımlanır; örneğin, argümanlardan biri karmaşık bir sayı olduğunda bir :exc:"
"`TypeError` hatası oluştururlar."

#: library/stdtypes.rst:180
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr ""
"Normalde, bir sınıfın özdeş olmayan örnekleri, sınıf :meth:`~object.__eq__` "
"metodunu tanımlamadığı sürece eşit olmayan olarak karşılaştırılır."

#: library/stdtypes.rst:183
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object."
"__gt__`, and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :"
"meth:`~object.__eq__` are sufficient, if you want the conventional meanings "
"of the comparison operators)."
msgstr ""
"Bir sınıfın örnekleri, sınıf yeterli metotları tanımlamadıkça, aynı sınıfın "
"diğer örneklerine veya diğer nesne türlerine göre sıralanamaz :meth:`~object."
"__lt__`, :meth:`~object.__le__` , :meth:`~object.__gt__` ve :meth:`~object."
"__ge__` (karşılaştırma operatörlerin geleneksel anlamlarını istiyorsanız, :"
"meth:`~object.__lt__` ve :meth:`~object.__eq__` genellikle yeterli "
"olacaktır)."

#: library/stdtypes.rst:190
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
":keyword:`is` ve :keyword:`is not` operatörlerinin davranışı "
"özelleştirilemez; ayrıca herhangi iki nesneye uygulanabilirler ve asla bir "
"hata oluşturmazlar."

#: library/stdtypes.rst:198
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`__contains__` method."
msgstr ""
"Aynı söz dizimsel önceliğe sahip iki işlem daha, :keyword:`in` ve :keyword:"
"`not in`, :term:`iterable` olan veya :meth:`__contains__` metodunu uygulayan "
"türler tarafından desteklenir."

#: library/stdtypes.rst:205
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Sayısal Türler --- :class:`int`, :class:`float`, :class:`complex`"

#: library/stdtypes.rst:215
#, fuzzy
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:expr:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""
"Üç farklı sayısal tür vardır: :dfn:`integers`, :dfn:`floating point "
"numbers`, ve :dfn:`complex numbers`.  Ayrıca, Booleanlar tam sayıların bir "
"alt türüdür.  Tam sayıların kesinliği sınırsızdır.  Gerçel sayılar "
"genellikle C dilinde :c:type:`double` kullanılarak uygulanır; programınızın "
"çalıştığı makine için gerçel sayıların kesinliği ve dahili gösterimi "
"hakkında bilgi :data:`sys.float_info` içinde mevcuttur.  Karmaşık sayıların "
"her biri bir gerçel sayı olan gerçek ve sanal birer kısımları vardır. Bu "
"parçaları *z* karmaşık sayısından ayıklamak için ``z.real`` ve ``z.imag`` "
"kullanın. (Standart kütüphane, rasyonel sayılar için :mod:`fractions."
"Fraction` ve kullanıcı tarafından tanımlanabilen hassasiyete sahip gerçel "
"sayılar için :mod:`decimal.Decimal` ek sayısal türlerini içerir.)"

#: library/stdtypes.rst:237
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"Sayılar, sayısal değişmezlerle veya, gömülü fonksiyonlar ve operatörlerin "
"sonucu olarak oluşturulur.  Sade tam sayı değişmezleri (onaltılı, sekizli ve "
"ikili sayılar dahil) tam sayıları verir.  Ondalık nokta veya üs işareti "
"içeren sayısal değişmezler, gerçel sayıları verir.  Sayısal bir değişmeze "
"``'j'`` veya ``'J'`` eklemek, tam veya gerçel bir sayıya eklenince gerçek ve "
"hayali kısımları olan bir karmaşık sayı ortaya çıkaran, hayali bir sayı "
"üretir."

#: library/stdtypes.rst:262
#, fuzzy
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex. A comparison between numbers "
"of different types behaves as though the exact values of those numbers were "
"being compared. [2]_"
msgstr ""
"Python karma aritmetiği tam olarak destekler: herhangi bir ikili aritmetik "
"operatörü farklı sayısal türlerde işlenenlere sahip olduğunda, \"dar\" türe "
"sahip işlenen, tam sayı karmaşık sayıdan daha dar olan gerçel sayıdan daha "
"dar olduğu diğerininkine genişletilir. Farklı türlerdeki sayıların "
"karşılaştırılması, bu sayıların tam değerleri karşılaştırılıyormuş gibi "
"davranır. [2]_"

#: library/stdtypes.rst:268
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
":func:`int`, :func:`float` ve :func:`complex` yapıcıları belirli bir türde "
"sayılar üretmek için kullanılabilir."

#: library/stdtypes.rst:271
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"Tüm sayısal türler (karmaşık sayılar hariç) aşağıdaki işlemleri destekler "
"(işlemlerin öncelikleri için bkz. :ref:`operator-summary`):"

#: library/stdtypes.rst:275
msgid "Full documentation"
msgstr "Tam dokümantasyon"

#: library/stdtypes.rst:277
msgid "``x + y``"
msgstr "``x + y``"

#: library/stdtypes.rst:277
msgid "sum of *x* and *y*"
msgstr "*x* ve *y* 'nin toplamı"

#: library/stdtypes.rst:279
msgid "``x - y``"
msgstr "``x - y``"

#: library/stdtypes.rst:279
msgid "difference of *x* and *y*"
msgstr "*x* ve *y* 'nin farkı"

#: library/stdtypes.rst:281
msgid "``x * y``"
msgstr "``x * y``"

#: library/stdtypes.rst:281
msgid "product of *x* and *y*"
msgstr "*x* ve *y* 'nin çarpımı"

#: library/stdtypes.rst:283
msgid "``x / y``"
msgstr "``x / y``"

#: library/stdtypes.rst:283
msgid "quotient of *x* and *y*"
msgstr "*x* 'in *y* 'ye bölümü"

#: library/stdtypes.rst:285
msgid "``x // y``"
msgstr "``x // y``"

#: library/stdtypes.rst:285
msgid "floored quotient of *x* and *y*"
msgstr "*x* ve *y* 'nin kat bölümü"

#: library/stdtypes.rst:288
msgid "``x % y``"
msgstr "``x % y``"

#: library/stdtypes.rst:288
msgid "remainder of ``x / y``"
msgstr "``x / y`` işleminde kalan"

#: library/stdtypes.rst:290
msgid "``-x``"
msgstr "``-x``"

#: library/stdtypes.rst:290
msgid "*x* negated"
msgstr "*x* 'in negatifi"

#: library/stdtypes.rst:292
msgid "``+x``"
msgstr "``+x``"

#: library/stdtypes.rst:292
msgid "*x* unchanged"
msgstr "*x* 'in değişmemişi"

#: library/stdtypes.rst:294
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: library/stdtypes.rst:294
msgid "absolute value or magnitude of *x*"
msgstr "*x* 'in mutlak değeri"

#: library/stdtypes.rst:294
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: library/stdtypes.rst:297
msgid "``int(x)``"
msgstr "``int(x)``"

#: library/stdtypes.rst:297
msgid "*x* converted to integer"
msgstr "*x* 'in integer tam sayıya (integer) dönüştürülmüş hali"

#: library/stdtypes.rst:297
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: library/stdtypes.rst:297
msgid ":func:`int`"
msgstr ":func:`int`"

#: library/stdtypes.rst:299
msgid "``float(x)``"
msgstr "``float(x)``"

#: library/stdtypes.rst:299
msgid "*x* converted to floating point"
msgstr "*x* 'in gerçel sayıya (float) dönüştürülmüş hali"

#: library/stdtypes.rst:299
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: library/stdtypes.rst:299
msgid ":func:`float`"
msgstr ":func:`float`"

#: library/stdtypes.rst:301
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: library/stdtypes.rst:301
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"gerçek kısmı *re*, sanal kısmı *im* olan bir karmaşık sayı. *im* varsayılan "
"olarak sıfırdır."

#: library/stdtypes.rst:1120 library/stdtypes.rst:3580
msgid "\\(6)"
msgstr "\\(6)"

#: library/stdtypes.rst:301
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: library/stdtypes.rst:305
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: library/stdtypes.rst:305
msgid "conjugate of the complex number *c*"
msgstr "*c* karmaşık sayısının eşleniği"

#: library/stdtypes.rst:308
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: library/stdtypes.rst:308
msgid "the pair ``(x // y, x % y)``"
msgstr "``(x // y, x % y)`` ifadesinin ikilisi"

#: library/stdtypes.rst:308
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: library/stdtypes.rst:310
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: library/stdtypes.rst:312
msgid "*x* to the power *y*"
msgstr "*x* üzeri *y*"

#: library/stdtypes.rst:312 library/stdtypes.rst:1112
#: library/stdtypes.rst:2364 library/stdtypes.rst:3576
#: library/stdtypes.rst:3583
msgid "\\(5)"
msgstr "\\(5)"

#: library/stdtypes.rst:310
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: library/stdtypes.rst:312
msgid "``x ** y``"
msgstr "``x ** y``"

#: library/stdtypes.rst:322
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"Tam sayılı bölümü olarak da adlandırılır.  Elde edilen değer bir tam "
"sayıdır, ancak sonucun türü her zaman int olmayabilir.  Sonuç her zaman eksi "
"sonsuza yuvarlanır: ``1//2`` = ``0``, ``(-1)//2`` = ``-1``, ``1//(-2)`` = "
"``-1``, ve ``(-1)//(-2)`` = ``0``."

#: library/stdtypes.rst:328
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Karmaşık sayılar için değil.  Bunun yerine uygunsa :func:`abs` kullanarak "
"gerçel sayılara dönüştürün."

#: library/stdtypes.rst:340
msgid ""
"Conversion from floating point to integer may round or truncate as in C; see "
"functions :func:`math.floor` and :func:`math.ceil` for well-defined "
"conversions."
msgstr ""
"Gerçel sayının (float) tam sayıya (integer) dönüştürülmesi, C dilinde de "
"olduğu gibi sayının yuvarlanmasına veya kırpılmasına sebep olabilir; iyi "
"tanımlanmış dönüşümler için :func:`math.floor` ve :func:`math.ceil` "
"fonksiyonlarına bakın."

#: library/stdtypes.rst:345
#, fuzzy
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"float ayrıca \"nan\" ve \"inf\" dizelerini, Sayı Değil ( Not a Number -> "
"NaN) ve pozitif veya negatif sonsuzluk için isteğe bağlı bir \"+\" veya \"-"
"\" ön ekiyle kabul eder."

#: library/stdtypes.rst:349
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python, diğer programlama dillerinde de olduğu gibi ``pow(0, 0)`` = ``1`` ve "
"``0 ** 0`` = ``1`` şeklinde tanımlar."

#: library/stdtypes.rst:353
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"Kabul edilen sayısal değişmezler, ``0`` ile ``9`` arasındaki rakamları veya "
"herhangi bir Unicode eş değerini (\"Nd\" özelliğine sahip kod noktaları) "
"içerir."

#: library/stdtypes.rst:356
msgid ""
"See https://www.unicode.org/Public/13.0.0/ucd/extracted/DerivedNumericType."
"txt for a complete list of code points with the ``Nd`` property."
msgstr ""
"``Nd`` özelliğine sahip kod noktalarının tam listesi için https://www."
"unicode.org/Public/13.0.0/ucd/extracted/DerivedNumericType.txt adresine "
"bakın."

#: library/stdtypes.rst:360
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Tüm :class:`numbers.Real` türleri (:class:`int` ve :class:`float`) ayrıca "
"aşağıdaki işlemleri içerir:"

#: library/stdtypes.rst:366
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: library/stdtypes.rst:366
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* :class:`~numbers.Integral` şeklinde kısaltıldı"

#: library/stdtypes.rst:369
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: library/stdtypes.rst:369
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* *n* haneye yuvarlanır, yarıdan çifte yuvarlanır. *n* atlanırsa, *n* "
"varsayılan olarak 0 olur."

#: library/stdtypes.rst:373
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: library/stdtypes.rst:373
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "en büyük :class:`~numbers.Integral` <= *x*"

#: library/stdtypes.rst:376
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: library/stdtypes.rst:376
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "en küçük :class:`~numbers.Integral` >= *x*"

#: library/stdtypes.rst:380
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"Ek sayısal işlemler için :mod:`math` ve :mod:`cmath` modüllerine bakın."

#: library/stdtypes.rst:389
msgid "Bitwise Operations on Integer Types"
msgstr "Tam sayı Türlerinde Bit Düzeyinde İşlemler"

#: library/stdtypes.rst:403
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"Bit düzeyinde işlemler yalnızca tam sayılar için anlamlıdır. Bit düzeyinde "
"işlemlerin sonucu, sonsuz sayıda işaret biti ile ikiye tümleyende "
"gerçekleştiriliyormuş gibi hesaplanır."

#: library/stdtypes.rst:407
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"İkili bit düzeyinde işlemlerin öncelikleri, sayısal işlemlerden daha düşük "
"ve karşılaştırmalardan daha yüksektir; ``~`` tekli işlemidiğer tekli sayısal "
"işlemlerle (``+`` ve ``-``) aynı önceliğe sahiptir."

#: library/stdtypes.rst:411
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"Bu tablo, artan önceliğe göre sıralanmış bit düzeyinde işlemleri listeler:"

#: library/stdtypes.rst:416
msgid "``x | y``"
msgstr "``x | y``"

#: library/stdtypes.rst:416
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "bit düzeyinde *x* :dfn:`or` *y*"

#: library/stdtypes.rst:419 library/stdtypes.rst:1133
#: library/stdtypes.rst:2354 library/stdtypes.rst:3569
msgid "\\(4)"
msgstr "\\(4)"

#: library/stdtypes.rst:419
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: library/stdtypes.rst:419
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "bit düzeyinde *x* :dfn:`exclusive or` *y*"

#: library/stdtypes.rst:422
msgid "``x & y``"
msgstr "``x & y``"

#: library/stdtypes.rst:422
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "bit düzeyinde *x* :dfn:`and` *y*"

#: library/stdtypes.rst:425
msgid "``x << n``"
msgstr "``x << n``"

#: library/stdtypes.rst:425
msgid "*x* shifted left by *n* bits"
msgstr "*x*, *n* bit kadar sola kaydırıldı"

#: library/stdtypes.rst:425
msgid "(1)(2)"
msgstr "(1)(2)"

#: library/stdtypes.rst:427
msgid "``x >> n``"
msgstr "``x >> n``"

#: library/stdtypes.rst:427
msgid "*x* shifted right by *n* bits"
msgstr "*x*, *n* bit kadar sağa kaydırıldı"

#: library/stdtypes.rst:427
msgid "(1)(3)"
msgstr "(1)(3)"

#: library/stdtypes.rst:429
msgid "``~x``"
msgstr "``~x``"

#: library/stdtypes.rst:429
msgid "the bits of *x* inverted"
msgstr "*x* 'in bitleri ters çevrildi"

#: library/stdtypes.rst:435
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""
"Negatif kaydırma sayıları geçersizdir ve :exc:`ValueError` hatasına sebep "
"olur."

#: library/stdtypes.rst:438
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr "*n* bitlik sola kaydırma, ``pow(2, n)`` ile çarpmaya eş değerdir."

#: library/stdtypes.rst:441
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr ""
"*n* bitlik sağa kaydırma, ``pow(2, n)`` ile kat bölümü işlemine eş değerdir."

#: library/stdtypes.rst:444
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"Bu hesaplamaları, sonlu ikinin tümleyen temsilinde en az bir ekstra işaret "
"uzatma biti ile yapmak ( ``1 + max(x.bit_length(), y.bit_length())`` veya "
"daha fazla çalışan bit genişliği), sonsuz sayıda işaret biti varmış gibi "
"aynı sonucu elde etmek için yeterlidir."

#: library/stdtypes.rst:451
msgid "Additional Methods on Integer Types"
msgstr "Integer (Tam sayı) Türlerinde Ek Metotlar"

#: library/stdtypes.rst:453
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"Int türü, :class:`numbers.Integral` :term:`abstract base class` 'ı uygular. "
"Ek olarak, birkaç metot daha sağlar:"

#: library/stdtypes.rst:458
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"İşaret ve baştaki sıfırlar hariç, ikili sistemde bir tam sayıyı (integer) "
"temsil etmek için gereken bit sayısını döndürür::"

#: library/stdtypes.rst:467
#, fuzzy
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"Daha doğrusu, ``x`` sıfırdan farklıysa, ``x.bit_length()``, ``2**(k-1) <= "
"abs(x) < 2**k`` olacak şekilde benzersiz ``k`` pozitif tam sayıdır. Aynı "
"şekilde, ``abs(x)`` doğru olarak yuvarlatılmış bir logaritmaya sahip olacak "
"kadar küçük olduğunda, ``k = 1 + int(log(abs(x), 2))`` olur. ``x`` sıfır "
"ise, ``x.bit_length()``, ``0`` döndürür."

#: library/stdtypes.rst:496
msgid "Equivalent to::"
msgstr "Eşittir::"

#: library/stdtypes.rst:484
msgid ""
"Return the number of ones in the binary representation of the absolute value "
"of the integer. This is also known as the population count. Example::"
msgstr ""
"Tam sayının mutlak değerinin ikili gösterimindeki birlerin sayısını "
"döndürün. Buna nüfus sayımı da denir. Örneğin::"

#: library/stdtypes.rst:505
msgid "Return an array of bytes representing an integer."
msgstr "Bir tam sayıyı temsil eden bir bayt dizisi döndürür."

#: library/stdtypes.rst:517
msgid ""
"The integer is represented using *length* bytes.  An :exc:`OverflowError` is "
"raised if the integer is not representable with the given number of bytes."
msgstr ""
"Tam sayı, *length* bayt kullanılarak temsil edilir.  Tam sayı verilen bayt "
"sayısıyla gösterilemezse :exc:`OverflowError` hatası ortaya çıkar."

#: library/stdtypes.rst:553
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer.  If *byteorder* is ``\"big\"``, the most significant byte is at the "
"beginning of the byte array.  If *byteorder* is ``\"little\"``, the most "
"significant byte is at the end of the byte array.  To request the native "
"byte order of the host system, use :data:`sys.byteorder` as the byte order "
"value."
msgstr ""
"*byteorder* argümanı, tam sayıyı temsil etmek için kullanılan bayt sırasını "
"belirler.  *byteorder* ``\"big\"`` ise, en önemli bayt, bayt dizisinin "
"başındadır. *byteorder* ``\"little\"`` ise, en önemli bayt, bayt dizisinin "
"sonundadır. Ana sistemin yerel bayt sırasını istemek için bayt sırası değeri "
"olarak :data:`sys.byteorder` kullanın."

#: library/stdtypes.rst:528
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"*signed* argümanı, tam sayıyı temsil etmek için ikinin tümleyeninin "
"kullanılıp kullanılmayacağını belirler.  *signed* ``False`` ise ve negatif "
"bir tam sayı verilirse, bir :exc:`OverflowError` hatası ortaya çıkar. "
"*signed* için varsayılan değer ``False`` şeklindedir."

#: library/stdtypes.rst:537
msgid "Return the integer represented by the given array of bytes."
msgstr "Verilen bayt dizisi tarafından temsil edilen tam sayıyı döndürür."

#: library/stdtypes.rst:550
#, fuzzy
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"*bytes* argümanı ya bir :term:`bytes-like object` ya da yinelenebilir üreten "
"bayt olabilir."

#: library/stdtypes.rst:560
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"*signed* argümanı, tam sayıyı temsil etmek için ikinin tümleyeninin "
"kullanılıp kullanılmadığını gösterir."

#: library/stdtypes.rst:567
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"integer and with a positive denominator. The integer ratio of integers "
"(whole numbers) is always the integer as the numerator and ``1`` as the "
"denominator."
msgstr ""
"Oranı, orijinal tam sayıya tam olarak eşit ve pozitif bir paydaya sahip bir "
"tam sayı çifti döndürür. Integerlerin tam sayı oranı her zaman pay olarak "
"tam sayı ve payda olarak ``1`` dir."

#: library/stdtypes.rst:575
msgid "Additional Methods on Float"
msgstr "Gerçel Sayılarda Ek Metotlar"

#: library/stdtypes.rst:577
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"Float türü, :class:`numbers.Real` :term:`abstract base class` 'ı uygular. "
"Float ayrıca aşağıdaki ek metotlara sahiptir."

#: library/stdtypes.rst:582
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""
"Oranı tam olarak orijinal gerçel sayıya eşit ve pozitif bir paydaya sahip "
"bir çift tam sayı döndürür. Sonsuzluklarda :exc:`OverflowError` ve NaN'lerde "
"(SayıDeğil) :exc:`ValueError` hataları ortaya çıkar."

#: library/stdtypes.rst:589
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Float örneği integral değeriyle sonluysa ``True``, aksi takdirde ``False`` "
"döndürür::"

#: library/stdtypes.rst:597
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"İki yöntem, onaltılık dizelere dönüştürmeyi destekler. Python'un floatları "
"dahili olarak ikili sayılar olarak depolandığından, bir kayan noktayı "
"*decimal* (ondalık) dizgeye dönüştürmek veya bu karakter dizisinden "
"dönüştürmek genellikle küçük bir yuvarlama hatası içerir. Buna karşılık, "
"onaltılık diziler, gerçel sayıların tam olarak gösterilmesine ve "
"belirtilmesine izin verir. Bu, hata ayıklama sırasında ve sayısal "
"çalışmalarda yararlı olabilir."

#: library/stdtypes.rst:608
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Bir gerçel sayının temsilini, onaltılık bir dize olarak döndürür. Sonlu "
"gerçel sayılar için, bu gösterim her zaman başında bir ``0x`` ve sonunda bir "
"``p`` ve üs içerecektir."

#: library/stdtypes.rst:616
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Gerçel sayıyı temsil eden bir onaltılık dize *s*'yi döndüren için sınıf "
"(class) metodu. *s* dizesinin başında ve sonunda boşluk olabilir."

#: library/stdtypes.rst:621
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
":meth:`float.hex` 'in bir örnek (instance) metodu olduğunu, :meth:`float."
"fromhex` 'in ise bir sınıf (class) metodu olduğunu unutmayın."

#: library/stdtypes.rst:624
msgid "A hexadecimal string takes the form::"
msgstr "Onaltılık bir dize şu biçimi alır::"

#: library/stdtypes.rst:628
#, fuzzy
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"burada opsiyonel ``işaret``, ``+`` veya ``-`` olabilir; ``tam sayı`` ve "
"``kesir`` onaltılı basamaklı dizelerdir; ``üs`` opsiyonel ön işaretle "
"birlikte ondalık tam sayıdır.  Büyük/küçük harf önemli değildir ve tam sayı "
"veya kesirde en az bir onaltılık basamak olmalıdır.  Bu söz dizimi, C99 "
"standardının 6.4.4.2 bölümünde belirtilen söz dizimine ve ayrıca Java "
"1.5'ten itibaren kullanılan söz dizimine benzer.  Özellikle, :meth:`float."
"hex` 'in çıktısı, C veya Java kodunda bir onaltılık gerçel değişmezi olarak "
"kullanılabilir ve C'nin ``%a`` biçim karakteri veya Java'nın ``Double."
"toHexString`` 'i tarafından üretilen onaltılık dizeler :meth:`float.fromhex` "
"tarafından kabul edilir."

#: library/stdtypes.rst:641
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Üssün onaltılık değil ondalık olarak yazıldığına ve katsayıyı çarpmak için "
"2'nin gücünü verdiğine dikkat edin. Örneğin, ``0x3.a7p10`` onaltılık dizesi, "
"``(3 + 10./16 + 7./16**2) * 2.0**10`` veya ``3740.0`` gerçel sayısını temsil "
"eder::"

#: library/stdtypes.rst:651
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"``3740.0`` 'a ters dönüştürme uygulamak, aynı sayıyı temsil eden farklı bir "
"onaltılık dize verir::"

#: library/stdtypes.rst:661
msgid "Hashing of numeric types"
msgstr "Sayısal türlerin hashlemesi"

#: library/stdtypes.rst:663
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types (including :"
"class:`int`, :class:`float`, :class:`decimal.Decimal` and :class:`fractions."
"Fraction`) Python's hash for numeric types is based on a single mathematical "
"function that's defined for any rational number, and hence applies to all "
"instances of :class:`int` and :class:`fractions.Fraction`, and all finite "
"instances of :class:`float` and :class:`decimal.Decimal`.  Essentially, this "
"function is given by reduction modulo ``P`` for a fixed prime ``P``.  The "
"value of ``P`` is made available to Python as the :attr:`modulus` attribute "
"of :data:`sys.hash_info`."
msgstr ""
"Muhtemelen farklı türlerdeki ``x`` ve ``y`` sayıları için, ``x == y`` "
"olduğunda ``hash(x) == hash(y)`` olması bir gerekliliktir (bkz. :meth:"
"`~object.__hash__`). Çeşitli sayısal türler arasında uygulama kolaylığı ve "
"verimlilik için (:class:`int`, :class:`float`, :class:`decimal.Decimal` ve :"
"class:`fractions.Fraction` dahil) Python'un sayısal türler için hash'i, "
"herhangi bir rasyonel sayı için tanımlanmış tek bir matematiksel fonksiyona "
"dayanır ve bu nedenle :class:`int` ve :class:`fractions.Fraction` 'ın tüm "
"örnekleri ve :class:`float` ve :class:`decimal.Decimal` öğelerinin tüm sonlu "
"örnekleri için geçerlidir. Esasen, bu fonksiyon sabit bir asal sayı olan "
"``P`` için ``reduction modulo`` ``P`` ile verilir. ``P`` değeri Python'a :"
"data:`sys.hash_info` 'nun :attr:`modulus` özelliği olarak sunulur."

#: library/stdtypes.rst:678
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"Şu anda kullanılan asal sayı, 32 bit C uzunluğundaki makinelerde ``P = 2**31 "
"- 1`` ve 64-bit C uzunluğundaki makinelerde ``P = 2**61 - 1`` şeklindedir."

#: library/stdtypes.rst:681
msgid "Here are the rules in detail:"
msgstr "İşte ayrıntılı kurallar:"

#: library/stdtypes.rst:683
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"``x = m / n`` negatif olmayan bir rasyonel sayıysa ve ``n`` ``P`` ile "
"bölünemiyorsa, ``hash(x)`` 'i ``m * invmod(n, P) % P`` olarak tanımlayın, bu "
"durumda ``invmod(n, P)``, ``n`` modül ``P`` 'nin tersini verir."

#: library/stdtypes.rst:687
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"``x = m / n`` negatif olmayan bir rasyonel sayıysa ve ``n``, ``P`` ile "
"bölünebiliyorsa (ancak ``m`` değildir), o zaman ``n`` 'nin ``P`` şeklinde "
"ters modülü yoktur ve yukarıdaki kural geçerli değildir; bu durumda "
"``hash(x)`` i ``sys.hash_info.inf`` olarak tanımlayın."

#: library/stdtypes.rst:692
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"``x = m / n`` negatif bir rasyonel sayıysa, ``hash(x)`` 'i ``-hash(-x)`` "
"olarak tanımlayın. Elde edilen ``hash`` ``-1`` ise, bunu ``-2`` ile "
"değiştirin."

#: library/stdtypes.rst:696
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr ""
"``sys.hash_info.inf`` ve ``-sys.hash_info.inf``, pozitif sonsuz veya negatif "
"sonsuz (sırasıyla) için ``hash`` değerleri olarak kullanılır."

#: library/stdtypes.rst:700
#, fuzzy
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Bir :class:`complex` sayı ``z`` için, gerçek ve sanal parçaların ```hash`` "
"değerleri, ``hash(z.real) + sys.hash_info.imag * hash(z.imag)`` , ``reduced "
"modulo`` ``2**sys.hash_info.width`` hesaplanarak birleştirilir, böylece "
"``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))`` 'de "
"bulunur. Yine sonuç ``-1`` ise, ``-2`` ile değiştirilir."

#: library/stdtypes.rst:708
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"Yukarıdaki kuralları açıklığa kavuşturmak için, :class:`float` veya :class:"
"`complex` olan rasyonel bir sayının ``hash`` 'ini hesaplamak için gömülü "
"``hash`` 'e eş değer örnek Python kodu::"

#: library/stdtypes.rst:763
msgid "Iterator Types"
msgstr "Yineleyici Türleri"

#: library/stdtypes.rst:771
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python, konteynerler üzerinde yineleme kavramını destekler. Bu, iki farklı "
"metot kullanılarak uygulanır; bunlar, kullanıcı tanımlı sınıfların "
"yinelemeyi desteklemesine izin vermek için kullanılır. Aşağıda daha "
"ayrıntılı olarak açıklanan diziler, her zaman yineleme metotlarını destekler."

#: library/stdtypes.rst:776
msgid ""
"One method needs to be defined for container objects to provide :term:"
"`iterable` support:"
msgstr ""
"Container nesnelerinin :term:`iterable` desteği sağlaması için bir metodun "
"tanımlanması gerekir:"

#: library/stdtypes.rst:783
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"Bir :term:`iterator` nesnesi döndürür.  Nesnenin aşağıda açıklanan "
"yineleyici protokolünü desteklemesi gerekir.  Bir container, farklı yineleme "
"türlerini destekliyorsa, bu yineleme türleri için özel olarak yineleyiciler "
"istemek için ek yöntemler sağlanabilir.  (Birden çok yineleme biçimini "
"destekleyen bir nesneye örnek olarak hem genişlik öncelikli hem de derinlik "
"öncelikli geçişi destekleyen bir ağaç yapısı verilebilir.)  Bu metot, Python/"
"C API'sindeki Python nesneleri için tür yapısının :c:member:`~PyTypeObject."
"tp_iter` yuvasına karşılık gelir."

#: library/stdtypes.rst:792
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Yineleyici nesnelerinin kendilerinin, birlikte :dfn:`iterator protocol` 'ü "
"oluşturan aşağıdaki iki metodu desteklemesi gerekir:"

#: library/stdtypes.rst:798
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements.  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
":term:`iterator` nesnesinin kendisini döndürür.  Bu, hem containerların hem "
"de yineleyicilerin :keyword:`for` ve :keyword:`in` ifadeleriyle birlikte "
"kullanılmasına izin vermek için gereklidir.  Bu metot, Python/C API'sindeki "
"Python nesneleri için tür yapısının :c:member:`~PyTypeObject.tp_iter` "
"yuvasına karşılık gelir."

#: library/stdtypes.rst:807
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to "
"the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
":term:`iterator` 'den sonraki öğeyi döndürür.  Başka öğe yoksa, :exc:"
"`StopIteration` hatasını verir.  Bu metot, Python/C API'sindeki Python "
"nesneleri için tür yapısının :c:member:`~PyTypeObject.tp_iternext` yuvasına "
"karşılık gelir."

#: library/stdtypes.rst:812
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Python, genel ve özel dizi türleri, sözlükler ve diğer daha özel formlar "
"üzerinde yinelemeyi desteklemek için birkaç yineleyici nesnesi tanımlar.  "
"Belirli türler, yineleyici protokolünün uygulanmasının ötesinde önemli "
"değildir."

#: library/stdtypes.rst:817
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"Bir yineleyicinin :meth:`~iterator.__next__` metodu :exc:`StopIteration` "
"hatasını verdiğinde, sonraki çağrılarda bunu yapmaya devam etmelidir. Bu "
"özelliğe uymayan uygulamalar bozuk sayılır."

#: library/stdtypes.rst:825
msgid "Generator Types"
msgstr "Oluşturucu Tipleri"

#: library/stdtypes.rst:827
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`~generator.__next__` methods. More information about generators can be "
"found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""
"Python'un :term:`generator`\\s, yineleyici protokolünü uygulamak için uygun "
"bir yol sağlar.  Bir container nesnesinin :meth:`__iter__` metodu bir "
"oluşturucu olarak uygulanırsa, otomatik olarak :meth:`__iter__` ve :meth:"
"`~generator.__next__` metotlarını sağlayan bir yineleyici nesne (teknik "
"olarak bir oluşturucu nesnesi) döndürür. Oluşturucular hakkında daha fazla "
"bilgi :ref:`the documentation for the yield expression <yieldexpr>` "
"adresinde bulunabilir."

#: library/stdtypes.rst:839
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "Dizi Tipleri --- :class:`list`, :class:`tuple`, :class:`range`"

#: library/stdtypes.rst:841
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Üç temel dizi türü vardır: listeler, demetler ve aralık nesneleri. :ref:"
"`binary data <binaryseq>` ve :ref:`text strings <textseq>` 'in işlenmesi "
"için uyarlanmış ek dizi türleri, özel bölümlerde açıklanmıştır."

#: library/stdtypes.rst:850
msgid "Common Sequence Operations"
msgstr "Yaygın Dizi İşlemleri"

#: library/stdtypes.rst:854
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"Aşağıdaki tablodaki işlemler, hem değiştirilebilir hem de değiştirilemez "
"olan çoğu dizi türü tarafından desteklenir. :class:`collections.abc."
"Sequence` ABC, bu işlemleri özel dize türlerinde doğru şekilde uygulamayı "
"kolaylaştırmak için sağlanmıştır."

#: library/stdtypes.rst:859
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"Bu tablo artan önceliğe göre sıralanmış dizi işlemlerini listeler.  Tabloda "
"*s* ve *t* aynı türden dizilerdir, *n*, *i*, *j* ve *k* tam sayılardır ve "
"*x*, *s* tarafından dayatılan her tür ve değer kısıtlamasını karşılayan "
"isteğe bağlı bir nesnedir."

#: library/stdtypes.rst:864
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"``in`` ve ``not in`` işlemleri, karşılaştırma işlemleriyle aynı önceliklere "
"sahiptir. ``+`` (birleştirme) ve ``*`` (yineleme) işlemleri, karşılık gelen "
"sayısal işlemlerle aynı önceliğe sahiptir. [3]_"

#: library/stdtypes.rst:885
msgid "``x in s``"
msgstr "``x in s``"

#: library/stdtypes.rst:885
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "*s* 'nin bir öğesi *x* 'e eşitse ``True``, aksi takdirde ``False``"

#: library/stdtypes.rst:888
msgid "``x not in s``"
msgstr "``x not in s``"

#: library/stdtypes.rst:888
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "*s* 'nin bir öğesi *x* 'e eşitse ``False``, aksi taktirde ``True``"

#: library/stdtypes.rst:891
msgid "``s + t``"
msgstr "``s + t``"

#: library/stdtypes.rst:891
msgid "the concatenation of *s* and *t*"
msgstr "*s* ve *t* 'nin birleşimi"

#: library/stdtypes.rst:891
msgid "(6)(7)"
msgstr "(6)(7)"

#: library/stdtypes.rst:894
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` veya ``n * s``"

#: library/stdtypes.rst:894
msgid "equivalent to adding *s* to itself *n* times"
msgstr "*s* 'yi kendisine *n* kez eklemeye eş değer"

#: library/stdtypes.rst:894
msgid "(2)(7)"
msgstr "(2)(7)"

#: library/stdtypes.rst:897
msgid "``s[i]``"
msgstr "``s[i]``"

#: library/stdtypes.rst:897
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*s* 'nin *i*\\ 'inci öğesi, orijin 0"

#: library/stdtypes.rst:899
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: library/stdtypes.rst:899
msgid "slice of *s* from *i* to *j*"
msgstr "*s* 'nin *i* 'den *j* 'ye kadar olan dilimi"

#: library/stdtypes.rst:899
msgid "(3)(4)"
msgstr "(3)(4)"

#: library/stdtypes.rst:901
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: library/stdtypes.rst:901
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr ""
"*s* 'nin *i* 'den *j* 'ye kadar olan dilimi, *k* 'lik adımlarla (örneğin *k* "
"= 2 ise, ikişer ikişer)"

#: library/stdtypes.rst:901
msgid "(3)(5)"
msgstr "(3)(5)"

#: library/stdtypes.rst:904
msgid "``len(s)``"
msgstr "``len(s)``"

#: library/stdtypes.rst:904
msgid "length of *s*"
msgstr "*s* 'nin uzunluğu"

#: library/stdtypes.rst:906
msgid "``min(s)``"
msgstr "``min(s)``"

#: library/stdtypes.rst:906
msgid "smallest item of *s*"
msgstr "*s* 'nin en küçük öğesi"

#: library/stdtypes.rst:908
msgid "``max(s)``"
msgstr "``max(s)``"

#: library/stdtypes.rst:908
msgid "largest item of *s*"
msgstr "*s* 'nin en büyük öğesi"

#: library/stdtypes.rst:910
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: library/stdtypes.rst:910
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"*x* 'in *s* içindeki ilk görüldüğü dizini (*i* dizininde veya sonrasında ve "
"*j* dizininden önce)"

#: library/stdtypes.rst:3551
msgid "\\(8)"
msgstr "\\(8)"

#: library/stdtypes.rst:914
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: library/stdtypes.rst:914
msgid "total number of occurrences of *x* in *s*"
msgstr "*s* 'de *x*'in toplam görülme sayısı"

#: library/stdtypes.rst:918
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"Aynı türden diziler de karşılaştırmaları destekler. Özellikle, demetler ve "
"listeler, karşılık gelen öğeler ile sözlükbilimsel olarak karşılaştırılır. "
"Bu, eşit karşılaştırma yapılabilmesi için her öğenin eşit olarak "
"karşılaştırması gerektiği ve iki dizinin aynı türde ve aynı uzunlukta olması "
"gerektiği anlamına gelir. (Tüm ayrıntılar için dil referansındaki :ref:"
"`comparisons` bölümüne bakın.)"

#: library/stdtypes.rst:928
msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index "
"drops below zero)."
msgstr ""

#: library/stdtypes.rst:937
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"``in`` ve ``not in`` işlemleri, genel durumda yalnızca basit sınırlama testi "
"için kullanılırken, bazı özel diziler (örneğin: :class:`str`, :class:`bytes` "
"ve :class:`bytearray`) bunları sonraki dizi testi için de kullanır:"

#: library/stdtypes.rst:946
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"*n* 'nin ```0`` 'dan küçük değerleri ``0`` olarak değerlendirilir (bu, *s* "
"ile aynı türde boş bir dizi verir). *s* dizisindeki öğeler kopyalanmaz, "
"birden çok kez referans gösterilir (kullanılır).  Bu, çoğunlukla yeni Python "
"programcılarına musallat olur; şunu düşünün::"

#: library/stdtypes.rst:958
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"Olan şu ki, ``[[]]`` boş bir liste içeren tek elemanlı bir listedir, "
"dolayısıyla ``[[]] * 3`` 'ün üç elemanı da bu boş listeye referanstır.  "
"``lists`` öğelerinin herhangi birinin değiştirilmesi bu listeyi değiştirir. "
"Bu şekilde farklı listelerin bir listesini oluşturabilirsiniz::"

#: library/stdtypes.rst:970
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"Daha fazla açıklama SSS gönderisinde mevcuttur: :ref:`faq-multidimensional-"
"list`."

#: library/stdtypes.rst:974
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"*i* veya *j* negatifse, dizin *s*: dizisinin sonuna göredir: ``len(s) + i`` "
"veya ``len(s) + j`` değiştirilir.  Ancak ``-0`` 'ın hala ``0`` olduğuna "
"dikkat edin."

#: library/stdtypes.rst:979
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"*s* 'nin *i* ile *j* arasındaki dilimi, ```i <= k < j`` olacak şekilde *k* "
"indeksine sahip öğelerin dizisi olarak tanımlanır.  *i* veya *j* ``len(s)`` "
"'den büyükse,``len(s)`` kullanın.  *i* atlanırsa veya ``None`` ise, ``0`` "
"kullanın.  *j* atlanırsa veya ``None`` ise, ``len(s)`` kullanın. *i*, *j* "
"'den büyük veya ona eşitse, dilim boştur."

#: library/stdtypes.rst:986
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""

#: library/stdtypes.rst:997
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"Değiştirilemez dizileri birleştirmek her zaman yeni bir nesneyle "
"sonuçlanır.  Bu, tekrarlanan birleştirme ile bir dizi oluşturmanın, toplam "
"dizi uzunluğunda ikinci dereceden bir çalışma zamanı maliyetine sahip "
"olacağı anlamına gelir.  Doğrusal bir çalışma zamanı maliyeti elde etmek "
"için aşağıdaki alternatiflerden birine geçmelisiniz:"

#: library/stdtypes.rst:1002
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
":class:`str` nesnelerini birleştiriyorsanız, bir liste oluşturabilir ve "
"sonunda :meth:`str.join` kullanabilir veya bir :class:`io.StringIO` örneğine "
"yazabilir ve tamamlandığında değerini alabilirsiniz"

#: library/stdtypes.rst:1006
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
":class:`bytes` nesnelerini birleştiriyorsanız, benzer şekilde :meth:`bytes."
"join` veya :class:`io.BytesIO` kullanabilir veya bir :class:`bytearray` "
"nesnesiyle yerinde birleştirme yapabilirsiniz.  :class:`bytearray` nesneleri "
"değiştirilebilirdir ve verimli bir aşırı tahsis mekanizmasına sahiptir"

#: library/stdtypes.rst:1011
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
":class:`tuple` nesneleri birleştiriyorsanız, bunun yerine bir :class:`list` "
"öğesini genişletin"

#: library/stdtypes.rst:1013
msgid "for other types, investigate the relevant class documentation"
msgstr "diğer türler için ilgili sınıf dokümantasyonunu inceleyin"

#: library/stdtypes.rst:1017
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Bazı dizi türleri (örneğin :class:`range`) yalnızca belirli kalıpları takip "
"eden öğe dizilerini destekler ve bu nedenle dizi birleştirmeyi veya "
"tekrarlamayı desteklemez."

#: library/stdtypes.rst:1022
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"*s* içinde *x* bulunmadığında ``index`` :exc:`ValueError` hatasını verir. "
"Tüm uygulamalar *i* ve *j* ek argümanlarının iletilmesini desteklemez. Bu "
"argümanlar, dizinin alt bölümlerinin verimli bir şekilde aranmasını sağlar. "
"Fazladan argümanları iletmek kabaca ``s[i:j].index(x)`` kullanmaya eş "
"değerdir, yalnızca herhangi bir veri kopyalamadan ve döndürülen index "
"dilimin başlangıcından ziyade dizinin başlangıcına göredir."

#: library/stdtypes.rst:1033
msgid "Immutable Sequence Types"
msgstr "Değiştirilemez Dizi Tipleri"

#: library/stdtypes.rst:1040
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"Değiştirilemez dizi türlerinin genellikle uyguladığı ve aynı zamanda "
"değişken dizi türleri tarafından uygulanmayan tek işlem, gömülü :func:`hash` "
"desteğidir."

#: library/stdtypes.rst:1044
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Bu destek, :class:`tuple` örnekleri gibi değiştirilemez dizilerin :class:"
"`dict` anahtarları olarak kullanılmasına, :class:`set` ve :class:`frozenset` "
"örneklerinde saklanmasına izin verir."

#: library/stdtypes.rst:1048
#, fuzzy
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Hash edilemez değerler içeren değiştirilemez bir diziyi hashlemeye çalışmak :"
"exc:`TypeError` ile sonuçlanır."

#: library/stdtypes.rst:1055
msgid "Mutable Sequence Types"
msgstr "Değiştirilebilir Dizi Tipleri"

#: library/stdtypes.rst:1062
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"Aşağıdaki tabloda yer alan işlemler değiştirilebilir dizi tiplerinde "
"tanımlanmıştır. :class:`collections.abc.MutableSequence` ABC, bu işlemleri "
"özel dizi türlerinde doğru şekilde uygulamayı kolaylaştırmak için "
"sağlanmıştır."

#: library/stdtypes.rst:1066
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"Tabloda *s* değiştirilebilir bir dizi türünün bir örneğidir, *t* "
"yinelenebilir herhangi bir nesnedir ve *x*, *s* tarafından dayatılan "
"herhangi bir tür ve değer kısıtlamasını karşılayan rastgele bir nesnedir "
"(örneğin, :class:`bytearray` yalnızca ``0 <= x <= 255`` değer kısıtlamasını "
"karşılayan tam sayıları kabul eder)."

#: library/stdtypes.rst:1090
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: library/stdtypes.rst:1090
msgid "item *i* of *s* is replaced by *x*"
msgstr "*s* 'nin *i* öğesi *x* ile değiştirilir"

#: library/stdtypes.rst:1093
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: library/stdtypes.rst:1093
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"*s* 'nin *i* ile *j* arasındaki dilimi, yinelenebilir *t* içeriğiyle "
"değiştirilir"

#: library/stdtypes.rst:1097
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: library/stdtypes.rst:1097
msgid "same as ``s[i:j] = []``"
msgstr "``s[i:j] = []`` ile eş değerdir"

#: library/stdtypes.rst:1099
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: library/stdtypes.rst:1099
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "``s[i:j:k]`` 'nin öğelerinin yerini *t* öğelerininkiler alır"

#: library/stdtypes.rst:1102
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: library/stdtypes.rst:1102
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "``s[i:j:k]`` 'nin öğelerini listeden kaldırır"

#: library/stdtypes.rst:1105
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: library/stdtypes.rst:1105
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr "dizinin sonuna *x* ekler (``s[len(s):len(s)] = [x]`` ile eş değerdir)"

#: library/stdtypes.rst:1109
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: library/stdtypes.rst:1109
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "*s* içindeki tüm öğeleri kaldırır (``del s[:]`` ile eş değerdir)"

#: library/stdtypes.rst:1112
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: library/stdtypes.rst:1112
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "*s*'nin sığ bir kopyasını oluşturur (``s[:]`` ile eş değerdir)"

#: library/stdtypes.rst:1115
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` veya ``s += t``"

#: library/stdtypes.rst:1115
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""
"*s* 'yi *t* 'nin içeriğiyle genişletir (çoğunlukla ``s[len(s):len(s)] = t`` "
"ile eş değerdir)"

#: library/stdtypes.rst:1120
msgid "``s *= n``"
msgstr "``s *= n``"

#: library/stdtypes.rst:1120
msgid "updates *s* with its contents repeated *n* times"
msgstr "*n* kez tekrarlanan içeriğiyle *s* 'yi günceller"

#: library/stdtypes.rst:1123
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: library/stdtypes.rst:1123
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""
"*i* tarafından verilen dizinde *s* 'nin içine *x* ekler (``s[i:i] = [x]`` "
"ile eş değerdir)"

#: library/stdtypes.rst:1127
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` veya ``s.pop(i)``"

#: library/stdtypes.rst:1127
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "*i* noktasındaki öğeyi alır ve *s* öğesinden kaldırır"

#: library/stdtypes.rst:1130
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: library/stdtypes.rst:1130
#, fuzzy
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "``s[i]`` 'nin *x* 'e eşit olduğu *s* 'den ilk öğeyi kaldırır"

#: library/stdtypes.rst:1133
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: library/stdtypes.rst:1133
msgid "reverses the items of *s* in place"
msgstr "*s* 'nin öğelerini yerinde tersine çevirir"

#: library/stdtypes.rst:1141
msgid "*t* must have the same length as the slice it is replacing."
msgstr "*t*, değiştirdiği dilimle aynı uzunlukta olmalıdır."

#: library/stdtypes.rst:1144
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"İsteğe bağlı *i* argümanı varsayılan olarak ``-1`` şeklindedir, böylece "
"varsayılan olarak son öğe kaldırılır ve döndürülür."

#: library/stdtypes.rst:1148
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""
"*s* 'nin içinde *x* bulunmadığında :meth:`remove` işlemi :exc:`ValueError` "
"hatasını verir."

#: library/stdtypes.rst:1151
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
":meth:`reverse` metodu, büyük bir diziyi tersine çevirirken yerden tasarruf "
"sağlamak için diziyi yerinde değiştirir. Kullanıcılara yan etki ile "
"çalıştığını hatırlatmak için ters diziyi döndürmez."

#: library/stdtypes.rst:1156
#, fuzzy
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""
":meth:`clear` ve :meth:`!copy`, dilimleme işlemlerini desteklemeyen "
"değiştirilebilir containerların (örneğin :class:`dict` ve :class:`set` gibi) "
"arayüzleriyle tutarlılık için dahil edilmiştir. :meth:`!copy`, :class:"
"`collections.abc.MutableSequence` ABC'nin bir parçası değildir, ancak çoğu "
"somut değiştirilebilir dizi sınıfı bunu sağlar."

#: library/stdtypes.rst:1162
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr ":meth:`clear` ve :meth:`!copy` metotları."

#: library/stdtypes.rst:1166
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"*n* değeri bir tam sayıdır veya :meth:`~object.__index__` uygulayan bir "
"nesnedir.  *n* 'nin sıfır ve negatif değerleri diziyi temizler.  Dizideki "
"öğeler kopyalanmaz; :ref:`typesseq-common` altında ```s * n`` için "
"açıklandığı gibi, bunlara birden çok kez başvurulur."

#: library/stdtypes.rst:1175
msgid "Lists"
msgstr "Listeler"

#: library/stdtypes.rst:1179
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"Listeler, tipik olarak (kesin benzerlik derecesinin uygulamaya göre "
"değişeceği) homojen öğelerin koleksiyonlarını depolamak için kullanılan "
"değiştirilebilir dizilerdir."

#: library/stdtypes.rst:1185
msgid "Lists may be constructed in several ways:"
msgstr "Listeler birkaç şekilde oluşturulabilir:"

#: library/stdtypes.rst:1187
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr "Boş listeyi belirtmek için bir çift köşeli parantez kullanma: ``[]``"

#: library/stdtypes.rst:1188
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Köşeli parantez kullanarak, öğeleri virgülle ayırarak: ``[a]``, ``[a, b, c]``"

#: library/stdtypes.rst:1189
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "Liste kavrayışını kullanma: ``[x for x in iterable]``"

#: library/stdtypes.rst:1190
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "Tür oluşturucuyu kullanma: ``list()`` veya ``list(iterable)``"

#: library/stdtypes.rst:1192
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"Yapıcı, öğeleri *iterable* 'ın öğeleriyle aynı ve aynı sırada olan bir liste "
"oluşturur.  *iterable*; bir dizi, yinelemeyi destekleyen bir container veya "
"yineleyici nesne olabilir.  *iterable* zaten bir listeyse, ``iterable[:]`` "
"'e benzer şekilde bir kopya oluşturulur ve döndürülür. Örneğin, "
"``list('abc')``, ``['a', 'b', 'c']`` değerini döndürür ve ``list( (1, 2, "
"3) )``, ``[ 1, 2, 3]``. Argüman verilmezse, yapıcı ``[]`` yeni bir boş liste "
"oluşturur."

#: library/stdtypes.rst:1201
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"Gömülü :func:`sorted` dahil olmak üzere diğer birçok işlem de listeler "
"üretir."

#: library/stdtypes.rst:1204
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Listeler, tüm :ref:`common <typesseq-common>` ve :ref:`mutable <typesseq-"
"mutable>` dizi işlemlerini uygular. Listeler ayrıca aşağıdaki ek metodu da "
"sağlar:"

#: library/stdtypes.rst:1210
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Bu metot, öğeler arasında yalnızca ``<`` karşılaştırmalarını kullanarak "
"listeyi yerinde sıralar. Hatalar bastırılmaz - herhangi bir karşılaştırma "
"işlemi başarısız olursa, tüm sıralama işlemi başarısız olur (ve liste büyük "
"olasılıkla kısmen değiştirilmiş durumda kalır)."

#: library/stdtypes.rst:1215
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` yalnızca anahtar kelime tarafından iletilebilen iki argümanı "
"kabul eder (:ref:`keyword-only arguments <keyword-only_parameter>`):"

#: library/stdtypes.rst:1218
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"*key*, her liste öğesinden bir karşılaştırma anahtarı çıkarmak için "
"kullanılan bir argümanın işlevini belirtir (örneğin, ``key=str.lower``). "
"Listedeki her bir öğeye karşılık gelen anahtar bir kez hesaplanır ve "
"ardından tüm sıralama işlemi için kullanılır. Varsayılan değer olan "
"``None``, liste öğelerinin ayrı bir anahtar değeri hesaplamadan doğrudan "
"sıralandığı anlamına gelir."

#: library/stdtypes.rst:1225
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
":func:`functools.cmp_to_key` yardımcı programı, 2.x stili *cmp* işlevini bir "
"*key* işlevine dönüştürmek için kullanılabilir."

#: library/stdtypes.rst:1228
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* bir boolean değeridir. ``True`` olarak ayarlanırsa, liste öğeleri, "
"her karşılaştırma tersine çevrilmiş gibi sıralanır."

#: library/stdtypes.rst:1231
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Bu yöntem, büyük bir diziyi sıralarken yerden tasarruf sağlamak için diziyi "
"yerinde değiştirir. Kullanıcılara yan etki ile çalıştığını hatırlatmak için, "
"sıralanan diziyi döndürmez (açıkça yeni bir sıralanmış liste örneği istemek "
"için :func:`sorted` kullanın)."

#: library/stdtypes.rst:1236
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
":meth:`sort` metodunun kararlı olduğu garanti edilir.  Bir sıralama, eşit "
"olarak karşılaştırılan öğelerin göreli sırasını değiştirmemeyi garanti "
"ediyorsa kararlıdır --- bu, birden çok geçişte sıralama için yararlıdır "
"(örneğin, departmana göre sıralama, ardından maaş derecesine göre)."

#: library/stdtypes.rst:1241
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Sıralama örnekleri ve kısa bir sıralama eğitimi için bkz. :ref:"
"`sortinghowto`."

#: library/stdtypes.rst:1245
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"Bir liste sıralanırken, listeyi değiştirmeye ve hatta incelemeye çalışmanın "
"etkisi tanımsızdır. Python'un C uygulaması, listenin süre boyunca boş "
"görünmesini sağlar ve bir sıralama sırasında listenin mutasyona uğradığını "
"algılayabilirse :exc:`ValueError` hatasını verir."

#: library/stdtypes.rst:1254
msgid "Tuples"
msgstr "Demetler"

#: library/stdtypes.rst:1258
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Tuple'lar, tipik olarak heterojen veri koleksiyonlarını depolamak için "
"kullanılan değiştirilemez dizilerdir (örneğin, gömülü :func:`enumerate` "
"tarafından üretilen 2 tuple). Tuple'lar, değiştirilemez bir homojen veri "
"dizisinin gerekli olduğu durumlarda da kullanılır (bir :class:`set` veya :"
"class:`dict` örneğinde depolamaya izin vermek gibi)."

#: library/stdtypes.rst:1266
msgid "Tuples may be constructed in a number of ways:"
msgstr "Tuple'lar çeşitli şekillerde oluşturulabilir:"

#: library/stdtypes.rst:1268
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr "Boş demeti belirtmek için bir çift parantez kullanma: ``()``"

#: library/stdtypes.rst:1269
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr "Tekli bir tuple için sonunda virgül kullanma: ``a,`` veya ``(a,)``"

#: library/stdtypes.rst:1270
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "Öğeleri virgülle ayırma: ``a, b, c`` veya ``(a, b, c)``"

#: library/stdtypes.rst:1271
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr "Gömülü :func:`tuple` kullanmak: ``tuple()`` veya ``tuple(iterable)``"

#: library/stdtypes.rst:1273
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"Yapıcı, öğeleri *iterable* öğeleriyle aynı ve aynı sırada olan bir demet "
"oluşturur.  *iterable* bir dizi, yinelemeyi destekleyen bir container veya "
"yineleyici nesne olabilir.  *iterable* zaten bir tuple ise, değiştirilmeden "
"döndürülür. Örneğin, ``tuple('abc')``, ``('a', 'b', 'c')`` 'yi ve "
"``tuple( [1, 2, 3] )``, ``(1, 2, 3)`` 'yi döndürür. Herhangi bir argüman "
"verilmezse, yapıcı yeni bir boş demet oluşturur ``()``."

#: library/stdtypes.rst:1281
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Bir demeti oluşturanın aslında parantez değil virgül olduğuna dikkat edin. "
"Boş demet durumunda veya söz dizimsel belirsizliği önlemek için gerektiğinde "
"parantezler isteğe bağlıdır. Örneğin, ``f(a, b, c)`` üç argümanlı bir "
"fonksiyon çağrısı iken ``f((a, b, c))``, tek argüman olarak 3'lü bir tuple "
"içeren bir fonksiyon çağrısıdır."

#: library/stdtypes.rst:1287
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Tuple'lar, tüm :ref:`common <typesseq-common>` dizi işlemlerini uygular."

#: library/stdtypes.rst:1290
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"Ada göre erişimin dizine göre erişimden daha net olduğu heterojen veri "
"koleksiyonları için, :func:`collections.namedtuple` basit bir tuple "
"nesnesinden daha uygun bir seçim olabilir."

#: library/stdtypes.rst:1298
msgid "Ranges"
msgstr "Aralıklar"

#: library/stdtypes.rst:1302
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
":class:`range` türü, değiştirilemez bir sayı dizisini temsil eder ve "
"genellikle :keyword:`for` döngülerinde belirli sayıda döngü yapmak için "
"kullanılır."

#: library/stdtypes.rst:1309
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is "
"zero, :exc:`ValueError` is raised."
msgstr ""
"Aralık oluşturucunun argümanları tamsayı olmalıdır (gömülü :class:`int` "
"veya :meth:`~object.__index__` özel metodunu uygulayan herhangi bir nesne). "
"*step* argümanı atlanırsa, varsayılan olarak ``1`` olur. *start* argümanı "
"atlanırsa, varsayılan olarak ``0`` olur. *step* sıfırsa, :exc:`ValueError` "
"hatası ortaya çıkar."

#: library/stdtypes.rst:1315
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Pozitif *step* için, ``r`` aralığının içeriği, ``i >= 0`` ve ``r[i] < stop`` "
"olmak üzere ``r[i] = start + step*i`` formülüyle belirlenir."

#: library/stdtypes.rst:1319
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"Negatif bir *step* için, aralığın içeriği hala ``r[i] = start + step*i`` "
"formülüyle belirlenir, ancak kısıtlamalar ``i >= 0`` ve ``r[i] > stop`` 'dir."

#: library/stdtypes.rst:1323
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Bir aralık nesnesi ``r[0]`` değer kısıtlamasını karşılamıyorsa, boş "
"olacaktır. Aralıklar negatif indeksleri destekler, ancak bunlar pozitif "
"indeksler tarafından belirlenen dizinin sonundan indeksleme olarak "
"yorumlanır."

#: library/stdtypes.rst:1328
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
":data:`sys.maxsize` 'dan büyük mutlak değerler içeren aralıklara izin "
"verilir, ancak bazı özellikler (:func:`len` gibi), :exc:`OverflowError` "
"hatasınının ortaya çıkmasını sağlayabilir."

#: library/stdtypes.rst:1332
msgid "Range examples::"
msgstr "Aralık örnekleri::"

#: library/stdtypes.rst:1349
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"Aralıklar, birleştirme ve tekrar dışında tüm :ref:`common <typesseq-common>` "
"dizi işlemlerini uygular (aralık nesnelerinin yalnızca katı bir kalıp "
"izleyen dizileri temsil edebilmesi ve tekrarlama ve birleştirmenin "
"genellikle bu kalıbı ihlal etmesi nedeniyle)."

#: library/stdtypes.rst:1356
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr "*start* parametresinin değeri (veya parametre sağlanmadıysa ``0``)"

#: library/stdtypes.rst:1361
msgid "The value of the *stop* parameter"
msgstr "*stop* parametresinin değeri"

#: library/stdtypes.rst:1365
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr "*step* parametresinin değeri (veya parametre sağlanmadıysa ``1``)"

#: library/stdtypes.rst:1368
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
":class:`range` türünün normal bir :class:`list` veya :class:`tuple` "
"üzerindeki avantajı, bir :class:`range` nesnesinin temsil ettiği aralığın "
"boyutu ne olursa olsun her zaman aynı (küçük) miktarda bellek almasıdır "
"(yalnızca ``start``, ``stop`` ve ``step`` değerlerini sakladığı için, tek "
"tek öğeleri ve alt aralıkları gerektiği gibi hesaplar)."

#: library/stdtypes.rst:1374
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Aralık (range) nesneleri :class:`collections.abc.Sequence` ABC'sini uygular "
"ve sınırlama testleri, eleman indeksi araması, dilimleme ve negatif "
"indeksler için destek gibi özellikler sağlar (bkz. :ref:`typesseq`):"

#: library/stdtypes.rst:1394
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"Aralık nesnelerini ``==`` ve ``!=`` ile eşitlik açısından test etmek, "
"bunları diziler olarak karşılaştırır. Yani, aynı değer dizisini temsil "
"ediyorlarsa, iki aralık nesnesi eşit kabul edilir.  (Eşit karşılaştıran iki "
"aralık nesnesinin farklı :attr:`~range.start`, :attr:`~range.stop` ve :attr:"
"`~range.step` niteliklerine sahip olabileceğini unutmayın, örneğin "
"``range(0) == range(2, 1, 3)`` veya ``range(0, 3, 2) == range(0, 4, 2)``.)"

#: library/stdtypes.rst:1401
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Dizi ABC'sini uygular, Dilimleme ve negatif indekslemeyi destekler, Tüm "
"öğeleri yinelemek yerine sabit zamanda üyelik için :class:`int` nesnelerini "
"test eder."

#: library/stdtypes.rst:1407
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"Aralık nesnelerini tanımladıkları değer sırasına göre karşılaştırmak için "
"'==' ve '!=' tanımlayın (nesne kimliğine göre karşılaştırmak yerine)."

#: library/stdtypes.rst:1412
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
":attr:`~range.start`, :attr:`~range.stop` ve :attr:`~range.step` özellikleri."

#: library/stdtypes.rst:1418
#, fuzzy
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000/>`_ shows "
"how to implement a lazy version of range suitable for floating point "
"applications."
msgstr ""
"`Linspace tarifi <http://code.activestate.com/recipes/579000/>`_ , kayan "
"nokta uygulamaları için uygun olan tembel bir aralığın nasıl uygulanacağını "
"gösterir."

#: library/stdtypes.rst:1430
msgid "Text Sequence Type --- :class:`str`"
msgstr "Metin Sırası Türü --- :class:`str`"

#: library/stdtypes.rst:1432
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"Python'da metinsel veriler :class:`str` nesneleri veya :dfn:`strings` ile "
"işlenir. Dizeler, Unicode kod noktalarının değişmez :ref:`dizgeleridir "
"<typesseq>`. Dize değişmezleri çeşitli şekillerde yazılır:"

#: library/stdtypes.rst:1437
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Tek tırnak: ``'katıştırılmış \"çift\" tırnaklara izin verir'``"

#: library/stdtypes.rst:1438
#, fuzzy
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "Çift tırnak: ``\"katıştırılmış 'tek' tırnaklara izin verir\"``."

#: library/stdtypes.rst:1439
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double quotes"
"\"\"\"``"
msgstr "Üçlü tırnak: ``'''Üç tek tırnak'''``, ``\"\"\"Üç çift tırnak\"\"\"``"

#: library/stdtypes.rst:1441
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"Üçlü tırnak içine alınmış dizeler birden çok satıra yayılabilir - ilişkili "
"tüm boşluklar dize değişmezine dahil edilecektir."

#: library/stdtypes.rst:1444
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Tek bir ifadenin parçası olan ve aralarında yalnızca boşluk bulunan dize "
"değişmezleri, örtük olarak tek bir dize değişmezine dönüştürülür. Yani, "
"``(\"spam\" \"yumurtalar\") == \"spam yumurtalar\"``."

#: library/stdtypes.rst:1448
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that "
"disables most escape sequence processing."
msgstr ""
"Desteklenen kaçış dizileri ve çoğu kaçış dizisi işlemeyi devre dışı bırakan "
"``r`` (\"raw\", Türkçesiyle \"ham\") ön eki dahil olmak üzere dize "
"değişmezinin çeşitli biçimleri hakkında daha fazla bilgi için bkz. :ref:"
"`strings`."

#: library/stdtypes.rst:1452
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Dizeler, :class:`str` yapıcısı kullanılarak diğer nesnelerden de "
"oluşturulabilir."

#: library/stdtypes.rst:1455
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Ayrı bir \"karakter\" türü olmadığından, bir dizenin indekslenmesi 1 "
"uzunluğunda dizeler üretir. Yani, boş olmayan bir *s* dizesi için ``s[0] == "
"s[0:1]``."

#: library/stdtypes.rst:1461
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Değiştirilebilir bir dize türü de yoktur, ancak :meth:`str.join` veya :class:"
"`io.StringIO` birden çok parçadan dizeleri verimli bir şekilde oluşturmak "
"için kullanılabilir."

#: library/stdtypes.rst:1465
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Python 2 serisiyle geriye dönük uyumluluk için, dize değişmezlerinde ``u`` "
"ön ekine izin verilir. Bunun dize değişmezlerinin anlamı üzerinde hiçbir "
"etkisi yoktur ve ``r`` ön ekiyle birleştirilemez."

#: library/stdtypes.rst:1477
#, fuzzy
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"*nesne* 'nin :ref:`string <textseq>` sürümünü döndürür. *nesne* sağlanmazsa "
"boş dizeyi döndürür.  Aksi takdirde, ``str()`` davranışı, aşağıdaki gibi "
"*kodlama* veya *hatalar* 'ın verilmesine bağlıdır."

#: library/stdtypes.rst:1481
#, fuzzy
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" "
"or nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a :meth:`~object."
"__str__` method, then :func:`str` falls back to returning :meth:"
"`repr(object) <repr>`."
msgstr ""
"Ne *kodlama* ne de *hatalar* verilmezse, ``str(object)`` :meth:`object."
"__str__() <object.__str__>` döndürür; bu, *object* ifadesinin \"gayriresmi\" "
"veya güzel yazdırılabilir dize temsilidir. Dize nesneleri için bu, dizenin "
"kendisidir. *object*'in bir :meth:`~object.__str__` metodu yoksa, :func:"
"`str`, :meth:`repr(object) <repr>` döndürmeye geri döner."

#: library/stdtypes.rst:1493
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"*kodlama* veya *hatalar* 'dan en az biri verilirse, *nesne* bir :term:`bytes-"
"like object` olmalıdır (ör. :class:`bytes` veya :class:`bytearray`).  Bu "
"durumda, *nesne* bir :class:`bytes` (veya :class:`bytearray`) nesnesiyse "
"``str(bytes, *kodlama*, *hatalar*)``, :meth:`bytes.decode(*kodlama*, "
"*hatalar*) <bytes.decode>` 'a eşdeğerdir.  Aksi takdirde, arabellek "
"nesnesinin altında yatan bayt nesnesi, :meth:`bytes.decode` çağrılmadan önce "
"elde edilir.  Arabellek nesneleri hakkında bilgi için bkz. :ref:`binaryseq` "
"ve :ref:`bufferobjects`."

#: library/stdtypes.rst:1502
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Bir :class:`bytes` nesnesini *kodlama* veya *hatalar* argümanları olmadan :"
"func:`str` 'ye iletmek, gayriresmi dize temsilini döndürmenin ilk durumuna "
"girer (ayrıca bkz. Python için :option:`-b` komut satırı seçeneği).  "
"Örneğin::"

#: library/stdtypes.rst:1510
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"``str`` sınıfı ve metotları hakkında daha fazla bilgi için aşağıdaki :ref:"
"`textseq` ve :ref:`string-methods` bölümüne bakın.  Biçimlendirilmiş "
"dizelerin çıktısını almak için :ref:`f-strings` ve :ref:`formatstrings` "
"bölümlerine bakın.  Ayrıca, :ref:`stringservices` bölümüne de bakın."

#: library/stdtypes.rst:1522
msgid "String Methods"
msgstr "String (Dize) Metotları"

#: library/stdtypes.rst:1527
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Dizeler, aşağıda açıklanan ek yöntemlerle birlikte tüm :ref:`ortak <typesseq-"
"common>` dizi işlemlerini uygular."

#: library/stdtypes.rst:1530
#, fuzzy
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Ayrıca dizeler, biri büyük ölçüde esneklik ve özelleştirme sağlayan ve "
"diğeri daha dar bir tür aralığını işleyen (bkz. :meth:`str.format`, :ref:"
"`formatstrings` ve :ref:`string-formatting`) ve doğru kullanımı biraz daha "
"zor olan C ``printf`` stili biçimlendirmesine dayanan iki dize biçimlendirme "
"stilini destekler, ancak genellikle işleyebileceği durumlar için daha "
"hızlıdır (:ref:`old-string-formatting`)."

#: library/stdtypes.rst:1537
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"Standart kütüphanenin :ref:`textservices` bölümü, metinle ilgili çeşitli "
"yardımcı programlar sağlayan bir dizi başka modülü kapsar (:mod:`re` "
"modülündeki normal ifade desteği dahil)."

#: library/stdtypes.rst:1543
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""
"İlk karakteri büyük ve geri kalanı küçük harf ile, dizenin bir kopyasını "
"döndürür."

#: library/stdtypes.rst:1546
#, fuzzy
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""
"Dizenin ilk karakteri başlıklarda olduğu gibi büyük harfe çevrilir. Bu "
"digraf gibi karakterlerin, sadece ilk harflerinin büyütüleceği anlamına "
"gelir."

#: library/stdtypes.rst:1553
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Dizenin küçük harfe katlanmış bir kopyasını döndürür. Küçük harfe katlanmış "
"dizeler, büyük/küçük harfsiz eşleştirme için kullanılabilir."

#: library/stdtypes.rst:1556
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"Büyük harf katlama, harf küçültmeye (lowercasing) benzer ancak daha "
"agresiftir, çünkü bir dizedeki tüm büyük/küçük harf ayrımlarını kaldırmayı "
"amaçlar. Örneğin, Almanca küçük harf ``'ß'``, ``\"ss\"`` ile eşdeğerdir. "
"Zaten küçük harf olduğundan, :meth:`lower` ``'ß'`` için hiçbir şey yapmaz; :"
"meth:`casefold` onu ``\"ss\"`` biçimine dönüştürür."

#: library/stdtypes.rst:1562
msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"Casefolding algoritması, Unicode Standardının 3.13 bölümünde açıklanmıştır."

#: library/stdtypes.rst:1570
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"*width* uzunluğundaki bir dizede ortalanmış olarak döndürür. Doldurma, "
"belirtilen *fillchar* kullanılarak yapılır (varsayılanı bir ASCII "
"boşluğudur). *width*, ``len(s)`` değerinden küçük veya ona eşitse orijinal "
"dize döndürülür."

#: library/stdtypes.rst:1578
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"[*start*, *end*] aralığında *sub* alt dizesinin örtüşmeyen oluşumlarının "
"sayısını döndürür. İsteğe bağlı bağımsız değişkenler *start* ve *end*, dilim "
"notasyonunda olduğu gibi yorumlanır."

#: library/stdtypes.rst:1582
msgid ""
"If *sub* is empty, returns the number of empty strings between characters "
"which is the length of the string plus one."
msgstr ""

#: library/stdtypes.rst:1588
msgid ""
"Return an encoded version of the string as a bytes object. Default encoding "
"is ``'utf-8'``. *errors* may be given to set a different error handling "
"scheme. The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`. Other possible values are ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` and any other "
"name registered via :func:`codecs.register_error`, see section :ref:`error-"
"handlers`. For a list of possible encodings, see section :ref:`standard-"
"encodings`."
msgstr ""
"Bir bayt nesnesi olarak dizenin kodlanmış bir sürümünü döndürün. Varsayılan "
"kodlama ``'utf-8'`` şeklindedir. *hatalar*, farklı bir hata işleme şeması "
"ayarlamak için verilebilir. *Hatalar* için varsayılan değer ``'strict'`` "
"'dir, yani kodlama hataları bir :exc:`UnicodeError` ortaya çıkarır. Diğer "
"olası değerler ``'ignore'``, ``'replace'``, ``'xmlcharreplace'``, "
"``'backslashreplace'`` ve :func:`codecs.register_error` aracılığıyla "
"kaydedilen diğer herhangi bir addır, :ref:`error-handlers` bölümüne bakın. "
"Olası kodlamaların listesi için section :ref:`standard-encodings` bölümüne "
"bakın."

#: library/stdtypes.rst:1597
msgid ""
"By default, the *errors* argument is not checked for best performances, but "
"only used at the first encoding error. Enable the :ref:`Python Development "
"Mode <devmode>`, or use a :ref:`debug build <debug-build>` to check *errors*."
msgstr ""
"Varsayılan olarak, *error* argümanı en iyi performans için kontrol edilmez, "
"sadece ilk kodlama hatasında kullanılır. :ref:`Python Geliştirme Modu "
"<devmode>` öğesini etkinleştirin veya *hataları* kontrol etmek için bir :ref:"
"`hata ayıklama derlemesi <debug-build>` kullanın."

#: library/stdtypes.rst:1602
msgid "Support for keyword arguments added."
msgstr "Anahtar kelime argümanları için destek eklendi."

#: library/stdtypes.rst:2739
msgid ""
"The *errors* is now checked in development mode and in :ref:`debug mode "
"<debug-build>`."
msgstr ""
"*Hatalar* şimdi geliştirme modunda ve :ref:`hata ayıklama modunda <debug-"
"build>` kontrol edilir."

#: library/stdtypes.rst:1612
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"Dize belirtilen *suffix* ile bitiyorsa ``True``, aksi takdirde ```False`` "
"döndürün. *suffix* ayrıca aranacak bir son ek grubu da olabilir. İsteğe "
"bağlı *start* ile, o konumdan başlayarak test edin. İsteğe bağlı *end* ile, "
"o konumda karşılaştırmayı bırakın."

#: library/stdtypes.rst:1620
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline (``"
"\\n``) or return (``\\r``), it is copied and the current column is reset to "
"zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"Geçerli sütuna ve verilen tab boyutuna bağlı olarak, tüm tab karakterlerinin "
"bir veya daha fazla boşlukla değiştirildiği dizenin bir kopyasını döndürün.  "
"Tab konumları her *tab boyutu* karakterinde oluşur (varsayılan 8'dir, 0, 8, "
"16 ve benzeri sütunlarda tab konumları verilir).  Dizeyi genişletmek için "
"mevcut sütun sıfıra ayarlanır ve dize karakter karakter incelenir. Karakter "
"bir tab ise (``\\t``), geçerli sütun sonraki tab konumuna eşit olana kadar "
"sonuca bir veya daha fazla boşluk karakteri eklenir. (Tab karakterinin "
"kendisi kopyalanmaz.)  Karakter yeni satırsa (``\\n``) veya dönüşse (``"
"\\r``), kopyalanır ve mevcut sütun sıfırlanır.  Diğer herhangi bir karakter "
"değiştirilmeden kopyalanır ve mevcut sütun, karakterin yazdırıldığında nasıl "
"temsil edildiğine bakılmaksızın bir artırılır."

#: library/stdtypes.rst:1641
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"*sub* alt dizesinin ``s[start:end]`` diliminde bulunduğu dizedeki en düşük "
"dizini döndür.  İsteğe bağlı argümanlar *start* ve *end*, dilim notasyonunda "
"olduğu gibi yorumlanır. *sub* bulunamazsa ``-1`` döndürür."

#: library/stdtypes.rst:1647
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
":meth:`~str.find` metodu yalnızca *sub* öğesinin konumunu bilmeniz "
"gerekiyorsa kullanılmalıdır.  *sub* 'ın bir alt dize olup olmadığını kontrol "
"etmek için :keyword:`in` operatörünü kullanın::"

#: library/stdtypes.rst:1657
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"Bir dize biçimlendirme işlemi gerçekleştirin. Bu yöntemin çağrıldığı dize, "
"parantez ``{}`` ile sınırlandırılmış metin veya değiştirme alanları "
"içerebilir.  Her değiştirme alanı, ya bir konumsal (sırası önemli) argümanın "
"sayısal dizinini ya da bir anahtar sözcük argmünanının adını içerir. Her "
"değiştirme alanının, karşılık gelen argümanın dize değeriyle değiştirildiği "
"dizenin bir kopyasını döndürür."

#: library/stdtypes.rst:1667
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Biçim dizelerinde (f string) belirtilebilecek çeşitli biçimlendirme "
"seçeneklerinin açıklaması için bkz. :ref:`formatstrings`."

#: library/stdtypes.rst:1671
#, fuzzy
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"Bir sayıyı (:class:`int`, :class:`float`, :class:`complex`, :class:`decimal."
"Decimal` ve alt sınıfları) ``n`` tipiyle (ör``'{:n}'.format(1234)``) "
"biçimlendirirken, fonksiyon, eğer ASCII değillerse veya 1 bayttan uzunlarsa, "
"ve ``LC_NUMERIC``, ``LC_CTYPE`` yerel ayarından farklıysa, :c:func:"
"`localeconv` 'un alanları olan ``decimal_point`` ve ``thousands_sep`` 'i "
"çözmek için, \"LC_CTYPE\" yerel ayarını geçici olarak ``LC_NUMERIC`` yerel "
"ayarına atar. Bu geçici değişiklik diğer iş parçacıklarını da etkiler."

#: library/stdtypes.rst:1680
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"Bir sayıyı ``n`` türüyle biçimlendirirken, fonksiyon bazı durumlarda "
"``LC_CTYPE`` yerel ayarını geçici olarak ``LC_NUMERIC`` yerel ayarına "
"ayarlar."

#: library/stdtypes.rst:1688
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"``str.format(**mapping)`` ile benzerdir, ancak ``mapping`` doğrudan "
"kullanılır ve bir :class:`dict` 'e kopyalanmaz.  Örneğin, ``mapping`` bir "
"dict alt sınıfı ise bu kullanışlıdır:"

#: library/stdtypes.rst:1704
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
":meth:`~str.find` gibi, ancak alt dize bulunamadığında :exc:`ValueError` "
"yükseltir."

#: library/stdtypes.rst:1710
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Dizedeki tüm karakterler alfanümerikse ve en az bir karakter varsa ``True``, "
"aksi takdirde ``False`` döndürür.  Bir ``c`` karakteri, aşağıdakilerden biri "
"``True`` döndürüyorsa alfasayısaldır: ``c.isalpha()``, ``c.isdecimal()``, "
"``c.isdigit()`` veya ``c.isnumeric()``."

#: library/stdtypes.rst:1718
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", \"Lu"
"\", \"Ll\", or \"Lo\".  Note that this is different from the \"Alphabetic\" "
"property defined in the Unicode Standard."
msgstr ""
"Dizedeki tüm karakterler alfabetikse ve en az bir karakter varsa ``True``, "
"aksi takdirde ``False`` döndürür.  Alfabetik karakterler, Unicode karakter "
"veritabanında \"Harf\" olarak tanımlanan karakterlerdir, yani genel kategori "
"özelliği \"Lm\", \"Lt\", \"Lu\", \"Ll\" veya \"Lo \"dan biri olan "
"karakterlerdir.  Bunun Unicode Standardında tanımlanan \"Alfabetik\" "
"özelliğinden farklı olduğunu unutmayın."

#: library/stdtypes.rst:1727
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range U"
"+0000-U+007F."
msgstr ""
"Dize boşsa veya dizedeki tüm karakterler ASCII ise ``True``, aksi takdirde "
"``False`` döndürür. ASCII karakterleri U+0000-U+007F aralığında kod "
"noktalarına sahiptir."

#: library/stdtypes.rst:1736
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""
"Dizedeki tüm karakterler ondalık karakter ise ve en az bir karakter varsa "
"``True``, aksi takdirde ``False`` döndürür. Ondalık karakterler 10 tabanında "
"sayılar oluşturmak için kullanılabilen karakterlerdir, örneğin U+0660, "
"ARAPÇA-HİNTÇE RAKAM SIFIR.  Resmi olarak bir ondalık karakter Unicode Genel "
"Kategorisi \"Nd\" içerisindeki bir karakterdir."

#: library/stdtypes.rst:1746
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Dizedeki tüm karakterler rakamsa ve en az bir karakter varsa ``True``, aksi "
"takdirde ``False`` döndürür.  Rakamlar ondalık karakterleri ve özel işlem "
"gerektiren rakamları (uyumluluk üst simge rakamları gibi) içerir. Bu, "
"Kharosthi sayıları gibi 10 tabanında sayı oluşturmak için kullanılamayan "
"rakamları kapsar.  Resmi olarak rakam, Numeric_Type=Digit veya "
"Numeric_Type=Decimal özellik değerine sahip bir karakterdir."

#: library/stdtypes.rst:1756
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""
":ref:`identifiers` bölümüne göre dizge dil tanımına göre geçerli bir "
"tanımlayıcı ise ``True`` döndürür."

#: library/stdtypes.rst:1759
msgid ""
"Call :func:`keyword.iskeyword` to test whether string ``s`` is a reserved "
"identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
":func:`keyword.iskeyword` çağrısı yaparak ``s`` dizesinin :keyword:`def` ve :"
"keyword:`class` gibi ayrılmış bir tanımlayıcı olup olmadığını test eder."

#: library/stdtypes.rst:1762
msgid "Example: ::"
msgstr "Örnek: ::"

#: library/stdtypes.rst:1775
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Dizedeki tüm büyük harfli karakterler [4]_ küçük harfli ise ve en az bir "
"büyük harfli karakter varsa ``True``, aksi takdirde ``False`` döndürür."

#: library/stdtypes.rst:1781
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"Dizedeki tüm karakterler sayısal karakterlerse ve en az bir karakter varsa "
"``True``, aksi takdirde ``False`` döndürür. Sayısal karakterler rakam "
"karakterlerini ve Unicode sayısal değer özelliğine sahip tüm karakterleri "
"içerir, örneğin U+2155, VULGAR FRAKSİYONU BEŞİNCİ.  Resmi olarak, sayısal "
"karakterler Numeric_Type=Digit, Numeric_Type=Decimal veya "
"Numeric_Type=Numeric özellik değerine sahip karakterlerdir."

#: library/stdtypes.rst:1791
msgid ""
"Return ``True`` if all characters in the string are printable or the string "
"is empty, ``False`` otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Dizedeki tüm karakterler yazdırılabilirse veya dize boşsa ``True``, aksi "
"takdirde ``False`` döndürür.  Yazdırılamayan karakterler, yazdırılabilir "
"olarak kabul edilen ASCII boşluğu (0x20) dışında, Unicode karakter "
"veritabanında \"Diğer\" veya \"Ayırıcı\" olarak tanımlanan karakterlerdir.  "
"(Bu bağlamda, yazdırılabilir karakterlerin :func:`repr` bir dize üzerinde "
"çağrıldığında kaçılmaması gereken karakterler olduğunu unutmayın.  Bunun :"
"data:`sys.stdout` veya :data:`sys.stderr` dosyalarına yazılan dizelerin "
"işlenmesiyle bir ilgisi yoktur)"

#: library/stdtypes.rst:1802
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""
"Dizede yalnızca boşluk karakterleri varsa ve en az bir karakter varsa "
"``True``, aksi takdirde ``False`` döndürür."

#: library/stdtypes.rst:1805
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, space"
"\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"Bir karakter, genel kategorisi ``Zs`` (“Ayırıcı, boşluk”) ya da çift yönlü "
"sınıfı ``WS``, ``B`` veya ``S``’den biri ise Unicode karakter veritabanında "
"(bkz. :mod:`unicodedata`) *beyaz boşluk karakteri*’dir."

#: library/stdtypes.rst:1813
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"Eğer dizenin yalnızca ilk harfi büyük ise ve en az bir karakter varsa "
"``True`` döndürür. Örneğin, büyük harfli karakterler sadece küçük harfli "
"karakterleri ve küçük harfli karakterler sadece büyük harfli karakterleri "
"takip edebilir.  Aksi takdirde ``False`` döndürür."

#: library/stdtypes.rst:1820
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Dizedeki tüm karakterler [4]_ büyük harfli ise ve en az bir büyük harfli "
"karakter varsa ``True``, aksi takdirde ``False`` döndürür."

#: library/stdtypes.rst:1836
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"*iterable* içindeki dizgelerin birleşiminden oluşan bir dizge döndürür. Eğer "
"*iterable* içinde :class:`bytes` nesneleri de dahil olmak üzere string "
"olmayan değerler varsa bir :exc:`TypeError` oluşacaktır.  Öğeler arasındaki "
"ayırıcı, bu yöntemi sağlayan dizedir."

#: library/stdtypes.rst:1844
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"*width* uzunluğundaki bir dizeyi sola hizalanmış olarak döndürür. Doldurma, "
"belirtilen *fillchar* kullanılarak yapılır (varsayılanı bir ASCII "
"boşluğudur). *width*, ``len(s)`` değerinden küçük veya ona eşitse orijinal "
"dize döndürülür."

#: library/stdtypes.rst:1851
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Dizenin tüm büyük harfli karakterlerini [4]_ küçük harfe dönüştürerek bir "
"kopyasını döndürür."

#: library/stdtypes.rst:1854
msgid ""
"The lowercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"Harf küçültme algoritması, Unicode Standardının 3.13 bölümünde açıklanmıştır."

#: library/stdtypes.rst:1860
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Dizenin baştaki karakterleri çıkarılmış bir kopyasını döndürür.  *chars* "
"bağımsız değişkeni, kaldırılacak karakter kümesini belirten bir dizedir.  "
"Atlanırsa veya ``None`` olursa, *chars* bağımsız değişkeni varsayılan olarak "
"boşlukları kaldırır.  *chars* bağımsız değişkeni bir ön ek değildir; bunun "
"yerine, değerlerinin tüm kombinasyonları çıkarılır::"

#: library/stdtypes.rst:1870
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Bir karakter kümesinin tüm ön ekleri yerine tek bir ön ek dizesini "
"kaldıracak bir yöntem için :meth:`str.removeprefix` bölümüne bakın.  "
"Örneğin::"

#: library/stdtypes.rst:1881
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Bu statik yöntem :meth:`str.translate` için kullanılabilecek bir çeviri "
"tablosu döndürür."

#: library/stdtypes.rst:1883
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Yalnızca bir bağımsız değişken varsa, Unicode sıradanlarını (tamsayılar) "
"veya karakterlerini (1 uzunluğundaki dizeler) Unicode sıradanlarına, "
"dizelere (isteğe bağlı uzunluklarda) veya ``None`` değerine eşleyen bir "
"sözlük olmalıdır.  Karakter anahtarları daha sonra sıradanlara "
"dönüştürülecektir."

#: library/stdtypes.rst:1888
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"İki bağımsız değişken varsa, bunlar eşit uzunlukta dizgeler olmalıdır. "
"Sözlüğün son halinde x'teki her karakter y'de aynı konumdaki karakterle "
"eşlenecektir. Üçüncü bir bağımsız değişken varsa, karakterleri sonuçta "
"``None`` ile eşlenecek bir dizge olmalıdır."

#: library/stdtypes.rst:1896
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Dizeyi *sep* öğesinin ilk geçtiği yerden böler ve ayırıcıdan önceki kısmı, "
"ayırıcının kendisini ve ayırıcıdan sonraki kısmı içeren bir 3'lü döndürür.  "
"Ayırıcı bulunamazsa, dizenin kendisini ve ardından iki boş dizeyi içeren bir "
"3'lü döndürür."

#: library/stdtypes.rst:1904
msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr ""
"Eğer dize *prefix* dizesi ile başlıyorsa, ``dize[len(prefix):]`` döndürür. "
"Aksi takdirde, orijinal dizgenin bir kopyasını döndürür::"

#: library/stdtypes.rst:1918
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"Dize *suffix* (son ek) dizesiyle bitiyorsa ve bu *suffix* boş değilse, "
"``dize[:-len(suffix)]`` döndürür. Aksi takdirde, orijinal dizenin bir "
"kopyasını döndürür::"

#: library/stdtypes.rst:1932
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""
"Dizenin, *eski* alt dizesinin tüm oluşumları *yeni* ile değiştirilmiş bir "
"kopyasını döndürür.  İsteğe bağlı olarak *count* bağımsız değişkeni "
"verilirse, yalnızca ilk *count* oluşumu değiştirilir."

#: library/stdtypes.rst:1939
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Dizede *sub* alt dizesinin bulunduğu en yüksek dizini döndürür, öyle ki "
"*sub* ``s[start:end]`` içinde yer alır.  İsteğe bağlı argümanlar *start* ve "
"*end* dilim gösterimindeki gibi yorumlanır.  Başarısızlık durumunda ``-1`` "
"döndürür."

#: library/stdtypes.rst:1946
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
":meth:`rfind` gibi, ancak *sub* alt dizesi bulunamadığında :exc:`ValueError` "
"yükseltir."

#: library/stdtypes.rst:1952
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"*width* uzunluğundaki bir dizeyi sağa hizalanmış olarak döndürür. Doldurma, "
"belirtilen *fillchar* kullanılarak yapılır (varsayılanı bir ASCII "
"boşluğudur). *width*, ``len(s)`` değerinden küçük veya ona eşitse orijinal "
"dize döndürülür."

#: library/stdtypes.rst:1959
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Dizeyi *sep* öğesinin ilk geçtiği yerden böler ve ayırıcıdan önceki kısmı, "
"ayırıcının kendisini ve ayırıcıdan sonraki kısmı içeren bir 3'lü döndürür.  "
"Ayırıcı bulunamazsa, dizenin kendisini ve ardından iki boş dizeyi içeren bir "
"3'lü döndürür."

#: library/stdtypes.rst:1967
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Ayırıcı dizge olarak *sep* kullanarak dizgedeki sözcüklerin bir listesini "
"döndürür. Eğer *maxsplit* belirtilmişse, *rightmost* olmak üzere en fazla "
"*maxsplit* bölme yapılır.  Eğer *sep* belirtilmemişse veya ``None`` ise, "
"herhangi bir boşluk dizesi ayırıcıdır.  Sağdan bölme dışında, :meth:`rsplit` "
"aşağıda ayrıntılı olarak açıklanan :meth:`split` gibi davranır."

#: library/stdtypes.rst:1976
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Dizenin en sondaki karakterleri çıkarılmış bir kopyasını döndürür.  *chars* "
"bağımsız değişkeni, kaldırılacak karakter kümesini belirten bir dizedir.  "
"Atlanırsa veya ``None`` olursa, *chars* bağımsız değişkeni varsayılan olarak "
"boşlukları kaldırır.  *chars* bağımsız değişkeni bir ön ek değildir; bunun "
"yerine, değerlerinin tüm kombinasyonları çıkarılır::"

#: library/stdtypes.rst:1986
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Bir karakter kümesinin tüm son ekleri yerine tek bir son ek dizesini "
"kaldıracak bir yöntem için :meth:`str.removeprefix` bölümüne bakın.  "
"Örneğin::"

#: library/stdtypes.rst:1996
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Ayırıcı dizge olarak *sep* kullanarak dizgedeki sözcüklerin bir listesini "
"döndürür.  Eğer *maxsplit* belirtilmişse, en fazla *maxsplit* bölme işlemi "
"yapılır (dolayısıyla, liste en fazla ``maxsplit+1`` elemana sahip olur).  "
"Eğer *maxsplit* belirtilmemişse veya ``-1`` ise, bölme sayısında bir "
"sınırlama yoktur (tüm olası bölmeler yapılır)."

#: library/stdtypes.rst:2002
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"*sep* verilirse, ardışık sınırlayıcılar birlikte gruplanmaz ve boş dizeleri "
"sınırladıkları kabul edilir (örneğin, ``'1,,2'.split(',')``, ``['1', '', "
"'2']`` döndürür). *sep* bağımsız değişkeni birden çok karakterden oluşabilir "
"(örneğin, ``'1<>2<>3'.split('<>')``, ``['1', '2', '3']`` döndürür). Boş bir "
"dizeyi belirtilen bir ayırıcıyla bölmek ``['']`` döndürür."

#: library/stdtypes.rst:2024 library/stdtypes.rst:2144
#: library/stdtypes.rst:3055 library/stdtypes.rst:3162
#: library/stdtypes.rst:3203 library/stdtypes.rst:3245
#: library/stdtypes.rst:3277 library/stdtypes.rst:3327
#: library/stdtypes.rst:3396 library/stdtypes.rst:3420
msgid "For example::"
msgstr "Örneğin: ::"

#: library/stdtypes.rst:2017
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Eğer *sep* belirtilmemişse veya ``None`` ise, farklı bir bölme algoritması "
"uygulanır: ardışık boşluk dizileri tek bir ayırıcı olarak kabul edilir ve "
"dizgenin başında veya sonunda boşluk varsa, sonucun başında veya sonunda boş "
"dizeler olmaz. Dolayısıyla, boş bir dizeyi veya sadece beyaz boşluktan "
"oluşan bir dizeyi ``None`` ayırıcısıyla bölmek ``[]`` döndürür."

#: library/stdtypes.rst:2039
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Satır sınırlarında keserek dizedeki satırların bir listesini döndürür.  "
"Satır sonları için *keepends* belirtilmediği ve true değerinde olmadığı "
"sürece, satır sonları sonuç listesine dahil edilmez."

#: library/stdtypes.rst:2043
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Bu yöntem aşağıdaki satır sınırlarında bölme yapar.  Spesifik olarak, "
"sınırlar :term:`universal newlines` 'ın bir üst kümesidir."

#: library/stdtypes.rst:2047
msgid "Representation"
msgstr "Temsil"

#: library/stdtypes.rst:2047
msgid "Description"
msgstr "Açıklama"

#: library/stdtypes.rst:2049
msgid "``\\n``"
msgstr "``\\n``"

#: library/stdtypes.rst:2049
msgid "Line Feed"
msgstr "Satır Atlama"

#: library/stdtypes.rst:2051
msgid "``\\r``"
msgstr "``\\r``"

#: library/stdtypes.rst:2051
msgid "Carriage Return"
msgstr "Satır Başına Alma"

#: library/stdtypes.rst:2053
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: library/stdtypes.rst:2053
msgid "Carriage Return + Line Feed"
msgstr "Satır Başına Alma + Satır Atlama"

#: library/stdtypes.rst:2055
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` or ``\\x0b``"

#: library/stdtypes.rst:2055
msgid "Line Tabulation"
msgstr "Satır Tablolama"

#: library/stdtypes.rst:2057
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` or ``\\x0c``"

#: library/stdtypes.rst:2057
msgid "Form Feed"
msgstr "Form Besleme"

#: library/stdtypes.rst:2059
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: library/stdtypes.rst:2059
msgid "File Separator"
msgstr "Dosya Ayırıcı"

#: library/stdtypes.rst:2061
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: library/stdtypes.rst:2061
msgid "Group Separator"
msgstr "Grup Ayırıcı"

#: library/stdtypes.rst:2063
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: library/stdtypes.rst:2063
msgid "Record Separator"
msgstr "Kayıt Ayırıcı"

#: library/stdtypes.rst:2065
msgid "``\\x85``"
msgstr "``\\x85``"

#: library/stdtypes.rst:2065
msgid "Next Line (C1 Control Code)"
msgstr "Yeni Satır (C1 Denetim Kodu)"

#: library/stdtypes.rst:2067
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: library/stdtypes.rst:2067
msgid "Line Separator"
msgstr "Satır Ayrıcı"

#: library/stdtypes.rst:2069
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: library/stdtypes.rst:2069
msgid "Paragraph Separator"
msgstr "Paragraf Ayırıcı"

#: library/stdtypes.rst:2074
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` ve ``\\f`` satır sınırlarına eklenir."

#: library/stdtypes.rst:2083
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Bir sınırlayıcı dize *sep* verildiğinde :meth:`~str.split` yönteminden "
"farklı olarak, bu yöntem boş dize için boş bir liste döndürür ve bir "
"terminal satır sonu fazladan bir satır ile sonuçlanmaz::"

#: library/stdtypes.rst:2092
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Kıyaslayacak olursak ``split(‘\\n’)`` şu değeri verir::"

#: library/stdtypes.rst:2102
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Dize *önek* ile başlıyorsa ``True`` döndürür, aksi takdirde ``False`` "
"döndürür. *prefix* ayrıca aranacak ön eklerin bir tuple'ı da olabilir.  "
"İsteğe bağlı *start* ile, o konumdan başlayan dizeyi sınar.  İsteğe bağlı "
"*end* ile, dizeyi o konumda karşılaştırmayı durdurur."

#: library/stdtypes.rst:2110
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Dizenin baştaki ve sondaki karakterleri çıkarılmış bir kopyasını döndürür. "
"*chars* bağımsız değişkeni, kaldırılacak karakter kümesini belirten bir "
"dizedir. Atlanırsa veya ``None`` olursa, *chars* bağımsız değişkeni "
"varsayılan olarak boşlukları kaldırır. *chars* bağımsız değişkeni bir ön ek "
"veya son ek değildir; bunun yerine, değerlerinin tüm kombinasyonları "
"çıkarılır::"

#: library/stdtypes.rst:2121
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"En dıştaki ön ve son*chars* bağımsız değişken değerleri dizeden çıkarılır. "
"Karakterler, *chars* içindeki karakter kümesinde bulunmayan bir dize "
"karakterine ulaşılana kadar önde gelen uçtan çıkarılır. Benzer bir işlem son "
"uçta da gerçekleşir. Örneğin::"

#: library/stdtypes.rst:2134
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Büyük harf karakterleri küçük harfe dönüştürülmüş veya tam tersi yapılmış "
"dizenin bir kopyasını döndürür. ``s.swapcase().swapcase() == s`` ifadesinin "
"mutlaka doğru olması gerekmediğine dikkat edin."

#: library/stdtypes.rst:2141
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Sözcüklerin büyük harfle başladığı ve kalan karakterlerin küçük harf olduğu "
"dizenin başlıklandırılmış bir sürümünü döndürür."

#: library/stdtypes.rst:3364
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"Algoritma, bir kelimenin ardışık harf grupları olarak dilden bağımsız basit "
"bir tanımını kullanır.  Bu tanım birçok bağlamda işe yarar, ancak bu, "
"kısaltmalar ve iyeliklerdeki kesme işaretlerinin kelime sınırları "
"oluşturduğu anlamına gelir ve bu istenen sonuç olmayabilir::"

#: library/stdtypes.rst:2157
msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ""

#: library/stdtypes.rst:2160
#, fuzzy
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr ""
"Kesme işaretleri için geçici bir çözüm düzenli ifadeler kullanılarak "
"oluşturulabilir::"

#: library/stdtypes.rst:2175
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`__getitem__`, typically a :term:`mapping` or :term:"
"`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"Her karakterin verilen çeviri tablosu aracılığıyla eşlendiği dizgenin bir "
"kopyasını döndürür.  Tablo, :meth:`__getitem__` aracılığıyla indeksleme "
"uygulayan bir nesne, tipik olarak bir :term:`mapping` veya :term:`sequence` "
"olmalıdır.  Bir Unicode sıra numarası (bir tamsayı) ile indekslendiğinde, "
"tablo nesnesi aşağıdakilerden herhangi birini yapabilir: karakteri bir veya "
"daha fazla başka karakterle eşlemek için bir Unicode sıra numarası veya bir "
"dize döndürmek; karakteri dönüş dizesinden silmek için ``None`` döndürmek; "
"veya karakteri kendisiyle eşlemek için bir :exc:`LookupError` istisnası "
"oluşturmak."

#: library/stdtypes.rst:2184
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""

#: library/stdtypes.rst:2187
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""

#: library/stdtypes.rst:2193
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""

#: library/stdtypes.rst:2199
msgid ""
"The uppercasing algorithm used is described in section 3.13 of the Unicode "
"Standard."
msgstr ""
"Harf büyütme algoritması, Unicode Standardının 3.13 bölümünde açıklanmıştır."

#: library/stdtypes.rst:2205
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: library/stdtypes.rst:2223
msgid "``printf``-style String Formatting"
msgstr ""

#: library/stdtypes.rst:2236
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""

#: library/stdtypes.rst:2244
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"in the C language."
msgstr ""

#: library/stdtypes.rst:2250
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""

#: library/stdtypes.rst:3475
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""

#: library/stdtypes.rst:3478
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr ""

#: library/stdtypes.rst:3480
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""

#: library/stdtypes.rst:3483
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""

#: library/stdtypes.rst:3486
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""

#: library/stdtypes.rst:3490
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""

#: library/stdtypes.rst:3495
msgid "Length modifier (optional)."
msgstr ""

#: library/stdtypes.rst:3497
msgid "Conversion type."
msgstr ""

#: library/stdtypes.rst:2284
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""

#: library/stdtypes.rst:3508
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""

#: library/stdtypes.rst:3511
msgid "The conversion flag characters are:"
msgstr ""

#: library/stdtypes.rst:3520
msgid "Flag"
msgstr ""

#: library/stdtypes.rst:3522
msgid "``'#'``"
msgstr ""

#: library/stdtypes.rst:3522
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""

#: library/stdtypes.rst:3525
msgid "``'0'``"
msgstr ""

#: library/stdtypes.rst:3525
msgid "The conversion will be zero padded for numeric values."
msgstr ""

#: library/stdtypes.rst:3527
msgid "``'-'``"
msgstr ""

#: library/stdtypes.rst:3527
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""

#: library/stdtypes.rst:3530
msgid "``' '``"
msgstr ""

#: library/stdtypes.rst:3530
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""

#: library/stdtypes.rst:3533
msgid "``'+'``"
msgstr ""

#: library/stdtypes.rst:3533
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""

#: library/stdtypes.rst:3537
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""

#: library/stdtypes.rst:3540
msgid "The conversion types are:"
msgstr ""

#: library/stdtypes.rst:3543
msgid "Conversion"
msgstr ""

#: library/stdtypes.rst:3545
msgid "``'d'``"
msgstr ""

#: library/stdtypes.rst:2332 library/stdtypes.rst:3547
msgid "Signed integer decimal."
msgstr ""

#: library/stdtypes.rst:3547
msgid "``'i'``"
msgstr ""

#: library/stdtypes.rst:3549
msgid "``'o'``"
msgstr ""

#: library/stdtypes.rst:3549
msgid "Signed octal value."
msgstr ""

#: library/stdtypes.rst:3551
msgid "``'u'``"
msgstr ""

#: library/stdtypes.rst:3551
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr ""

#: library/stdtypes.rst:3553
msgid "``'x'``"
msgstr ""

#: library/stdtypes.rst:3553
msgid "Signed hexadecimal (lowercase)."
msgstr ""

#: library/stdtypes.rst:3555
msgid "``'X'``"
msgstr ""

#: library/stdtypes.rst:3555
msgid "Signed hexadecimal (uppercase)."
msgstr ""

#: library/stdtypes.rst:3557
msgid "``'e'``"
msgstr ""

#: library/stdtypes.rst:3557
msgid "Floating point exponential format (lowercase)."
msgstr ""

#: library/stdtypes.rst:3559
msgid "``'E'``"
msgstr ""

#: library/stdtypes.rst:3559
msgid "Floating point exponential format (uppercase)."
msgstr ""

#: library/stdtypes.rst:3561
msgid "``'f'``"
msgstr ""

#: library/stdtypes.rst:2348 library/stdtypes.rst:3563
msgid "Floating point decimal format."
msgstr ""

#: library/stdtypes.rst:3563
msgid "``'F'``"
msgstr ""

#: library/stdtypes.rst:3565
msgid "``'g'``"
msgstr ""

#: library/stdtypes.rst:3565
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: library/stdtypes.rst:3569
msgid "``'G'``"
msgstr ""

#: library/stdtypes.rst:3569
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: library/stdtypes.rst:3573
msgid "``'c'``"
msgstr ""

#: library/stdtypes.rst:2358
msgid "Single character (accepts integer or single character string)."
msgstr ""

#: library/stdtypes.rst:3586
msgid "``'r'``"
msgstr ""

#: library/stdtypes.rst:2361
msgid "String (converts any Python object using :func:`repr`)."
msgstr ""

#: library/stdtypes.rst:3580
msgid "``'s'``"
msgstr ""

#: library/stdtypes.rst:2364
msgid "String (converts any Python object using :func:`str`)."
msgstr ""

#: library/stdtypes.rst:3583
msgid "``'a'``"
msgstr ""

#: library/stdtypes.rst:2367
msgid "String (converts any Python object using :func:`ascii`)."
msgstr ""

#: library/stdtypes.rst:3589
msgid "``'%'``"
msgstr ""

#: library/stdtypes.rst:3589
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""

#: library/stdtypes.rst:3596
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""

#: library/stdtypes.rst:3600
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""

#: library/stdtypes.rst:3604
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""

#: library/stdtypes.rst:3607
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""

#: library/stdtypes.rst:3611
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""

#: library/stdtypes.rst:3614
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""

#: library/stdtypes.rst:3618
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr ""

#: library/stdtypes.rst:3627
msgid "See :pep:`237`."
msgstr ""

#: library/stdtypes.rst:2404
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""

#: library/stdtypes.rst:2409
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""

#: library/stdtypes.rst:2420
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""

#: library/stdtypes.rst:2428
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""

#: library/stdtypes.rst:2433
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""

#: library/stdtypes.rst:2439
msgid "Bytes Objects"
msgstr ""

#: library/stdtypes.rst:2443
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""

#: library/stdtypes.rst:2450
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""

#: library/stdtypes.rst:2453
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr ""

#: library/stdtypes.rst:2454
#, fuzzy
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr "Çift tırnak: ``\"katıştırılmış 'tek' tırnaklara izin verir\"``."

#: library/stdtypes.rst:2455
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""

#: library/stdtypes.rst:2457
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""

#: library/stdtypes.rst:2461
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""

#: library/stdtypes.rst:2465
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""

#: library/stdtypes.rst:2475
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""

#: library/stdtypes.rst:2478
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr ""

#: library/stdtypes.rst:2479
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr ""

#: library/stdtypes.rst:2480
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""

#: library/stdtypes.rst:2482
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr ""

#: library/stdtypes.rst:2484
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""

#: library/stdtypes.rst:2490
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""

#: library/stdtypes.rst:2497
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""

#: library/stdtypes.rst:2501
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""

#: library/stdtypes.rst:2591
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""

#: library/stdtypes.rst:2512
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, "
"this separator will be included between each byte. A second optional "
"*bytes_per_sep* parameter controls the spacing. Positive values calculate "
"the separator position from the right, negative values from the left."
msgstr ""

#: library/stdtypes.rst:2529
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""

#: library/stdtypes.rst:2533
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""

#: library/stdtypes.rst:2538
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""

#: library/stdtypes.rst:2546
msgid "Bytearray Objects"
msgstr ""

#: library/stdtypes.rst:2550
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""

#: library/stdtypes.rst:2555
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""

#: library/stdtypes.rst:2558
msgid "Creating an empty instance: ``bytearray()``"
msgstr ""

#: library/stdtypes.rst:2559
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr ""

#: library/stdtypes.rst:2560
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr ""

#: library/stdtypes.rst:2561
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""

#: library/stdtypes.rst:2563
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""

#: library/stdtypes.rst:2567
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr ""

#: library/stdtypes.rst:2569
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""

#: library/stdtypes.rst:2575
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""

#: library/stdtypes.rst:2582
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""

#: library/stdtypes.rst:2586
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""

#: library/stdtypes.rst:2599
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""

#: library/stdtypes.rst:2604
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""

#: library/stdtypes.rst:2609
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""

#: library/stdtypes.rst:2618
msgid "Bytes and Bytearray Operations"
msgstr ""

#: library/stdtypes.rst:2623
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""

#: library/stdtypes.rst:2631
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""

#: library/stdtypes.rst:2638
msgid "and::"
msgstr ""

#: library/stdtypes.rst:2643
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""

#: library/stdtypes.rst:2648
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""

#: library/stdtypes.rst:2651
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""

#: library/stdtypes.rst:2657
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""

#: library/stdtypes.rst:2763 library/stdtypes.rst:2851
#: library/stdtypes.rst:2864
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""

#: library/stdtypes.rst:2664
msgid ""
"If *sub* is empty, returns the number of empty slices between characters "
"which is the length of the bytes object plus one."
msgstr ""

#: library/stdtypes.rst:2775 library/stdtypes.rst:2854
#: library/stdtypes.rst:2867
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr ""

#: library/stdtypes.rst:2674
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr ""

#: library/stdtypes.rst:2683
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr ""

#: library/stdtypes.rst:2709 library/stdtypes.rst:2932
#: library/stdtypes.rst:2977 library/stdtypes.rst:3033
#: library/stdtypes.rst:3121 library/stdtypes.rst:3288
#: library/stdtypes.rst:3386 library/stdtypes.rst:3429
#: library/stdtypes.rst:3631
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""

#: library/stdtypes.rst:2696
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""

#: library/stdtypes.rst:2705
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr ""

#: library/stdtypes.rst:2718
msgid ""
"Return a string decoded from the given bytes.  Default encoding is "
"``'utf-8'``. *errors* may be given to set a different error handling "
"scheme.  The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`.  Other possible values are ``'ignore'``, "
"``'replace'`` and any other name registered via :func:`codecs."
"register_error`, see section :ref:`error-handlers`. For a list of possible "
"encodings, see section :ref:`standard-encodings`."
msgstr ""

#: library/stdtypes.rst:2726
msgid ""
"By default, the *errors* argument is not checked for best performances, but "
"only used at the first decoding error. Enable the :ref:`Python Development "
"Mode <devmode>`, or use a :ref:`debug build <debug-build>` to check *errors*."
msgstr ""

#: library/stdtypes.rst:2732
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary bytes or "
"bytearray object."
msgstr ""

#: library/stdtypes.rst:2736
msgid "Added support for keyword arguments."
msgstr ""

#: library/stdtypes.rst:2747
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""

#: library/stdtypes.rst:2752
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""

#: library/stdtypes.rst:2758
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""

#: library/stdtypes.rst:2768
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""

#: library/stdtypes.rst:2782
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""

#: library/stdtypes.rst:2795
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""

#: library/stdtypes.rst:2806
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""

#: library/stdtypes.rst:2817
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""

#: library/stdtypes.rst:2881
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr ""

#: library/stdtypes.rst:2830
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""

#: library/stdtypes.rst:2834
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""

#: library/stdtypes.rst:2846
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""

#: library/stdtypes.rst:2861
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""

#: library/stdtypes.rst:2874
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""

#: library/stdtypes.rst:2887
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""

#: library/stdtypes.rst:2892
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr ""

#: library/stdtypes.rst:2898
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""

#: library/stdtypes.rst:2903
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""

#: library/stdtypes.rst:2906
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""

#: library/stdtypes.rst:2912
msgid "*delete* is now supported as a keyword argument."
msgstr ""

#: library/stdtypes.rst:2916
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""

#: library/stdtypes.rst:2925
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""

#: library/stdtypes.rst:2939
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""

#: library/stdtypes.rst:2953
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""

#: library/stdtypes.rst:2965
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""

#: library/stdtypes.rst:2984
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""

#: library/stdtypes.rst:2998
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""

#: library/stdtypes.rst:3009
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""

#: library/stdtypes.rst:3021
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""

#: library/stdtypes.rst:3040
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""

#: library/stdtypes.rst:3046
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence (for example, ``b'1<>2<>3'.split(b'<>')`` returns "
"``[b'1', b'2', b'3']``). Splitting an empty sequence with a specified "
"separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on the type of "
"object being split.  The *sep* argument may be any :term:`bytes-like object`."
msgstr ""

#: library/stdtypes.rst:3064
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""

#: library/stdtypes.rst:3085
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""

#: library/stdtypes.rst:3098
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""

#: library/stdtypes.rst:3107
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""

#: library/stdtypes.rst:3115
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""

#: library/stdtypes.rst:3128
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""

#: library/stdtypes.rst:3156
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""

#: library/stdtypes.rst:3173
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""

#: library/stdtypes.rst:3189
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""

#: library/stdtypes.rst:3199
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""

#: library/stdtypes.rst:3214
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""

#: library/stdtypes.rst:3266 library/stdtypes.rst:3332
#: library/stdtypes.rst:3401
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""

#: library/stdtypes.rst:3232
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""

#: library/stdtypes.rst:3241
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""

#: library/stdtypes.rst:3256
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""

#: library/stdtypes.rst:3274
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""

#: library/stdtypes.rst:3299
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""

#: library/stdtypes.rst:3311
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""

#: library/stdtypes.rst:3324
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""

#: library/stdtypes.rst:3336
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""

#: library/stdtypes.rst:3350
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""

#: library/stdtypes.rst:3359
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""

#: library/stdtypes.rst:3372
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Kesme işaretleri için geçici bir çözüm düzenli ifadeler kullanılarak "
"oluşturulabilir::"

#: library/stdtypes.rst:3393
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""

#: library/stdtypes.rst:3414
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""

#: library/stdtypes.rst:3436
msgid "``printf``-style Bytes Formatting"
msgstr ""

#: library/stdtypes.rst:3453
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""

#: library/stdtypes.rst:3458
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""

#: library/stdtypes.rst:3465
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""

#: library/stdtypes.rst:3499
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""

#: library/stdtypes.rst:3573
msgid "Single byte (accepts integer or single byte objects)."
msgstr ""

#: library/stdtypes.rst:3576
msgid "``'b'``"
msgstr ""

#: library/stdtypes.rst:3576
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`__bytes__`)."
msgstr ""

#: library/stdtypes.rst:3580
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""

#: library/stdtypes.rst:3583
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""

#: library/stdtypes.rst:3586
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""

#: library/stdtypes.rst:3586
msgid "\\(7)"
msgstr ""

#: library/stdtypes.rst:3621
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr ""

#: library/stdtypes.rst:3624
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr ""

#: library/stdtypes.rst:3636
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ""

#: library/stdtypes.rst:3643
msgid "Memory Views"
msgstr ""

#: library/stdtypes.rst:3645
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""

#: library/stdtypes.rst:3651
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""

#: library/stdtypes.rst:3655
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such "
"as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""

#: library/stdtypes.rst:3660
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the view. "
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""

#: library/stdtypes.rst:3667
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""

#: library/stdtypes.rst:3680
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""

#: library/stdtypes.rst:3689
msgid "Here is an example with a non-byte format::"
msgstr ""

#: library/stdtypes.rst:3701
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""

#: library/stdtypes.rst:3722
msgid ""
"One-dimensional memoryviews of hashable (read-only) types with formats 'B', "
"'b' or 'c' are also hashable. The hash is defined as ``hash(m) == hash(m."
"tobytes())``::"
msgstr ""

#: library/stdtypes.rst:3734
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now hashable."
msgstr ""

#: library/stdtypes.rst:3738
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""

#: library/stdtypes.rst:3742
msgid "memoryviews can now be indexed with tuple of integers."
msgstr ""

#: library/stdtypes.rst:3745
msgid ":class:`memoryview` has several methods:"
msgstr ""

#: library/stdtypes.rst:3749
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""

#: library/stdtypes.rst:3753
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""

#: library/stdtypes.rst:3772
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""

#: library/stdtypes.rst:3788
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""

#: library/stdtypes.rst:3791
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""

#: library/stdtypes.rst:3797
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""

#: library/stdtypes.rst:3806
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""

#: library/stdtypes.rst:3811
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""

#: library/stdtypes.rst:3820
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""

#: library/stdtypes.rst:3829
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""

#: library/stdtypes.rst:3836
msgid "Return the data in the buffer as a list of elements. ::"
msgstr ""

#: library/stdtypes.rst:3846
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""

#: library/stdtypes.rst:3853
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""

#: library/stdtypes.rst:3872
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""

#: library/stdtypes.rst:3878
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""

#: library/stdtypes.rst:3889
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""

#: library/stdtypes.rst:3905
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""

#: library/stdtypes.rst:3911
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length."
msgstr ""

#: library/stdtypes.rst:3916
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr ""

#: library/stdtypes.rst:3939
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr ""

#: library/stdtypes.rst:3952
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr ""

#: library/stdtypes.rst:3978
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr ""

#: library/stdtypes.rst:3992
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""

#: library/stdtypes.rst:3995
msgid "There are also several readonly attributes available:"
msgstr ""

#: library/stdtypes.rst:3999
msgid "The underlying object of the memoryview::"
msgstr ""

#: library/stdtypes.rst:4010
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""

#: library/stdtypes.rst:4029
msgid "Multi-dimensional arrays::"
msgstr ""

#: library/stdtypes.rst:4046
msgid "A bool indicating whether the memory is read only."
msgstr ""

#: library/stdtypes.rst:4050
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""

#: library/stdtypes.rst:4055
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""

#: library/stdtypes.rst:4061
msgid "The size in bytes of each element of the memoryview::"
msgstr ""

#: library/stdtypes.rst:4074
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""

#: library/stdtypes.rst:4079
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""

#: library/stdtypes.rst:4090
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr ""

#: library/stdtypes.rst:4087
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""

#: library/stdtypes.rst:4095
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""

#: library/stdtypes.rst:4099
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "Belleğin C-:term:`contiguous` olup olmadığını gösteren bir bool."

#: library/stdtypes.rst:4105
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "Belleğin Fortran :term:`contiguous` olup olmadığını gösteren bir bool."

#: library/stdtypes.rst:4111
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "Belleğin :term:`contiguous` olup olmadığını gösteren bir bool."

#: library/stdtypes.rst:4119
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Set Türleri --- :class:`set`, :class:`frozenset`"

#: library/stdtypes.rst:4123
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Bir :dfn:`set` nesnesi, farklı :term:`hashable` nesnelerinin sıralanmamış "
"bir koleksiyonudur. Yaygın kullanımları arasında üyelik sınaması, bir "
"diziden yinelenenlerin kaldırılması ve kesişim, birleşim, fark ve simetrik "
"fark gibi matematiksel işlemlerin hesaplanması yer alır. (Diğer kapsayıcılar "
"için yerleşik :class:`dict`, :class:`list` ve :class:`tuple` sınıflarına ve :"
"mod:`collections` modülüne bakın)"

#: library/stdtypes.rst:4130
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Diğer koleksiyonlar gibi, kümeler de ``x in set``, ``len(set)``, ve ``for x "
"in set`` özelliklerini destekler.  Sırasız bir koleksiyon olan kümeler, "
"eleman konumunu veya ekleme sırasını kaydetmez.  Buna göre, kümeler "
"dizinleme, dilimleme veya sıra benzeri davranışları desteklemez."

#: library/stdtypes.rst:4135
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"Şu anda iki yerleşik set türü vardır, :class:`set` ve :class:`frozenset`. :"
"class:`set` türü değişkendir --- içeriği :meth:`~set.add` ve :meth:`~set."
"remove` gibi yöntemler kullanılarak değiştirilebilir.  Değiştirilebilir "
"olduğu için hash değeri yoktur ve bir sözlük anahtarı ya da başka bir "
"kümenin elemanı olarak kullanılamaz. :class:`frozenset` türü değişmezdir ve :"
"term:`hashable` --- içeriği oluşturulduktan sonra değiştirilemez; bu nedenle "
"bir sözlük anahtarı veya başka bir kümenin öğesi olarak kullanılabilir."

#: library/stdtypes.rst:4143
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"Boş olmayan kümeler (frozensetler değil), :class:`set` yapıcısına ek olarak "
"parantez içine virgülle ayrılmış bir öğe listesi yerleştirilerek "
"oluşturulabilir, örneğin: ``{'jack', 'sjoerd'}``."

#: library/stdtypes.rst:4147
msgid "The constructors for both classes work the same:"
msgstr "Her iki sınıfın kurucuları aynı şekilde çalışır:"

#: library/stdtypes.rst:4152
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Elemanları *iterable* öğesinden alınan yeni bir küme veya frozenset nesnesi "
"döndürür.  Bir kümenin elemanları :term:`hashable` olmalıdır.  Kümelerin "
"kümelerini temsil etmek için, iç kümeler :class:`frozenset` nesneleri "
"olmalıdır.  Eğer *iterable* belirtilmemişse, yeni bir boş küme döndürülür."

#: library/stdtypes.rst:4158
msgid "Sets can be created by several means:"
msgstr "Setler çeşitli yollarla oluşturulabilir:"

#: library/stdtypes.rst:4160
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr ""
"Parantez içinde virgülle ayrılmış bir öğe listesi kullanın: ``{'jack', "
"'sjoerd'}``"

#: library/stdtypes.rst:4161
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr ""
"Bir küme kavrayışı kullanın: ``{c for c in 'abracadabra' if c not in 'abc'}``"

#: library/stdtypes.rst:4162
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""
"Tür kurucusunu kullanın: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"

#: library/stdtypes.rst:4164
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
":class:`set` ve :class:`frozenset` örnekleri aşağıdaki işlemleri sağlar:"

#: library/stdtypes.rst:4169
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "*s* kümesindeki eleman sayısını döndürür (*s*'nin kardinalitesi)."

#: library/stdtypes.rst:4173
msgid "Test *x* for membership in *s*."
msgstr "*x*'i *s* üyeliği için test edin."

#: library/stdtypes.rst:4177
msgid "Test *x* for non-membership in *s*."
msgstr "*x*'in *s*'ye üye olup olmadığını test edin."

#: library/stdtypes.rst:4181
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Kümenin *other* kümelerle ortak hiçbir elemanı yoksa ``True`` döndürür.  "
"Kümeler, ancak ve ancak kesişimleri boş küme ise ayrıktır."

#: library/stdtypes.rst:4187
msgid "Test whether every element in the set is in *other*."
msgstr "Kümedeki her elemanın *other* içinde olup olmadığını test edin."

#: library/stdtypes.rst:4191
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Kümenin *other* kümenin uygun bir alt kümesi olup olmadığını, yani ``set <= "
"other and set != other`` olup olmadığını test eder."

#: library/stdtypes.rst:4197
msgid "Test whether every element in *other* is in the set."
msgstr "Kümedeki her elemanın *other* içinde olup olmadığını test edin."

#: library/stdtypes.rst:4201
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Kümenin *other* kümenin uygun bir üst kümesi olup olmadığını, yani ``set >= "
"other and set != other`` olup olmadığını test edin."

#: library/stdtypes.rst:4207
msgid "Return a new set with elements from the set and all others."
msgstr ""
"Kümedeki ve diğer tüm kümelerdeki elemanları içeren yeni bir küme döndürür."

#: library/stdtypes.rst:4212
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Küme ve diğer tüm kümeler için ortak öğeler içeren yeni bir küme döndürür."

#: library/stdtypes.rst:4217
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""
"Küme içinde diğerlerinde olmayan elemanlar içeren yeni bir küme döndürür."

#: library/stdtypes.rst:4222
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Elemanları ya kümede ya da *diğer* kümede olan ancak her ikisinde de olmayan "
"yeni bir küme döndürür."

#: library/stdtypes.rst:4226
msgid "Return a shallow copy of the set."
msgstr "Kümenin yüzeysel bir kopyasını döndürür."

#: library/stdtypes.rst:4229
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and :meth:"
"`issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of "
"the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Not: :meth:`union`, :meth:`intersection`, :meth:`difference`, :meth:"
"`symmetric_difference`, :meth:`issubset` ve :meth:`issuperset` metotlarının "
"operatörsüz versiyonları herhangi bir yinelenebiliri argüman olarak kabul "
"edecektir.  Buna karşılık, operatör tabanlı benzerleri argümanlarının küme "
"olmasını gerektirir.  Bu, daha okunabilir ``set('abc').intersection('cbs')`` "
"yerine ``set('abc') & 'cbs'`` gibi hataya açık yapıları engeller.\n"
"\n"
"Translated with www.DeepL.com/Translator (free version)"

#: library/stdtypes.rst:4236
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"Hem :class:`set` hem de :class:`frozenset` kümeden kümeye karşılaştırmaları "
"destekler. İki küme, ancak ve ancak her kümenin her elemanı diğerinin içinde "
"bulunuyorsa (her biri diğerinin alt kümesi ise) eşittir. Bir küme başka bir "
"kümeden ancak ve ancak birinci küme ikinci kümenin uygun bir alt kümesi ise "
"(bir alt kümedir, ancak eşit değildir) küçüktür. Bir küme, ancak ve ancak "
"birinci küme ikinci kümenin uygun bir üst kümesi ise (bir üst kümedir, ancak "
"eşit değildir) başka bir kümeden büyüktür.\n"
"\n"
"Translated with www.DeepL.com/Translator (free version)"

#: library/stdtypes.rst:4243
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
":class:`set` örnekleri, üyelerine göre :class:`frozenset` örnekleriyle "
"karşılaştırılır.  Örneğin, ``set('abc') == frozenset('abc')`` ``True`` "
"döndürür ve ``set('abc') in set([frozenset('abc')])`` de öyle."

#: library/stdtypes.rst:4247
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"Alt küme ve eşitlik karşılaştırmaları toplam sıralama fonksiyonuna "
"genelleştirilemez.  Örneğin, boş olmayan herhangi iki ayrık küme eşit "
"değildir ve birbirinin alt kümesi değildir, bu nedenle aşağıdakilerin *all* "
"``Yanlış`` döndürür: ``a<b``, ``a==b`` veya ``a>b``."

#: library/stdtypes.rst:4252
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Kümeler yalnızca kısmi sıralama (alt küme ilişkileri) tanımladığından, :meth:"
"`list.sort` yönteminin çıktısı küme listeleri için tanımsızdır."

#: library/stdtypes.rst:4255
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr "Sözlük anahtarları gibi küme öğeleri de :term:`hashable` olmalıdır."

#: library/stdtypes.rst:4257
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
":class:`set` örneklerini :class:`frozenset` ile karıştıran ikili işlemler "
"ilk işlenenin türünü döndürür.  Örneğin: ``frozenset('ab') | set('bc')`` "
"bir :class:`frozenset` örneği döndürür."

#: library/stdtypes.rst:4261
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"Aşağıdaki tabloda :class:`set` için kullanılabilen ve :class:`frozenset` 'in "
"değişmez örneklerine uygulanmayan işlemler listelenmektedir:"

#: library/stdtypes.rst:4267
msgid "Update the set, adding elements from all others."
msgstr "Diğer tüm öğeleri ekleyerek seti güncelleyin."

#: library/stdtypes.rst:4272
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""
"Yalnızca içinde bulunan öğeleri ve diğerlerini koruyarak seti güncelleyin."

#: library/stdtypes.rst:4277
msgid "Update the set, removing elements found in others."
msgstr "Diğerlerinde bulunan öğeleri kaldırarak kümeyi güncelleyin."

#: library/stdtypes.rst:4282
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Kümeyi güncelleyin, yalnızca her iki kümede de bulunan öğeleri saklayın, "
"ancak her ikisinde de bulunmayın."

#: library/stdtypes.rst:4286
msgid "Add element *elem* to the set."
msgstr "Kümeye *elem* öğesini ekleyin."

#: library/stdtypes.rst:4290
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Kümeden *elem* elemanını kaldırır.  Eğer *elem* kümede bulunmuyorsa :exc:"
"`KeyError` değerini yükseltir."

#: library/stdtypes.rst:4295
msgid "Remove element *elem* from the set if it is present."
msgstr "Eğer varsa *elem* öğesini kümeden kaldırır."

#: library/stdtypes.rst:4299
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Kümeden rastgele bir elemanı kaldırır ve döndürür.  Küme boşsa :exc:"
"`KeyError` değerini yükseltir."

#: library/stdtypes.rst:4304
msgid "Remove all elements from the set."
msgstr "Kümeden tüm öğeleri kaldırın."

#: library/stdtypes.rst:4307
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Not: :meth:`update`, :meth:`intersection_update`, :meth:`difference_update` "
"ve :meth:`symmetric_difference_update` metotlarının operatör olmayan "
"versiyonları herhangi bir iterable'ı argüman olarak kabul edecektir."

#: library/stdtypes.rst:4312
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, a temporary one is created from *elem*."
msgstr ""
"Not: :meth:`__contains__`, :meth:`remove` ve :meth:`discard` yöntemlerinin "
"*elem* argümanı bir küme olabilir.  Eşdeğer bir frozenset aramayı "
"desteklemek için, *elem*'den geçici bir tane oluşturulur."

#: library/stdtypes.rst:4320
msgid "Mapping Types --- :class:`dict`"
msgstr "Mapping Types --- :class:`dict`"

#: library/stdtypes.rst:4330
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Bir :term:`mapping` nesnesi :term:`hashable` değerlerini rastgele nesnelere "
"eşler. Eşlemeler değiştirilebilir nesnelerdir.  Şu anda sadece bir standart "
"eşleme türü vardır, :dfn:`dictionary`.  (Diğer kapsayıcılar için yerleşik :"
"class:`list`, :class:`set` ve :class:`tuple` sınıflarına ve :mod:"
"`collections` modülüne bakın)."

#: library/stdtypes.rst:4336
#, fuzzy
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys. Values that compare equal (such as ``1``, ``1.0``, "
"and ``True``) can be used interchangeably to index the same dictionary entry."
msgstr ""
"Bir sözlüğün anahtarları *almost* rastgele değerlerdir. :term:`hashable` "
"olmayan değerler, yani listeler, sözlükler veya diğer değişebilir türleri "
"içeren değerler (nesne kimliği yerine değere göre karşılaştırılan) anahtar "
"olarak kullanılamaz.  Anahtarlar için kullanılan sayısal türler, sayısal "
"karşılaştırma için normal kurallara uyar: iki sayı eşit karşılaştırılırsa "
"(örneğin ``1`` ve ``1.0``), aynı sözlük girdisini indekslemek için "
"birbirlerinin yerine kullanılabilirler.  (Bununla birlikte, bilgisayarlar "
"kayan noktalı sayıları yaklaşık olarak sakladığından, bunları sözlük "
"anahtarları olarak kullanmak genellikle akıllıca değildir)."

#: library/stdtypes.rst:4347
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"İsteğe bağlı bir konumsal bağımsız değişken ve muhtemelen boş bir anahtar "
"sözcük bağımsız değişken kümesinden başlatılan yeni bir sözlük döndürür."

#: library/stdtypes.rst:4350
msgid "Dictionaries can be created by several means:"
msgstr "Sözlükler çeşitli yollarla oluşturulabilir:"

#: library/stdtypes.rst:4352
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""

#: library/stdtypes.rst:4354
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr ""

#: library/stdtypes.rst:4355
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""

#: library/stdtypes.rst:4358
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""

#: library/stdtypes.rst:4368
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""

#: library/stdtypes.rst:4373
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""

#: library/stdtypes.rst:4385
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""

#: library/stdtypes.rst:4389
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""

#: library/stdtypes.rst:4394
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr ""

#: library/stdtypes.rst:4398
msgid "Return the number of items in the dictionary *d*."
msgstr ""

#: library/stdtypes.rst:4402
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""

#: library/stdtypes.rst:4407
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""

#: library/stdtypes.rst:4425
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""

#: library/stdtypes.rst:4431
msgid "Set ``d[key]`` to *value*."
msgstr ""

#: library/stdtypes.rst:4435
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""

#: library/stdtypes.rst:4440
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""

#: library/stdtypes.rst:4444
msgid "Equivalent to ``not key in d``."
msgstr ""

#: library/stdtypes.rst:4448
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""

#: library/stdtypes.rst:4453
msgid "Remove all items from the dictionary."
msgstr ""

#: library/stdtypes.rst:4457
msgid "Return a shallow copy of the dictionary."
msgstr ""

#: library/stdtypes.rst:4461
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""

#: library/stdtypes.rst:4463
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""

#: library/stdtypes.rst:4471
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""

#: library/stdtypes.rst:4477
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""

#: library/stdtypes.rst:4482
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""

#: library/stdtypes.rst:4487
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""

#: library/stdtypes.rst:4493
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""

#: library/stdtypes.rst:4496
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""

#: library/stdtypes.rst:4500
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""

#: library/stdtypes.rst:4506
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""

#: library/stdtypes.rst:4513
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""

#: library/stdtypes.rst:4519
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""

#: library/stdtypes.rst:4522
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""

#: library/stdtypes.rst:4529
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""

#: library/stdtypes.rst:4532
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""

#: library/stdtypes.rst:4542
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""

#: library/stdtypes.rst:4550
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""

#: library/stdtypes.rst:4556
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`."
msgstr ""

#: library/stdtypes.rst:4560
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""

#: library/stdtypes.rst:4578
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""

#: library/stdtypes.rst:4582
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr ""

#: library/stdtypes.rst:4594
msgid "Dictionaries are now reversible."
msgstr ""

#: library/stdtypes.rst:4599
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""

#: library/stdtypes.rst:4606
msgid "Dictionary view objects"
msgstr ""

#: library/stdtypes.rst:4608
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""

#: library/stdtypes.rst:4613
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""

#: library/stdtypes.rst:4618
msgid "Return the number of entries in the dictionary."
msgstr ""

#: library/stdtypes.rst:4622
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""

#: library/stdtypes.rst:4625
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""

#: library/stdtypes.rst:4630
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: library/stdtypes.rst:4633
msgid "Dictionary order is guaranteed to be insertion order."
msgstr ""

#: library/stdtypes.rst:4638
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""

#: library/stdtypes.rst:4643
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""

#: library/stdtypes.rst:4646
msgid "Dictionary views are now reversible."
msgstr ""

#: library/stdtypes.rst:4651
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr ""

#: library/stdtypes.rst:4656
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all "
"values are hashable, so that ``(key, value)`` pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-"
"like since the entries are generally not unique.)  For set-like views, all "
"of the operations defined for the abstract base class :class:`collections."
"abc.Set` are available (for example, ``==``, ``<``, or ``^``)."
msgstr ""

#: library/stdtypes.rst:4663
msgid "An example of dictionary view usage::"
msgstr ""

#: library/stdtypes.rst:4704
msgid "Context Manager Types"
msgstr "Bağlam Yöneticisi Türleri"

#: library/stdtypes.rst:4711
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""

#: library/stdtypes.rst:4719
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""

#: library/stdtypes.rst:4724
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""

#: library/stdtypes.rst:4728
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""

#: library/stdtypes.rst:4738
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""

#: library/stdtypes.rst:4743
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""

#: library/stdtypes.rst:4750
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`__exit__` "
"method has actually failed."
msgstr ""

#: library/stdtypes.rst:4756
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""

#: library/stdtypes.rst:4762
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` methods, "
"rather than the iterator produced by an undecorated generator function."
msgstr ""

#: library/stdtypes.rst:4769
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""

#: library/stdtypes.rst:4777
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"
msgstr ""

#: library/stdtypes.rst:4782
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""

#: library/stdtypes.rst:4789
msgid "Generic Alias Type"
msgstr "Genel Takma Ad Türü"

#: library/stdtypes.rst:4795
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""

#: library/stdtypes.rst:4805
msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr ""

#: library/stdtypes.rst:4808
#, fuzzy
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr ""
"``GenericAlias`` nesnesi, :term:`generic types <generic type>` için bir "
"vekil olarak hareket eder, *parametreli jenerikler* uygulamak - kapsayıcı "
"öğeleri için türler sağlayan belirli bir jenerik örneği."

#: library/stdtypes.rst:4811
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations "
"to signify a :class:`set` in which all the elements are of type :class:"
"`bytes`."
msgstr ""

#: library/stdtypes.rst:4817
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both "
"the :class:`str` data type and the :class:`bytes` data type:"
msgstr ""

#: library/stdtypes.rst:4823
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""

#: library/stdtypes.rst:4829
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""

#: library/stdtypes.rst:4835
#, fuzzy
msgid ""
"``GenericAlias`` objects are instances of the class :class:`types."
"GenericAlias`, which can also be used to create ``GenericAlias`` objects "
"directly."
msgstr ""
"``GenericAlias`` nesnesi için kullanıcıya açık tipe :class:`types."
"GenericAlias` öğesinden erişilebilir ve :func:`isinstance` kontrolleri için "
"kullanılabilir.  Ayrıca doğrudan ``GenericAlias`` nesneleri oluşturmak için "
"de kullanılabilir."

#: library/stdtypes.rst:4841
#, fuzzy
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"Kullanılan ``T`` türüne bağlı olarak *X*, *Y* ve daha fazla türde öğeler "
"içeren bir ``T`` türünü temsil eden bir ``GenericAlias`` oluşturur. "
"Örneğin, :class:`float` elemanları içeren bir :class:`list` bekleyen bir "
"fonksiyon::"

#: library/stdtypes.rst:4849
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is "
"a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
"Anahtar türünü ve değer türünü temsil eden iki tür parametresi bekleyen "
"genel bir tür olan :class:`dict` kullanarak :term:`mapping` nesneleri için "
"başka bir örnek.  Bu örnekte, fonksiyon :class:`str` türünde anahtarları ve :"
"class:`int` türünde değerleri olan bir ``dict`` bekler::"

#: library/stdtypes.rst:4857
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"Yerleşik :func:`isinstance` ve :func:`issubclass` işlevleri ikinci "
"argümanları için ``GenericAlias`` türlerini kabul etmez::"

#: library/stdtypes.rst:4865
#, fuzzy
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"Python çalışma zamanı :term:`type annotations <annotation>` zorlamaz. "
"<annotation>Bu, genel türlere ve bunların tür parametrelerine kadar uzanır. "
"Bir ``GenericAlias`` türünden bir nesne oluştururken, kapsayıcı elemanlar "
"türlerine göre kontrol edilmez. Örneğin, aşağıdaki kod tavsiye edilmez, "
"ancak hatasız çalışacaktır::"

#: library/stdtypes.rst:4875
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr ""
"Ayrıca, parametrelendirilmiş jenerikler nesne oluşturma sırasında tip "
"parametrelerini siler::"

#: library/stdtypes.rst:4886
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr ""
"Bir jenerik üzerinde :func:`repr` veya :func:`str` çağrısı "
"parametrelendirilmiş türü gösterir::"

#: library/stdtypes.rst:4894
#, fuzzy
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"Generics'in :meth:`__getitem__` yöntemi, ``dict[str][str]``: gibi hatalara "
"izin vermemek için bir istisna oluşturacaktır:"

#: library/stdtypes.rst:4902
#, fuzzy
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"Ancak, bu tür ifadeler :ref:`type variables <generics>` kullanıldığında "
"geçerlidir. <generics> Dizin, ``GenericAlias`` nesnesinin :attr:`__args__` "
"öğesindeki tür değişkeni öğeleri kadar öğeye sahip olmalıdır <genericalias.\n"
"__args__>`. ::"

#: library/stdtypes.rst:4913
#, fuzzy
msgid "Standard Generic Classes"
msgstr "Standart Jenerik Koleksiyonlar"

#: library/stdtypes.rst:4915
#, fuzzy
msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr ""
"Bu standart kütüphane koleksiyonları parametrelendirilmiş jenerikleri "
"destekler."

#: library/stdtypes.rst:4918
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: library/stdtypes.rst:4919
msgid ":class:`list`"
msgstr ":class:`list`"

#: library/stdtypes.rst:4920
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: library/stdtypes.rst:4921
msgid ":class:`set`"
msgstr ":class:`set`"

#: library/stdtypes.rst:4922
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: library/stdtypes.rst:4923
msgid ":class:`type`"
msgstr ":class:`type`"

#: library/stdtypes.rst:4924
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: library/stdtypes.rst:4925
msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

#: library/stdtypes.rst:4926
msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

#: library/stdtypes.rst:4927
msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

#: library/stdtypes.rst:4928
msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

#: library/stdtypes.rst:4929
msgid ":class:`collections.abc.Awaitable`"
msgstr ":class:`collections.abc.Awaitable`"

#: library/stdtypes.rst:4930
msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

#: library/stdtypes.rst:4931
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: library/stdtypes.rst:4932
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterator`"

#: library/stdtypes.rst:4933
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

#: library/stdtypes.rst:4934
msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

#: library/stdtypes.rst:4935
msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

#: library/stdtypes.rst:4936
msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

#: library/stdtypes.rst:4937
msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

#: library/stdtypes.rst:4938
msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

#: library/stdtypes.rst:4939
msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

#: library/stdtypes.rst:4940
msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

#: library/stdtypes.rst:4941
msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

#: library/stdtypes.rst:4942
msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

#: library/stdtypes.rst:4943
msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

#: library/stdtypes.rst:4944
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

#: library/stdtypes.rst:4945
msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

#: library/stdtypes.rst:4946
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

#: library/stdtypes.rst:4947
msgid ":class:`collections.abc.ByteString`"
msgstr ":class:`collections.abc.ByteString`"

#: library/stdtypes.rst:4948
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

#: library/stdtypes.rst:4949
msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

#: library/stdtypes.rst:4950
msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

#: library/stdtypes.rst:4951
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

#: library/stdtypes.rst:4952
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

#: library/stdtypes.rst:4953
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

#: library/stdtypes.rst:4954
#, fuzzy
msgid ":class:`dataclasses.Field`"
msgstr ":class:`tuple`"

#: library/stdtypes.rst:4955
msgid ":class:`functools.cached_property`"
msgstr ""

#: library/stdtypes.rst:4956
msgid ":class:`functools.partialmethod`"
msgstr ""

#: library/stdtypes.rst:4957
#, fuzzy
msgid ":class:`os.PathLike`"
msgstr ":class:`set`"

#: library/stdtypes.rst:4958
#, fuzzy
msgid ":class:`queue.LifoQueue`"
msgstr ":class:`frozenset`"

#: library/stdtypes.rst:4959
#, fuzzy
msgid ":class:`queue.Queue`"
msgstr ":class:`tuple`"

#: library/stdtypes.rst:4960
msgid ":class:`queue.PriorityQueue`"
msgstr ""

#: library/stdtypes.rst:4961
#, fuzzy
msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`tuple`"

#: library/stdtypes.rst:4962
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Pattern <re-objects>`"

#: library/stdtypes.rst:4963
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: library/stdtypes.rst:4964
msgid ":class:`shelve.BsdDbShelf`"
msgstr ""

#: library/stdtypes.rst:4965
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ""

#: library/stdtypes.rst:4966
#, fuzzy
msgid ":class:`shelve.Shelf`"
msgstr ":class:`set`"

#: library/stdtypes.rst:4967
#, fuzzy
msgid ":class:`types.MappingProxyType`"
msgstr ":class:`collections.abc.Mapping`"

#: library/stdtypes.rst:4968
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ""

#: library/stdtypes.rst:4969
msgid ":class:`weakref.WeakMethod`"
msgstr ""

#: library/stdtypes.rst:4970
#, fuzzy
msgid ":class:`weakref.WeakSet`"
msgstr ":class:`frozenset`"

#: library/stdtypes.rst:4971
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ""

#: library/stdtypes.rst:4976
#, fuzzy
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "Genel Takma Adın Özel Öznitelikleri"

#: library/stdtypes.rst:4978
msgid "All parameterized generics implement special read-only attributes."
msgstr "Tüm parametreli jenerikler özel salt okunur öznitelikler uygular."

#: library/stdtypes.rst:4982
msgid "This attribute points at the non-parameterized generic class::"
msgstr "Bu öznitelik, parametrelendirilmemiş genel sınıfa işaret eder::"

#: library/stdtypes.rst:4990
#, fuzzy
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr ""
"Bu öznitelik, genel kabın orijinal :meth:`__class_getitem__` öğesine "
"geçirilen genel türlerin :class:`tuple` (muhtemelen uzunluğu 1'dir):"

#: library/stdtypes.rst:5000
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr ""
"Bu öznitelik, ''__args__'' içinde bulunan benzersiz tür değişkenlerin tembel "
"bir şekilde hesaplanmış bir demetidir (muhtemelen boş):"

#: library/stdtypes.rst:5011
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because :class:`typing."
"ParamSpec` is intended primarily for static type checking."
msgstr ""
"``GenericAlias`` nesnesi ile :class:`typing.ParamSpec` parametreleri "
"değiştirildikten sonra doğru ``__parameters__`` olmayabilir çünkü :class:"
"`typing.ParamSpec` öncelikle statik tip kontrolü için tasarlanmıştır."

#: library/stdtypes.rst:5018
msgid ":pep:`484` - Type Hints"
msgstr ""

#: library/stdtypes.rst:5018
msgid "Introducing Python's framework for type annotations."
msgstr ""

#: library/stdtypes.rst:5023
#, fuzzy
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` -- \"Standart Koleksiyonlarda Tip İma Eden Jenerikler\""

#: library/stdtypes.rst:5021
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr ""

#: library/stdtypes.rst:5026
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""

#: library/stdtypes.rst:5026
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""

#: library/stdtypes.rst:5035
msgid "Union Type"
msgstr "Sendika Türü"

#: library/stdtypes.rst:5041
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended "
"primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to :data:`typing."
"Union`."
msgstr ""
"Bir birleşim nesnesi, birden çok :ref:`type objects <bltin-type-objects>` "
"üzerinde ``|`` (bitsel veya) işleminin değerini tutar. Bu türler öncelikle "
"aşağıdakiler için tasarlanmıştır :term:`type annotations <annotation>`. "
"Birleşim türü ifadesi, aşağıdakilere kıyasla daha temiz tür ipucu sözdizimi "
"sağlar :data:`typing.Union`."

#: library/stdtypes.rst:5048
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or :"
"class:`float`::"
msgstr ""
"*X*, *Y* vb. türleri tutan bir birleşim nesnesi tanımlar. ``X | Y`` X veya Y "
"anlamına gelir.  Bu, ``typing.Union[X, Y]`` ile eşdeğerdir. Örneğin, "
"aşağıdaki işlev :class:`int` veya :class:`float`::"

#: library/stdtypes.rst:5058
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr ""
"Birlik nesneleri, diğer birlik nesneleriyle eşitlik açısından test "
"edilebilir.  Detaylar:"

#: library/stdtypes.rst:5060
msgid "Unions of unions are flattened::"
msgstr "Birliklerin birlikleri düzleştirimiştir::"

#: library/stdtypes.rst:5064
msgid "Redundant types are removed::"
msgstr "Gereksiz türler kaldırılır::"

#: library/stdtypes.rst:5068
msgid "When comparing unions, the order is ignored::"
msgstr "Birlikleri karşılaştırırken, sipariş göz ardı edilir::"

#: library/stdtypes.rst:5072
msgid "It is compatible with :data:`typing.Union`::"
msgstr ":data:`typing.Union`:: ile uyumludur:"

#: library/stdtypes.rst:5076
msgid "Optional types can be spelled as a union with ``None``::"
msgstr "İsteğe bağlı türler ``None``:: ile bir birlik olarak yazılabilir:"

#: library/stdtypes.rst:5083
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr ""
":func:`isinstance` ve :func:`issubclass` çağrıları da bir birlik nesnesiyle "
"desteklenir::"

#: library/stdtypes.rst:5089
msgid ""
"However, union objects containing :ref:`parameterized generics <types-"
"genericalias>` cannot be used::"
msgstr "Ancak, :ref:`types-genericalias` içeren union nesneleri kullanılamaz::"

#: library/stdtypes.rst:5097
msgid ""
"The user-exposed type for the union object can be accessed from :data:`types."
"UnionType` and used for :func:`isinstance` checks.  An object cannot be "
"instantiated from the type::"
msgstr ""
"Union nesnesinin kullanıcıya açık türüne :data:`types.UnionType` adresinden "
"erişilebilir ve :func:`isinstance` kontrolleri için kullanılabilir.  Bir "
"nesne şu türden örneklenemez::"

#: library/stdtypes.rst:5110
msgid ""
"The :meth:`__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`__or__`, the Union may override "
"it::"
msgstr ""
"Tür nesneleri için :meth:`__or__` yöntemi, ``X | Y`` sözdizimini desteklemek "
"için eklendi.  Eğer bir metaclass :meth:`__or__` metodunu uygularsa, Union "
"bunu geçersiz kılabilir::"

#: library/stdtypes.rst:5128
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ":pep:`604` -- ``X | Y`` sözdizimini ve Birlik türünü öneren PEP."

#: library/stdtypes.rst:5136
msgid "Other Built-in Types"
msgstr "Diğer Yerleşik Tipler"

#: library/stdtypes.rst:5138
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"Yorumlayıcı başka nesne türlerini de destekler. Bunların çoğu yalnızca bir "
"veya iki işlemi destekler."

#: library/stdtypes.rst:5145
msgid "Modules"
msgstr "Modüller"

#: library/stdtypes.rst:5147
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"Bir modül üzerindeki tek özel işlem öznitelik erişimidir: ``m.name``, burada "
"*m* bir modüldür ve *name*, *m*'nin sembol tablosunda tanımlanan bir isme "
"erişir. Modül nitelikleri atanabilir.  (:keyword:`import` deyiminin "
"kesinlikle bir modül nesnesi üzerinde bir işlem olmadığına dikkat edin; "
"``import foo`` *foo* adında bir modül nesnesinin var olmasını gerektirmez, "
"bunun yerine bir yerlerde *foo* adında bir modül için (harici) bir "
"*tanımlama* gerektirir)"

#: library/stdtypes.rst:5154
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Her modülün özel bir niteliği :attr:`~object.__dict__` 'dir. Bu, modülün "
"sembol tablosunu içeren sözlüktür. Bu sözlüğü değiştirmek aslında modülün "
"sembol tablosunu değiştirecektir, ancak :attr:`~object.__dict__` niteliğine "
"doğrudan atama yapmak mümkün değildir (``m.__dict__['a'] = 1`` "
"yazabilirsiniz, bu ``m.a`` yı ``1`` olarak tanımlar, ancak ``m.__dict__ = {}"
"`` yazamazsınız).  :attr:`~object.__dict__` öğesinin doğrudan değiştirilmesi "
"önerilmez."

#: library/stdtypes.rst:5162
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Yorumlayıcıda yerleşik olarak bulunan modüller şu şekilde yazılır: ``<module "
"'sys' (built-in)>``.  Eğer bir dosyadan yüklenmişlerse, ``<module 'os' from "
"'/usr/local/lib/pythonX.Y/os.pyc'>`` şeklinde yazılırlar."

#: library/stdtypes.rst:5170
msgid "Classes and Class Instances"
msgstr "Sınıflar ve Sınıf Örnekleri"

#: library/stdtypes.rst:5172
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Bunlar için :ref:`class` ve :ref:`objects`  bakın."

#: library/stdtypes.rst:5178
msgid "Functions"
msgstr "Fonksiyonlar"

#: library/stdtypes.rst:5180
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Fonksiyon nesneleri fonksiyon tanımları tarafından oluşturulur.  Bir "
"fonksiyon nesnesi üzerindeki tek işlem onu çağırmaktır: ``func(argument-"
"list)``."

#: library/stdtypes.rst:5183
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Fonksiyon nesnelerinin gerçekten iki çeşidi vardır: yerleşik fonksiyonlar ve "
"kullanıcı tanımlı fonksiyonlar.  Her ikisi de aynı işlemi destekler (işlevi "
"çağırmak için), ancak uygulama farklıdır, dolayısıyla farklı nesne türleri "
"vardır."

#: library/stdtypes.rst:5187
msgid "See :ref:`function` for more information."
msgstr "Daha fazla bilgi için :ref:`function` bölümüne bakınız."

#: library/stdtypes.rst:5193
msgid "Methods"
msgstr "Yöntemler"

#: library/stdtypes.rst:5197
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"Yöntemler, nitelik gösterimi kullanılarak çağrılan işlevlerdir. İki çeşidi "
"vardır: yerleşik yöntemler (listelerde :meth:`append` gibi) ve sınıf örneği "
"yöntemleri.  Yerleşik yöntemler, onları destekleyen türlerle birlikte "
"tanımlanır."

#: library/stdtypes.rst:5202
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to "
"the argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is "
"the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-"
"n)`` is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"Bir yönteme (bir sınıf ad alanında tanımlanmış bir fonksiyon) bir örnek "
"üzerinden erişirseniz, özel bir nesne elde edersiniz: bir :dfn:`bound "
"method` (ayrıca :dfn:`instance method` olarak da adlandırılır) nesnesi. "
"Çağrıldığında, ``self`` argümanını argüman listesine ekleyecektir.  Bağlı "
"metotların iki özel salt okunur niteliği vardır: ``m.__self__`` metodun "
"üzerinde çalıştığı nesne ve ``m.__func__`` metodu uygulayan fonksiyondur.  "
"``m(arg-1, arg-2, ..., arg-n)`` çağrısı tamamen ``m.__func__(m.__self__, "
"arg-1, arg-2, ..., arg-n)`` çağrısına eşdeğerdir."

#: library/stdtypes.rst:5211
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""
"Fonksiyon nesneleri gibi, bağlı metot nesneleri de keyfi nitelikler almayı "
"destekler.  Ancak, yöntem nitelikleri aslında temel işlev nesnesinde (``meth."
"__func__``) saklandığından, bağlı yöntemlerde yöntem niteliklerinin "
"ayarlanmasına izin verilmez.  Bir yöntem üzerinde bir öznitelik ayarlamaya "
"çalışmak :exc:`AttributeError` ile sonuçlanır.  Bir yöntem özniteliğini "
"ayarlamak için, bunu temel işlev nesnesi üzerinde açıkça ayarlamanız "
"gerekir::"

#: library/stdtypes.rst:5262
msgid "See :ref:`types` for more information."
msgstr "Daha fazla bilgi için :ref:`types` sayfasına bakın."

#: library/stdtypes.rst:5239
msgid "Code Objects"
msgstr "Kod Nesneleri"

#: library/stdtypes.rst:5245
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`__code__` attribute. See also the :mod:`code` module."
msgstr ""
"Kod nesneleri, uygulama tarafından bir fonksiyon gövdesi gibi \"sözde "
"derlenmiş\" çalıştırılabilir Python kodunu temsil etmek için kullanılır. "
"Fonksiyon nesnelerinden farklıdırlar çünkü global yürütme ortamlarına bir "
"referans içermezler.  Kod nesneleri yerleşik :func:`compile` işlevi "
"tarafından döndürülür ve  :attr:`__code__` niteliği aracılığıyla işlev "
"nesnelerinden çıkarılabilir. Ayrıca :mod:`code` modülüne de bakınız."

#: library/stdtypes.rst:5252
msgid ""
"Accessing ``__code__`` raises an :ref:`auditing event <auditing>` ``object."
"__getattr__`` with arguments ``obj`` and ``\"__code__\"``."
msgstr ""
"``__code__`` 'e erişmek,``obj`` ve ``\"__code__\"`` argümanlarıyla :ref:"
"`denetim etkinliği <auditing>` ``object.__getattr__`` oluşturur."

#: library/stdtypes.rst:5259
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Bir kod nesnesi (kaynak dize yerine) :func:`exec` veya :func:`eval` yerleşik "
"işlevlerine geçirilerek yürütülebilir veya değerlendirilebilir."

#: library/stdtypes.rst:5268
msgid "Type Objects"
msgstr "Type Objects"

#: library/stdtypes.rst:5274
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Type nesneleri çeşitli nesne türlerini temsil eder.  Bir nesnenin türüne "
"yerleşik işlev :func:`type` tarafından erişilir.  Türler üzerinde özel bir "
"işlem yoktur.  Standart modül :mod:`types` tüm standart yerleşik türler için "
"isimleri tanımlar."

#: library/stdtypes.rst:5279
msgid "Types are written like this: ``<class 'int'>``."
msgstr "Türler şu şekilde yazılır: ``<class 'int'>``."

#: library/stdtypes.rst:5285
msgid "The Null Object"
msgstr "Null Nesne"

#: library/stdtypes.rst:5287
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Bu nesne, açıkça bir değer döndürmeyen işlevler tarafından döndürülür.  Özel "
"operasyonları desteklemez.  Tam olarak ``None`` (yerleşik bir ad) adlı bir "
"null nesne vardır.  ``type(None)()`` aynı singleton'u üretir."

#: library/stdtypes.rst:5291
msgid "It is written as ``None``."
msgstr "''Yok'' olarak yazılmıştır."

#: library/stdtypes.rst:5298
msgid "The Ellipsis Object"
msgstr "Üç Nokta Nesnesi"

#: library/stdtypes.rst:5300
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Bu nesne genellikle dilimleme tarafından kullanılır (bkz. :ref:`slicings`).  "
"Özel operasyonları desteklemez.  Tam olarak :const:`Ellipsis` (yerleşik bir "
"ad) adında bir elips nesnesi vardır.  ``type(Ellipsis)()``, :const:"
"`Ellipsis` singletonunu üretir."

#: library/stdtypes.rst:5305
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "``Ellipsis`` veya ``...`` olarak yazılmıştır."

#: library/stdtypes.rst:5311
msgid "The NotImplemented Object"
msgstr "NotImplemented Nesnesi"

#: library/stdtypes.rst:5313
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"Bu nesne, desteklemedikleri türlerde çalışmaları istendiğinde "
"karşılaştırmalardan ve ikili işlemlerden döndürülür. Daha fazla bilgi için :"
"ref:`comparisons` sayfasına bakın.  Tam olarak bir ``NotImplemented`` "
"nesnesi vardır. ``type(NotImplemented)()``, singleton örneğini üretir."

#: library/stdtypes.rst:5318
msgid "It is written as ``NotImplemented``."
msgstr "''NotImplemented'' olarak yazılmıştır."

#: library/stdtypes.rst:5324
msgid "Boolean Values"
msgstr "Boolean Değerleri"

#: library/stdtypes.rst:5326
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""
"Boolean değerleri, ``Yanlış`` ve ``Doğru`` olmak üzere iki sabit nesnedir.  "
"Doğruluk değerlerini temsil etmek için kullanılırlar (diğer değerler de "
"yanlış veya doğru olarak kabul edilebilir).  Sayısal bağlamlarda (örneğin, "
"bir aritmetik işlecinin bağımsız değişkeni olarak kullanıldığında), "
"sırasıyla 0 ve 1 tamsayıları gibi davranırlar. Yerleşik işlev :func:`bool`, "
"değer bir doğruluk değeri olarak yorumlanabiliyorsa, herhangi bir değeri bir "
"Boolean'a dönüştürmek için kullanılabilir (yukarıdaki bölüm :ref:`truth` a "
"bakın)."

#: library/stdtypes.rst:5339
msgid "They are written as ``False`` and ``True``, respectively."
msgstr "Sırasıyla ``Yanlış`` ve ``Doğru`` olarak yazılırlar."

#: library/stdtypes.rst:5345
msgid "Internal Objects"
msgstr "İç Nesneler"

#: library/stdtypes.rst:5347
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"Bu bilgi için :ref:`types` sayfasına bakın.  Yığın çerçeve nesnelerini, geri "
"izleme nesnelerini ve dilim nesnelerini açıklar."

#: library/stdtypes.rst:5354
msgid "Special Attributes"
msgstr "Özel Özellikler"

#: library/stdtypes.rst:5356
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"Uygulama, ilgili oldukları çeşitli nesne türlerine birkaç özel salt okunur "
"öznitelik ekler.  Bunlardan bazıları :func:`dir` yerleşik işlevi tarafından "
"bildirilmez."

#: library/stdtypes.rst:5363
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"Bir nesnenin (yazılabilir) özniteliklerini depolamak için kullanılan sözlük "
"veya başka bir eşleme nesnesi."

#: library/stdtypes.rst:5369
msgid "The class to which a class instance belongs."
msgstr "Bir sınıf örneğinin ait olduğu sınıf."

#: library/stdtypes.rst:5374
msgid "The tuple of base classes of a class object."
msgstr "Bir sınıf elemanının temel sınıflarının kümesi."

#: library/stdtypes.rst:5379
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr "Sınıf, fonksiyon, yöntem, tanımlayıcı veya üretici örneğinin adı."

#: library/stdtypes.rst:5385
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
"Sınıf, fonksiyon, yöntem, tanımlayıcı veya üretici örneğinin :term:"
"`qualified name`."

#: library/stdtypes.rst:5393
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"Bu öznitelik, yöntem çözümlemesi sırasında temel sınıfları ararken dikkate "
"alınan bir sınıf kümesidir."

#: library/stdtypes.rst:5399
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"Bu yöntem, örneklerinin yöntem çözümleme sırasını özelleştirmek için bir "
"meta sınıf tarafından geçersiz kılınabilir.  Sınıf örneğinde çağrılır ve "
"sonucu :attr:`~class.__mro__` içinde depolanır."

#: library/stdtypes.rst:5406
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive.  The list is "
"in definition order.  Example::"
msgstr ""
"Her sınıf, kendi alt sınıflarına yapılan zayıf referansların bir listesini "
"tutar.  Bu yöntem, hala var olan tüm bu başvuruların bir listesini "
"döndürür.  Liste tanım sırasına göredir.  Örnek::"

#: library/stdtypes.rst:5417
msgid "Integer string conversion length limitation"
msgstr ""

#: library/stdtypes.rst:5419
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:"
"`str` to mitigate denial of service attacks. This limit *only* applies to "
"decimal or other non-power-of-two number bases. Hexadecimal, octal, and "
"binary conversions are unlimited. The limit can be configured."
msgstr ""

#: library/stdtypes.rst:5424
msgid ""
"The :class:`int` type in CPython is an abitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that "
"can convert a string to a binary integer or a binary integer to a string in "
"linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""

#: library/stdtypes.rst:5431
msgid ""
"Limiting conversion size offers a practical way to avoid `CVE-2020-10735 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-10735>`_."
msgstr ""

#: library/stdtypes.rst:5434
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr ""

#: library/stdtypes.rst:5438
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr ""

#: library/stdtypes.rst:5460
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be "
"configured is 640 digits as provided in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."
msgstr ""

#: library/stdtypes.rst:5465
#, fuzzy
msgid "Verification:"
msgstr "İşlem"

#: library/stdtypes.rst:5480
msgid "Affected APIs"
msgstr ""

#: library/stdtypes.rst:5482
msgid ""
"The limitation only applies to potentially slow conversions between :class:"
"`int` and :class:`str` or :class:`bytes`:"
msgstr ""

#: library/stdtypes.rst:5485
msgid "``int(string)`` with default base 10."
msgstr ""

#: library/stdtypes.rst:5486
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr ""

#: library/stdtypes.rst:5487
msgid "``str(integer)``."
msgstr ""

#: library/stdtypes.rst:5488
msgid "``repr(integer)``"
msgstr ""

#: library/stdtypes.rst:5489
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, ``"
"\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""

#: library/stdtypes.rst:5492
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr ""

#: library/stdtypes.rst:5494
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr ""

#: library/stdtypes.rst:5495
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ""

#: library/stdtypes.rst:5496
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ""

#: library/stdtypes.rst:5497
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ""

#: library/stdtypes.rst:5498
#, fuzzy
msgid ":class:`str` to :class:`float`."
msgstr "Set Türleri --- :class:`set`, :class:`frozenset`"

#: library/stdtypes.rst:5499
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ""

#: library/stdtypes.rst:5502
msgid "Configuring the limit"
msgstr ""

#: library/stdtypes.rst:5504
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr ""

#: library/stdtypes.rst:5507
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""

#: library/stdtypes.rst:5510
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""

#: library/stdtypes.rst:5512
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the "
"env var and the ``-X`` option are set, the ``-X`` option takes precedence. A "
"value of *-1* indicates that both were unset, thus a value of :data:`sys."
"int_info.default_max_str_digits` was used during initilization."
msgstr ""

#: library/stdtypes.rst:5518
msgid ""
"From code, you can inspect the current limit and set a new one using these :"
"mod:`sys` APIs:"
msgstr ""

#: library/stdtypes.rst:5521
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have "
"their own limit."
msgstr ""

#: library/stdtypes.rst:5525
msgid ""
"Information about the default and minimum can be found in :attr:`sys."
"int_info`:"
msgstr ""

#: library/stdtypes.rst:5527
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ""

#: library/stdtypes.rst:5529
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""

#: library/stdtypes.rst:5536
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or "
"even at installation time - anytime an up to date ``.pyc`` does not already "
"exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""

#: library/stdtypes.rst:5545
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""

#: library/stdtypes.rst:5551
msgid "Recommended configuration"
msgstr ""

#: library/stdtypes.rst:5553
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.11."
msgstr ""

#: library/stdtypes.rst:5558
#, fuzzy
msgid "Example::"
msgstr "Örnek: ::"

#: library/stdtypes.rst:5570
msgid "If you need to disable it entirely, set it to ``0``."
msgstr ""

#: library/stdtypes.rst:5574
msgid "Footnotes"
msgstr "Dipnotlar"

#: library/stdtypes.rst:5575
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Bu özel yöntemler hakkında daha fazla bilgi Python Referans El Kitabında (:"
"ref:`customization`) bulunabilir."

#: library/stdtypes.rst:5578
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"Sonuç olarak, ``[1, 2]`` listesi ``[1.0, 2.0]`` ve benzer şekilde demetler "
"için eşit kabul edilir."

#: library/stdtypes.rst:5581
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"Ayrıştırıcı, işlenenlerin türünü söyleyemediğinden sahip olmaları gerekir."

#: library/stdtypes.rst:5583
msgid ""
"Cased characters are those with general category property being one of \"Lu"
"\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Harfli karakterler, genel kategori özelliği \"Lu\" (Harf, büyük), \"Ll"
"\" (Harf, küçük harf) veya \"Lt\" (Harf, başlık) karakterlerinden biri olan "
"karakterlerdir."

#: library/stdtypes.rst:5586
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Bu nedenle, yalnızca bir tuple(demet) biçimlendirmek için, tek öğesi "
"biçimlendirilecek tuple(demet) olan tek bir tuple(demet) sağlamanız gerekir."

#~ msgid ""
#~ "Dictionaries can be created by placing a comma-separated list of ``key: "
#~ "value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}"
#~ "`` or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` "
#~ "constructor."
#~ msgstr ""
#~ "Sözlükler, ``key: value`` çiftlerinin virgülle ayrılmış bir listesini "
#~ "parantez içine yerleştirerek oluşturulabilir, örneğin: ``{'jack': 4098, "
#~ "'sjoerd': 4127}`` veya ``{4098: 'jack', 4127: 'sjoerd'}`` veya :class:"
#~ "`dict` yapıcısı ile oluşturulabilir."

#~ msgid ""
#~ "``GenericAlias`` objects are created by subscripting a class (usually a "
#~ "container), such as ``list[int]``.  They are intended primarily for :term:"
#~ "`type annotations <annotation>`."
#~ msgstr ""
#~ "``GenericAlias`` nesneleri, ``list[int]`` gibi bir sınıfın (genellikle "
#~ "bir kapsayıcı) alt kodlanmasıyla oluşturulur.  Bunlar öncelikle :term:"
#~ "`type annotations <annotation>` için tasarlanmıştır."

#~ msgid ""
#~ "Usually, the :ref:`subscription <subscriptions>` of container objects "
#~ "calls the method :meth:`__getitem__` of the object.  However, the "
#~ "subscription of some containers' classes may call the classmethod :meth:"
#~ "`__class_getitem__` of the class instead. The classmethod :meth:"
#~ "`__class_getitem__` should return a ``GenericAlias`` object."
#~ msgstr ""
#~ "Genellikle, kapsayıcı nesnelerinin :ref:`subscription <subscriptions>`, "
#~ "nesnenin :meth:`__getitem__` yöntemini çağırır.  Ancak, bazı konteyner "
#~ "sınıflarının aboneliğinin içinde sınıfın :meth:`__class_getitem__` sınıf "
#~ "metodunu çağırabilir. :meth:`__class_getitem__` sınıf yöntemi bir "
#~ "``GenerAlias`` nesnesine döndürmeli."

#~ msgid ""
#~ "If the :meth:`__getitem__` of the class' metaclass is present, it will "
#~ "take precedence over the :meth:`__class_getitem__` defined in the class "
#~ "(see :pep:`560` for more details)."
#~ msgstr ""
#~ "Sınıfın üst sınıfının :meth:`__getitem__`'i mevcutsa, sınıfta tanımlanan :"
#~ "meth:`__class_getitem__`'e göre öncelikli olacaktır (daha fazla ayrıntı "
#~ "için :pep:`560`'a bakın)."

#~ msgid ""
#~ ":meth:`__class_getitem__` -- Used to implement parameterized generics."
#~ msgstr ""
#~ ":meth:`__class_getitem__` -- Parametreli jenerikleri uygulamak için "
#~ "kullanılır."

#~ msgid ":ref:`generics` -- Generics in the :mod:`typing` module."
#~ msgstr ":ref:`generics` -- :mod:`typing` modülündeki jenerikler."
