# Python Documentation Turkish Translation
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-09-18 22:33+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: \n"
"Language-Team: TURKISH <python.docs.tr@gmail.com>\n"
"Language: tr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: library/typing.rst:3
#, fuzzy
msgid ":mod:`typing` --- Support for type hints"
msgstr ":mod:`typing` --- Tür ipuçları desteği"

#: library/typing.rst:16
#, fuzzy
msgid "**Source code:** :source:`Lib/typing.py`"
msgstr "**Kaynak kod:** :source:`Lib/typing.py`"

#: library/typing.rst:20
#, fuzzy
msgid ""
"The Python runtime does not enforce function and variable type annotations. "
"They can be used by third party tools such as type checkers, IDEs, linters, "
"etc."
msgstr ""
"Python çalışma zamanı, işlev ve değişken türü ek açıklamalarını zorunlu "
"kılmaz. Tip denetleyicileri, IDE'ler, linterler vb. gibi üçüncü taraf "
"araçlar tarafından kullanılabilirler."

#: library/typing.rst:26
#, fuzzy
msgid ""
"This module provides runtime support for type hints. For the original "
"specification of the typing system, see :pep:`484`. For a simplified "
"introduction to type hints, see :pep:`483`."
msgstr ""
"Bu modül, tür ipuçları için çalışma zamanı desteği sağlar. Yazma sisteminin "
"orijinal özellikleri için bkz. :pep:`483`. Yazım ipuçlarına basitleştirilmiş"
" bir giriş için bkz. :pep:`483`."

#: library/typing.rst:31
#, fuzzy
msgid ""
"The function below takes and returns a string and is annotated as follows::"
msgstr ""
"Aşağıdaki işlev bir dize alır ve döndürür ve aşağıdaki şekilde "
"açıklanmıştır::"

#: library/typing.rst:36
#, fuzzy
msgid ""
"In the function ``greeting``, the argument ``name`` is expected to be of "
"type :class:`str` and the return type :class:`str`. Subtypes are accepted as"
" arguments."
msgstr ""
"``greeting`` fonksiyonunda, ``name`` argümanının :class:`str` türünde ve "
":class:`str` dönüş türünde olması beklenir. Alt türler argüman olarak kabul "
"edilir."

#: library/typing.rst:40
#, fuzzy
msgid ""
"New features are frequently added to the ``typing`` module. The "
"`typing_extensions <https://pypi.org/project/typing-extensions/>`_ package "
"provides backports of these new features to older versions of Python."
msgstr ""
"``typing`` modülüne sıklıkla yeni özellikler eklenmektedir. "
"`typing_extensions <https://pypi.org/project/typing-extensions/>`_ paketi, "
"bu yeni özelliklerin Python'un eski sürümlerine desteklenmesini sağlar."

#: library/typing.rst:44
#, fuzzy
msgid ""
"For a summary of deprecated features and a deprecation timeline, please see "
"`Deprecation Timeline of Major Features`_."
msgstr ""
"Kullanımdan kaldırılan özelliklerin özeti ve kullanımdan kaldırma zaman "
"çizelgesi için lütfen `Deprecation Timeline of Major Features`_'ya bakın."

#: library/typing.rst:50
#, fuzzy
msgid ""
"`\"Typing cheat sheet\" "
"<https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html>`_"
msgstr ""
"`\"Typing cheat sheet\" "
"<https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html>`_"

#: library/typing.rst:50
#, fuzzy
msgid "A quick overview of type hints (hosted at the mypy docs)"
msgstr "Tür ipuçlarına hızlı bir genel bakış (mypy belgelerinde barındırılır)"

#: library/typing.rst:55
#, fuzzy
msgid ""
"\"Type System Reference\" section of `the mypy docs "
"<https://mypy.readthedocs.io/en/stable/index.html>`_"
msgstr ""
"`the mypy docs <https://mypy.readthedocs.io/en/stable/index.html>`_'nın "
"\"Sistem Referansını Yazın\" bölümü"

#: library/typing.rst:53
#, fuzzy
msgid ""
"The Python typing system is standardised via PEPs, so this reference should "
"broadly apply to most Python type checkers. (Some parts may still be "
"specific to mypy.)"
msgstr ""
"Python yazma sistemi PEP'ler aracılığıyla standartlaştırılmıştır, "
"dolayısıyla bu referans genel olarak çoğu Python tipi denetleyiciye "
"uygulanmalıdır. (Bazı kısımlar hala mypy'ye özel olabilir.)"

#: library/typing.rst:59
#, fuzzy
msgid ""
"`\"Static Typing with Python\" <https://typing.readthedocs.io/en/latest/>`_"
msgstr ""
"`\"Static Typing with Python\" <https://typing.readthedocs.io/en/latest/>`_"

#: library/typing.rst:58
#, fuzzy
msgid ""
"Type-checker-agnostic documentation written by the community detailing type "
"system features, useful typing related tools and typing best practices."
msgstr ""
"Topluluk tarafından yazılan, tür sistemi özelliklerini, yazımla ilgili "
"yararlı araçları ve yazımla ilgili en iyi uygulamaları ayrıntılarıyla "
"anlatan, tür denetleyiciden bağımsız belgeler."

#: library/typing.rst:65
#, fuzzy
msgid "Relevant PEPs"
msgstr "İlgili KEP'ler"

#: library/typing.rst:67
#, fuzzy
msgid ""
"Since the initial introduction of type hints in :pep:`484` and :pep:`483`, a"
" number of PEPs have modified and enhanced Python's framework for type "
"annotations:"
msgstr ""
":pep:`483` ve :pep:`483`'de tür ipuçlarının ilk kez kullanıma sunulmasından "
"bu yana, bir dizi PEP, Python'un tür açıklamalarına yönelik çerçevesini "
"değiştirdi ve geliştirdi:"

#: library/typing.rst:77
#, fuzzy
msgid ":pep:`526`: Syntax for Variable Annotations"
msgstr ":pep:`526`: Değişken Ek Açıklamalar için Sözdizimi"

#: library/typing.rst:77
#, fuzzy
msgid ""
"*Introducing* syntax for annotating variables outside of function "
"definitions, and :data:`ClassVar`"
msgstr ""
"İşlev tanımlarının dışındaki değişkenlere açıklama eklemek için "
"*Introducing* sözdizimi ve :data:`ClassVar`"

#: library/typing.rst:80
#, fuzzy
msgid ":pep:`544`: Protocols: Structural subtyping (static duck typing)"
msgstr ":pep:`544`: Protokoller: Yapısal alt tipleme (statik ördek yazma)"

#: library/typing.rst:80
#, fuzzy
msgid ""
"*Introducing* :class:`Protocol` and the "
":func:`@runtime_checkable<runtime_checkable>` decorator"
msgstr ""
"*Introducing* :class:`Protocol` ve "
":func:`@runtime_checkable<runtime_checkable>` dekoratörü"

#: library/typing.rst:83
#, fuzzy
msgid ":pep:`585`: Type Hinting Generics In Standard Collections"
msgstr ":pep:`585`: Standart Koleksiyonlarda Tip İpucu Jenerikleri"

#: library/typing.rst:83
#, fuzzy
msgid ""
"*Introducing* :class:`types.GenericAlias` and the ability to use standard "
"library classes as :ref:`generic types<types-genericalias>`"
msgstr ""
"*Introducing* :class:`types.GenericAlias` ve standart kütüphane sınıflarını "
":ref:`generic types<types-genericalias>` olarak kullanma yeteneği"

#: library/typing.rst:85
#, fuzzy
msgid ":pep:`586`: Literal Types"
msgstr ":pep:`586`: Değişmez Türler"

#: library/typing.rst:86
#, fuzzy
msgid "*Introducing* :data:`Literal`"
msgstr "*Introducing* :data:`Literal`"

#: library/typing.rst:87
#, fuzzy
msgid ""
":pep:`589`: TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys"
msgstr ""
":pep:`589`: TypedDict: Sabit Tuş Grubuna Sahip Sözlükler için Yazım İpuçları"

#: library/typing.rst:88
#, fuzzy
msgid "*Introducing* :class:`TypedDict`"
msgstr "*Introducing* :class:`TypedDict`"

#: library/typing.rst:89
#, fuzzy
msgid ":pep:`591`: Adding a final qualifier to typing"
msgstr ":pep:`591`: Yazmaya son bir niteleyici ekleme"

#: library/typing.rst:90
#, fuzzy
msgid "*Introducing* :data:`Final` and the :func:`@final<final>` decorator"
msgstr "*Introducing* :data:`Final` ve :func:`@final<final>` dekoratörü"

#: library/typing.rst:91
#, fuzzy
msgid ":pep:`593`: Flexible function and variable annotations"
msgstr ":pep:`593`: Esnek işlev ve değişken açıklamalar"

#: library/typing.rst:92
#, fuzzy
msgid "*Introducing* :data:`Annotated`"
msgstr "*Introducing* :data:`Annotated`"

#: library/typing.rst:95
#, fuzzy
msgid ":pep:`604`: Allow writing union types as ``X | Y``"
msgstr ":pep:`604`: Birleşim türlerinin ``X | Y`` olarak yazılmasına izin ver"

#: library/typing.rst:94
#, fuzzy
msgid ""
"*Introducing* :data:`types.UnionType` and the ability to use the binary-or "
"operator ``|`` to signify a :ref:`union of types<types-union>`"
msgstr ""
"*Introducing* :data:`types.UnionType` ve bir :ref:`union of types<types-"
"union>`'u belirtmek için ikili veya ``|`` operatörünü kullanma yeteneği"

#: library/typing.rst:97
#, fuzzy
msgid ":pep:`612`: Parameter Specification Variables"
msgstr ":pep:`612`: Parametre Belirtim Değişkenleri"

#: library/typing.rst:98
#, fuzzy
msgid "*Introducing* :class:`ParamSpec` and :data:`Concatenate`"
msgstr "*Introducing* :class:`ParamSpec` ve :data:`Concatenate`"

#: library/typing.rst:99
#, fuzzy
msgid ":pep:`613`: Explicit Type Aliases"
msgstr ":pep:`613`: Açık Tür Takma Adları"

#: library/typing.rst:100
#, fuzzy
msgid "*Introducing* :data:`TypeAlias`"
msgstr "*Introducing* :data:`TypeAlias`"

#: library/typing.rst:101
#, fuzzy
msgid ":pep:`646`: Variadic Generics"
msgstr ":pep:`646`: Değişken Jenerikler"

#: library/typing.rst:102
#, fuzzy
msgid "*Introducing* :data:`TypeVarTuple`"
msgstr "*Introducing* :data:`TypeVarTuple`"

#: library/typing.rst:103
#, fuzzy
msgid ":pep:`647`: User-Defined Type Guards"
msgstr ":pep:`647`: Kullanıcı Tanımlı Tip Korumalar"

#: library/typing.rst:104
#, fuzzy
msgid "*Introducing* :data:`TypeGuard`"
msgstr "*Introducing* :data:`TypeGuard`"

#: library/typing.rst:105
#, fuzzy
msgid ""
":pep:`655`: Marking individual TypedDict items as required or potentially "
"missing"
msgstr ""
":pep:`655`: Bireysel TypedDict öğelerini gerekli veya potansiyel olarak "
"eksik olarak işaretleme"

#: library/typing.rst:106
#, fuzzy
msgid "*Introducing* :data:`Required` and :data:`NotRequired`"
msgstr "*Introducing* :data:`NotRequired` ve :data:`NotRequired`"

#: library/typing.rst:107
#, fuzzy
msgid ":pep:`673`: Self type"
msgstr ":pep:`673`: Kendi kendine tip"

#: library/typing.rst:108
#, fuzzy
msgid "*Introducing* :data:`Self`"
msgstr "*Introducing* :data:`Self`"

#: library/typing.rst:109
#, fuzzy
msgid ":pep:`675`: Arbitrary Literal String Type"
msgstr ":pep:`675`: Keyfi Değişmez Dize Türü"

#: library/typing.rst:110
#, fuzzy
msgid "*Introducing* :data:`LiteralString`"
msgstr "*Introducing* :data:`LiteralString`"

#: library/typing.rst:111
#, fuzzy
msgid ":pep:`681`: Data Class Transforms"
msgstr ":pep:`681`: Veri Sınıfı Dönüşümleri"

#: library/typing.rst:112
#, fuzzy
msgid ""
"*Introducing* the :func:`@dataclass_transform<dataclass_transform>` "
"decorator"
msgstr ""
"*Introducing*, :func:`@dataclass_transform<dataclass_transform>` dekoratörü"

#: library/typing.rst:114
#, fuzzy
msgid ":pep:`692`: Using ``TypedDict`` for more precise ``**kwargs`` typing"
msgstr ""
":pep:`692`: Daha hassas ``**kwargs`` yazımı için ``**kwargs``'ü kullanma"

#: library/typing.rst:114
#, fuzzy
msgid ""
"*Introducing* a new way of typing ``**kwargs`` with :data:`Unpack` and "
":data:`TypedDict`"
msgstr ""
"*Introducing*, :data:`TypedDict` ve :data:`TypedDict` ile ``**kwargs`` "
"yazmanın yeni bir yolu"

#: library/typing.rst:116
#, fuzzy
msgid ":pep:`695`: Type Parameter Syntax"
msgstr ":pep:`695`: Tip Parametre Söz Dizimi"

#: library/typing.rst:117
#, fuzzy
msgid ""
"*Introducing* builtin syntax for creating generic functions, classes, and "
"type aliases."
msgstr ""
"Genel işlevler, sınıflar ve tür takma adları oluşturmaya yönelik "
"*Introducing* yerleşik sözdizimi."

#: library/typing.rst:119
#, fuzzy
msgid ":pep:`698`: Adding an override decorator to typing"
msgstr ":pep:`698`: Yazmaya geçersiz kılma dekoratörü ekleme"

#: library/typing.rst:119
#, fuzzy
msgid "*Introducing* the :func:`@override<override>` decorator"
msgstr "*Introducing*, :func:`@override<override>` dekoratörü"

#: library/typing.rst:129
#, fuzzy
msgid "Type aliases"
msgstr "Takma adları yazın"

#: library/typing.rst:131
#, fuzzy
msgid ""
"A type alias is defined using the :keyword:`type` statement, which creates "
"an instance of :class:`TypeAliasType`. In this example, ``Vector`` and "
"``list[float]`` will be treated equivalently by static type checkers::"
msgstr ""
"Bir tür takma adı, :class:`TypeAliasType` örneğini oluşturan :keyword:`type`"
" deyimi kullanılarak tanımlanır. Bu örnekte, ``list[float]`` ve "
"``list[float]``, statik tür denetleyiciler tarafından eşit şekilde ele "
"alınacaktır::"

#: library/typing.rst:144
#, fuzzy
msgid ""
"Type aliases are useful for simplifying complex type signatures. For "
"example::"
msgstr ""
"Tür takma adları, karmaşık tür imzalarını basitleştirmek için kullanışlıdır."
" Örneğin::"

#: library/typing.rst:162
#, fuzzy
msgid ""
"The :keyword:`type` statement is new in Python 3.12. For backwards "
"compatibility, type aliases can also be created through simple assignment::"
msgstr ""
":keyword:`type` ifadesi Python 3.12'deki yeni bir özelliktir. Geriye dönük "
"uyumluluk için, basit atama yoluyla tür takma adları da oluşturulabilir::"

#: library/typing.rst:167
#, fuzzy
msgid ""
"Or marked with :data:`TypeAlias` to make it explicit that this is a type "
"alias, not a normal variable assignment::"
msgstr ""
"Veya bunun normal bir değişken ataması değil, bir tür takma adı olduğunu "
"açıkça belirtmek için :data:`TypeAlias` ile işaretlendi::"

#: library/typing.rst:177
#, fuzzy
msgid "NewType"
msgstr "Yeni tip"

#: library/typing.rst:179
#, fuzzy
msgid "Use the :class:`NewType` helper to create distinct types::"
msgstr ""
"Farklı türler oluşturmak için :class:`NewType` yardımcısını kullanın::"

#: library/typing.rst:186
#, fuzzy
msgid ""
"The static type checker will treat the new type as if it were a subclass of "
"the original type. This is useful in helping catch logical errors::"
msgstr ""
"Statik tür denetleyicisi, yeni türü orijinal türün bir alt sınıfıymış gibi "
"ele alacaktır. Bu, mantıksal hataların yakalanmasına yardımcı olmak "
"açısından faydalıdır::"

#: library/typing.rst:198
#, fuzzy
msgid ""
"You may still perform all ``int`` operations on a variable of type "
"``UserId``, but the result will always be of type ``int``. This lets you "
"pass in a ``UserId`` wherever an ``int`` might be expected, but will prevent"
" you from accidentally creating a ``UserId`` in an invalid way::"
msgstr ""
"Tüm ``UserId`` işlemlerini ``UserId`` türündeki bir değişken üzerinde "
"gerçekleştirmeye devam edebilirsiniz ancak sonuç her zaman ``UserId`` "
"türünde olacaktır. Bu, bir ``UserId``'ün beklendiği her yere bir ``UserId`` "
"aktarmanıza olanak tanır, ancak yanlışlıkla geçersiz bir şekilde bir "
"``UserId`` oluşturmanızı da engeller::"

#: library/typing.rst:206
#, fuzzy
msgid ""
"Note that these checks are enforced only by the static type checker. At "
"runtime, the statement ``Derived = NewType('Derived', Base)`` will make "
"``Derived`` a callable that immediately returns whatever parameter you pass "
"it. That means the expression ``Derived(some_value)`` does not create a new "
"class or introduce much overhead beyond that of a regular function call."
msgstr ""
"Bu kontrollerin yalnızca statik tip denetleyicisi tarafından uygulandığını "
"unutmayın. Çalışma zamanında, ``Derived(some_value)`` ifadesi, "
"``Derived(some_value)``'ü, ilettiğiniz parametre ne olursa olsun hemen "
"döndüren bir çağrılabilir hale getirecektir. Bu, ``Derived(some_value)`` "
"ifadesinin yeni bir sınıf oluşturmadığı veya normal bir işlev çağrısının "
"ötesinde fazla yük getirmediği anlamına gelir."

#: library/typing.rst:212
#, fuzzy
msgid ""
"More precisely, the expression ``some_value is Derived(some_value)`` is "
"always true at runtime."
msgstr ""
"Daha doğrusu, ``some_value is Derived(some_value)`` ifadesi çalışma "
"zamanında her zaman doğrudur."

#: library/typing.rst:215
#, fuzzy
msgid "It is invalid to create a subtype of ``Derived``::"
msgstr "``Derived``'ün alt türünü oluşturmak geçersizdir::"

#: library/typing.rst:224
#, fuzzy
msgid ""
"However, it is possible to create a :class:`NewType` based on a 'derived' "
"``NewType``::"
msgstr ""
"Ancak 'türetilmiş' bir ``NewType``'ü temel alan bir :class:`NewType` "
"oluşturmak mümkündür::"

#: library/typing.rst:232
#, fuzzy
msgid "and typechecking for ``ProUserId`` will work as expected."
msgstr "ve ``ProUserId`` için yazım denetimi beklendiği gibi çalışacaktır."

#: library/typing.rst:234
#, fuzzy
msgid "See :pep:`484` for more details."
msgstr "Daha fazla ayrıntı için :pep:`484`'e bakın."

#: library/typing.rst:238
#, fuzzy
msgid ""
"Recall that the use of a type alias declares two types to be *equivalent* to"
" one another. Doing ``type Alias = Original`` will make the static type "
"checker treat ``Alias`` as being *exactly equivalent* to ``Original`` in all"
" cases. This is useful when you want to simplify complex type signatures."
msgstr ""
"Bir tür takma adının kullanılmasının, iki türün birbirine *exactly "
"equivalent* olduğunu bildirdiğini hatırlayın. ``Original``'ün yapılması, "
"statik tür denetleyicinin ``Original``'ü her durumda *exactly equivalent* "
"ila ``Original`` olarak değerlendirmesini sağlayacaktır. Bu, karmaşık "
"türdeki imzaları basitleştirmek istediğinizde kullanışlıdır."

#: library/typing.rst:243
#, fuzzy
msgid ""
"In contrast, ``NewType`` declares one type to be a *subtype* of another. "
"Doing ``Derived = NewType('Derived', Original)`` will make the static type "
"checker treat ``Derived`` as a *subclass* of ``Original``, which means a "
"value of type ``Original`` cannot be used in places where a value of type "
"``Derived`` is expected. This is useful when you want to prevent logic "
"errors with minimal runtime cost."
msgstr ""
"Buna karşılık, ``Derived`` bir türün diğerinin *subclass*'i olduğunu "
"bildirir. ``Derived`` yapmak, statik tür denetleyicinin ``Derived``'ü "
"``Derived``'ün *subclass*'i olarak değerlendirmesini sağlayacaktır; bu, "
"``Derived`` türünde bir değerin beklendiği yerlerde ``Derived`` türünde bir "
"değerin kullanılamayacağı anlamına gelir. Bu, minimum çalışma zamanı "
"maliyetiyle mantık hatalarını önlemek istediğinizde kullanışlıdır."

#: library/typing.rst:252
#, fuzzy
msgid ""
"``NewType`` is now a class rather than a function.  As a result, there is "
"some additional runtime cost when calling ``NewType`` over a regular "
"function."
msgstr ""
"``NewType`` artık bir işlevden ziyade bir sınıftır. Sonuç olarak, "
"``NewType``'ü normal bir işlev üzerinden çağırırken bazı ek çalışma zamanı "
"maliyeti ortaya çıkar."

#: library/typing.rst:257
#, fuzzy
msgid ""
"The performance of calling ``NewType`` has been restored to its level in "
"Python 3.9."
msgstr ""
"``NewType``'ü çağırma performansı Python 3.9'daki seviyesine geri getirildi."

#: library/typing.rst:264
#, fuzzy
msgid "Annotating callable objects"
msgstr "Çağrılabilir nesnelere açıklama ekleme"

#: library/typing.rst:266
#, fuzzy
msgid ""
"Functions -- or other :term:`callable` objects -- can be annotated using "
":class:`collections.abc.Callable` or :data:`typing.Callable`. "
"``Callable[[int], str]`` signifies a function that takes a single parameter "
"of type :class:`int` and returns a :class:`str`."
msgstr ""
"İşlevlere veya diğer :term:`callable` nesnelerine :class:`str` veya "
":data:`typing.Callable` kullanılarak açıklama eklenebilir. ``Callable[[int],"
" str]``, :class:`str` türünde tek bir parametre alan ve bir :class:`str` "
"döndüren bir işlevi belirtir."

#: library/typing.rst:2873 library/typing.rst:3015
#, fuzzy
msgid "For example:"
msgstr "Örneğin:"

#: library/typing.rst:289
#, fuzzy
msgid ""
"The subscription syntax must always be used with exactly two values: the "
"argument list and the return type.  The argument list must be a list of "
"types, a :class:`ParamSpec`, :data:`Concatenate`, or an ellipsis. The return"
" type must be a single type."
msgstr ""
"Abonelik sözdizimi her zaman tam olarak iki değerle kullanılmalıdır: "
"bağımsız değişken listesi ve dönüş türü. Bağımsız değişken listesi bir tür "
"listesi, bir :class:`ParamSpec`, :data:`Concatenate` veya bir üç nokta "
"olmalıdır. Dönüş türü tek bir tür olmalıdır."

#: library/typing.rst:294
#, fuzzy
msgid ""
"If a literal ellipsis ``...`` is given as the argument list, it indicates "
"that a callable with any arbitrary parameter list would be acceptable:"
msgstr ""
"Bağımsız değişken listesi olarak gerçek bir üç nokta ``...`` verilirse, bu, "
"herhangi bir isteğe bağlı parametre listesiyle çağrılabilir olanın kabul "
"edilebilir olacağını gösterir:"

#: library/typing.rst:306
#, fuzzy
msgid ""
"``Callable`` cannot express complex signatures such as functions that take a"
" variadic number of arguments, :func:`overloaded functions <overload>`, or "
"functions that have keyword-only parameters. However, these signatures can "
"be expressed by defining a :class:`Protocol` class with a "
":meth:`~object.__call__` method:"
msgstr ""
"``Callable``, değişken sayıda bağımsız değişken alan işlevler, "
":func:`overloaded functions <overload>` veya yalnızca anahtar kelimeden "
"oluşan parametrelere sahip işlevler gibi karmaşık imzaları ifade edemez. "
"Ancak bu imzalar, :meth:`~object.__call__` yöntemiyle bir :class:`Protocol` "
"sınıfı tanımlanarak ifade edilebilir:"

#: library/typing.rst:333
#, fuzzy
msgid ""
"Callables which take other callables as arguments may indicate that their "
"parameter types are dependent on each other using :class:`ParamSpec`. "
"Additionally, if that callable adds or removes arguments from other "
"callables, the :data:`Concatenate` operator may be used.  They take the form"
" ``Callable[ParamSpecVariable, ReturnType]`` and "
"``Callable[Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable], "
"ReturnType]`` respectively."
msgstr ""
"Diğer çağrılabilirleri bağımsız değişken olarak alan çağrılabilirler, "
":class:`ParamSpec`'u kullanarak parametre türlerinin birbirine bağlı "
"olduğunu gösterebilir. Ek olarak, eğer bu çağrılabilir diğer "
"çağrılabilirlere argüman eklerse veya bunlardan argümanları çıkarırsa, "
":data:`Concatenate` operatörü kullanılabilir. Sırasıyla "
"``Callable[Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable], "
"ReturnType]`` ve ``Callable[Concatenate[Arg1Type, Arg2Type, ..., "
"ParamSpecVariable], ReturnType]`` formunu alırlar."

#: library/typing.rst:3544
#, fuzzy
msgid ""
"``Callable`` now supports :class:`ParamSpec` and :data:`Concatenate`. See "
":pep:`612` for more details."
msgstr ""
"``Callable`` artık :class:`ParamSpec` ve :data:`Concatenate`'yi destekliyor."
" Daha fazla ayrıntı için :pep:`612`'e bakın."

#: library/typing.rst:346
#, fuzzy
msgid ""
"The documentation for :class:`ParamSpec` and :class:`Concatenate` provides "
"examples of usage in ``Callable``."
msgstr ""
":class:`Concatenate` ve :class:`Concatenate` belgelerinde ``Callable``'teki "
"kullanım örnekleri verilmektedir."

#: library/typing.rst:352
#, fuzzy
msgid "Generics"
msgstr "Jenerikler"

#: library/typing.rst:354
#, fuzzy
msgid ""
"Since type information about objects kept in containers cannot be statically"
" inferred in a generic way, many container classes in the standard library "
"support subscription to denote the expected types of container elements."
msgstr ""
"Kaplarda tutulan nesnelere ilişkin tür bilgileri genel bir şekilde statik "
"olarak çıkarılamadığından, standart kitaplıktaki birçok kapsayıcı sınıfı, "
"beklenen kapsayıcı öğeleri türlerini belirtmek için aboneliği destekler."

#: library/typing.rst:371
#, fuzzy
msgid ""
"Generic functions and classes can be parameterized by using :ref:`type "
"parameter syntax <type-params>`::"
msgstr ""
"Genel işlevler ve sınıflar :ref:`type parameter syntax <type-params>`:: "
"kullanılarak parametrelendirilebilir."

#: library/typing.rst:379
#, fuzzy
msgid "Or by using the :class:`TypeVar` factory directly::"
msgstr "Veya doğrudan :class:`TypeVar` fabrikasını kullanarak::"

#: library/typing.rst:389
#, fuzzy
msgid "Syntactic support for generics is new in Python 3.12."
msgstr "Jenerikler için sözdizimsel destek Python 3.12'de yenidir."

#: library/typing.rst:395
#, fuzzy
msgid "Annotating tuples"
msgstr "Açıklama grupları"

#: library/typing.rst:397
#, fuzzy
msgid ""
"For most containers in Python, the typing system assumes that all elements "
"in the container will be of the same type. For example::"
msgstr ""
"Python'daki çoğu kapsayıcı için yazma sistemi, kapsayıcıdaki tüm öğelerin "
"aynı türde olacağını varsayar. Örneğin::"

#: library/typing.rst:412
#, fuzzy
msgid ""
":class:`list` only accepts one type argument, so a type checker would emit "
"an error on the ``y`` assignment above. Similarly, "
":class:`~collections.abc.Mapping` only accepts two type arguments: the first"
" indicates the type of the keys, and the second indicates the type of the "
"values."
msgstr ""
":class:`~collections.abc.Mapping` yalnızca bir tür bağımsız değişkenini "
"kabul eder, dolayısıyla bir tür denetleyici yukarıdaki ``y`` atamasında bir "
"hata verecektir. Benzer şekilde, :class:`~collections.abc.Mapping` yalnızca "
"iki tür bağımsız değişkeni kabul eder: birincisi anahtarların türünü, "
"ikincisi ise değerlerin türünü gösterir."

#: library/typing.rst:418
#, fuzzy
msgid ""
"Unlike most other Python containers, however, it is common in idiomatic "
"Python code for tuples to have elements which are not all of the same type. "
"For this reason, tuples are special-cased in Python's typing system. "
":class:`tuple` accepts *any number* of type arguments::"
msgstr ""
"Bununla birlikte, diğer Python kapsayıcılarının çoğundan farklı olarak, "
"deyimsel Python kodunda demetlerin tümü aynı türde olmayan öğelere sahip "
"olması yaygındır. Bu nedenle Python'un yazma sisteminde tuple'lar özel "
"kasalıdır. :class:`tuple`, *any number* tipi bağımsız değişkenleri kabul "
"eder::"

#: library/typing.rst:434
#, fuzzy
msgid ""
"To denote a tuple which could be of *any* length, and in which all elements "
"are of the same type ``T``, use ``tuple[T, ...]``. To denote an empty tuple,"
" use ``tuple[()]``. Using plain ``tuple`` as an annotation is equivalent to "
"using ``tuple[Any, ...]``::"
msgstr ""
"*any* uzunluğunda olabilecek ve içindeki tüm öğelerin aynı ``tuple[Any, "
"...]`` türünde olduğu bir demet belirtmek için ``tuple[Any, ...]``'ü "
"kullanın. Boş bir demet belirtmek için ``tuple[Any, ...]``'ü kullanın. Düz "
"``tuple[Any, ...]``'ü ek açıklama olarak kullanmak, ``tuple[Any, ...]``:: "
"kullanmaya eşdeğerdir:"

#: library/typing.rst:457
#, fuzzy
msgid "The type of class objects"
msgstr "Sınıf nesnelerinin türü"

#: library/typing.rst:459
#, fuzzy
msgid ""
"A variable annotated with ``C`` may accept a value of type ``C``. In "
"contrast, a variable annotated with ``type[C]`` (or :class:`typing.Type[C] "
"<Type>`) may accept values that are classes themselves -- specifically, it "
"will accept the *class object* of ``C``. For example::"
msgstr ""
"``C`` ile açıklama eklenmiş bir değişken, ``C`` türünde bir değeri kabul "
"edebilir. Buna karşılık, ``C`` (veya :class:`typing.Type[C] <Type>`) ile "
"açıklamalı bir değişken, bizzat sınıf olan değerleri kabul edebilir; "
"özellikle ``C``'ün *class object*'ini kabul eder. Örneğin::"

#: library/typing.rst:469
#, fuzzy
msgid "Note that ``type[C]`` is covariant::"
msgstr "``type[C]``'ün kovaryant olduğunu unutmayın::"

#: library/typing.rst:485
#, fuzzy
msgid ""
"The only legal parameters for :class:`type` are classes, :data:`Any`, "
":ref:`type variables <generics>`, and unions of any of these types. For "
"example::"
msgstr ""
":class:`type` için yegane yasal parametreler sınıflar, :data:`Any`, "
":ref:`type variables <generics>` ve bu türlerden herhangi birinin "
"birleşimidir. Örneğin::"

#: library/typing.rst:497
#, fuzzy
msgid ""
"``type[Any]`` is equivalent to :class:`type`, which is the root of Python's "
":ref:`metaclass hierarchy <metaclasses>`."
msgstr ""
"``type[Any]``, Python'un :ref:`metaclass hierarchy <metaclasses>`'unun kökü "
"olan :class:`type`'a eşdeğerdir."

#: library/typing.rst:503
#, fuzzy
msgid "User-defined generic types"
msgstr "Kullanıcı tanımlı genel türler"

#: library/typing.rst:505
#, fuzzy
msgid "A user-defined class can be defined as a generic class."
msgstr "Kullanıcı tanımlı bir sınıf genel bir sınıf olarak tanımlanabilir."

#: library/typing.rst:528
#, fuzzy
msgid ""
"This syntax indicates that the class ``LoggedVar`` is parameterised around a"
" single :class:`type variable <TypeVar>` ``T`` . This also makes ``T`` valid"
" as a type within the class body."
msgstr ""
"Bu sözdizimi, ``T`` sınıfının tek bir :class:`type variable <TypeVar>` ``T``"
" etrafında parametrelendirildiğini gösterir. Bu aynı zamanda ``T``'ü sınıf "
"gövdesi içindeki bir tür olarak geçerli kılar."

#: library/typing.rst:532
#, fuzzy
msgid ""
"Generic classes implicitly inherit from :class:`Generic`. For compatibility "
"with Python 3.11 and lower, it is also possible to inherit explicitly from "
":class:`Generic` to indicate a generic class::"
msgstr ""
"Genel sınıflar dolaylı olarak :class:`Generic`'dan miras alır. Python 3.11 "
"ve daha düşük sürümlerle uyumluluk için, genel bir sınıfı belirtmek üzere "
":class:`Generic`'dan açıkça miras almak da mümkündür::"

#: library/typing.rst:543
#, fuzzy
msgid ""
"Generic classes have :meth:`~object.__class_getitem__` methods, meaning they"
" can be parameterised at runtime (e.g. ``LoggedVar[int]`` below)::"
msgstr ""
"Genel sınıfların :meth:`~object.__class_getitem__` yöntemleri vardır, yani "
"çalışma zamanında parametrelendirilebilirler (örn. aşağıdaki "
"``LoggedVar[int]``)::"

#: library/typing.rst:552
#, fuzzy
msgid ""
"A generic type can have any number of type variables. All varieties of "
":class:`TypeVar` are permissible as parameters for a generic type::"
msgstr ""
"Genel bir tür, herhangi bir sayıda tür değişkenine sahip olabilir. "
":class:`TypeVar`'un tüm çeşitlerine genel bir tür için parametre olarak izin"
" verilir::"

#: library/typing.rst:567
#, fuzzy
msgid ""
"Each type variable argument to :class:`Generic` must be distinct. This is "
"thus invalid::"
msgstr ""
":class:`Generic`'a yönelik her tür değişkeni bağımsız değişkeni farklı "
"olmalıdır. Bu nedenle geçersiz::"

#: library/typing.rst:581
#, fuzzy
msgid "Generic classes can also inherit from other classes::"
msgstr "Genel sınıflar ayrıca diğer sınıflardan da miras alabilir::"

#: library/typing.rst:588
#, fuzzy
msgid ""
"When inheriting from generic classes, some type parameters could be fixed::"
msgstr ""
"Genel sınıflardan miras alırken bazı tür parametreleri düzeltilebilir::"

#: library/typing.rst:595
#, fuzzy
msgid "In this case ``MyDict`` has a single parameter, ``T``."
msgstr "Bu durumda ``T``'ün tek bir parametresi vardır: ``T``."

#: library/typing.rst:597
#, fuzzy
msgid ""
"Using a generic class without specifying type parameters assumes :data:`Any`"
" for each position. In the following example, ``MyIterable`` is not generic "
"but implicitly inherits from ``Iterable[Any]``:"
msgstr ""
"Tür parametrelerini belirtmeden genel bir sınıf kullanıldığında, her konum "
"için :data:`Any` varsayılır. Aşağıdaki örnekte, ``Iterable[Any]`` genel "
"değildir ancak dolaylı olarak ``Iterable[Any]``'ten miras alır:"

#: library/typing.rst:608
#, fuzzy
msgid "User-defined generic type aliases are also supported. Examples::"
msgstr "Kullanıcı tanımlı genel tür takma adları da desteklenir. Örnekler::"

#: library/typing.rst:623
#, fuzzy
msgid ""
"For backward compatibility, generic type aliases can also be created through"
" a simple assignment::"
msgstr ""
"Geriye dönük uyumluluk için genel tür takma adları da basit bir atama "
"yoluyla oluşturulabilir::"

#: library/typing.rst:632
#, fuzzy
msgid ":class:`Generic` no longer has a custom metaclass."
msgstr ":class:`Generic`'un artık özel bir meta sınıfı yok."

#: library/typing.rst:635
#, fuzzy
msgid ""
"Syntactic support for generics and type aliases is new in version 3.12. "
"Previously, generic classes had to explicitly inherit from :class:`Generic` "
"or contain a type variable in one of their bases."
msgstr ""
"Jenerikler ve tür takma adları için sözdizimsel destek, sürüm 3.12'de "
"yenidir. Daha önce genel sınıfların açıkça :class:`Generic`'dan miras alması"
" veya tabanlarından birinde bir tür değişkeni içermesi gerekiyordu."

#: library/typing.rst:640
#, fuzzy
msgid ""
"User-defined generics for parameter expressions are also supported via "
"parameter specification variables in the form ``[**P]``.  The behavior is "
"consistent with type variables' described above as parameter specification "
"variables are treated by the typing module as a specialized type variable.  "
"The one exception to this is that a list of types can be used to substitute "
"a :class:`ParamSpec`::"
msgstr ""
"Parametre ifadelerine yönelik kullanıcı tanımlı jenerikler ayrıca ``[**P]`` "
"formundaki parametre belirtimi değişkenleri aracılığıyla da desteklenir. "
"Parametre belirtimi değişkenleri, yazma modülü tarafından özel bir tür "
"değişkeni olarak ele alındığından, davranış yukarıda açıklanan tür "
"değişkenleriyle tutarlıdır. Bunun tek istisnası, :class:`ParamSpec`'un "
"yerine tür listesi kullanılabilmesidir::"

#: library/typing.rst:651
#, fuzzy
msgid ""
"Classes generic over a :class:`ParamSpec` can also be created using explicit"
" inheritance from :class:`Generic`. In this case, ``**`` is not used::"
msgstr ""
":class:`Generic` üzerinden genel sınıflar, :class:`Generic`'dan açık "
"devralma kullanılarak da oluşturulabilir. Bu durumda ``**`` kullanılmaz::"

#: library/typing.rst:661
#, fuzzy
msgid ""
"Another difference between :class:`TypeVar` and :class:`ParamSpec` is that a"
" generic with only one parameter specification variable will accept "
"parameter lists in the forms ``X[[Type1, Type2, ...]]`` and also ``X[Type1, "
"Type2, ...]`` for aesthetic reasons.  Internally, the latter is converted to"
" the former, so the following are equivalent::"
msgstr ""
":class:`ParamSpec` ve :class:`ParamSpec` arasındaki diğer bir fark, yalnızca"
" bir parametre spesifikasyon değişkenine sahip bir jeneriğin, estetik "
"nedenlerle ``X[Type1, Type2, ...]`` ve ayrıca ``X[Type1, Type2, ...]`` "
"formlarındaki parametre listelerini kabul etmesidir. Dahili olarak ikincisi "
"birinciye dönüştürülür, dolayısıyla aşağıdakiler eşdeğerdir::"

#: library/typing.rst:674
#, fuzzy
msgid ""
"Note that generics with :class:`ParamSpec` may not have correct "
"``__parameters__`` after substitution in some cases because they are "
"intended primarily for static type checking."
msgstr ""
":class:`ParamSpec`'lu jeneriklerin bazı durumlarda değiştirildikten sonra "
"doğru ``__parameters__``'e sahip olmayabileceğini unutmayın; çünkü bunların "
"esas olarak statik tür kontrolü amaçlı olması gerekir."

#: library/typing.rst:678
#, fuzzy
msgid ""
":class:`Generic` can now be parameterized over parameter expressions. See "
":class:`ParamSpec` and :pep:`612` for more details."
msgstr ""
":class:`ParamSpec` artık parametre ifadeleri üzerinden "
"parametrelendirilebilir. Daha fazla ayrıntı için :class:`ParamSpec` ve "
":pep:`612`'e bakın."

#: library/typing.rst:682
#, fuzzy
msgid ""
"A user-defined generic class can have ABCs as base classes without a "
"metaclass conflict. Generic metaclasses are not supported. The outcome of "
"parameterizing generics is cached, and most types in the typing module are "
":term:`hashable` and comparable for equality."
msgstr ""
"Kullanıcı tanımlı bir genel sınıf, metasınıf çatışması olmaksızın temel "
"sınıflar olarak ABC'lere sahip olabilir. Genel metasınıflar desteklenmez. "
"Jeneriklerin parametreleştirilmesinin sonucu önbelleğe alınır ve yazma "
"modülündeki çoğu tür :term:`hashable`'tür ve eşitlik açısından "
"karşılaştırılabilir."

#: library/typing.rst:689
#, fuzzy
msgid "The :data:`Any` type"
msgstr ":data:`Any` türü"

#: library/typing.rst:691
#, fuzzy
msgid ""
"A special kind of type is :data:`Any`. A static type checker will treat "
"every type as being compatible with :data:`Any` and :data:`Any` as being "
"compatible with every type."
msgstr ""
"Özel bir tür :data:`Any`'dir. Statik tür denetleyici, her türü :data:`Any` "
"ile uyumlu, :data:`Any`'yi ise her türle uyumlu olarak değerlendirecektir."

#: library/typing.rst:695
#, fuzzy
msgid ""
"This means that it is possible to perform any operation or method call on a "
"value of type :data:`Any` and assign it to any variable::"
msgstr ""
"Bu, :data:`Any` tipi bir değer üzerinde herhangi bir işlem veya yöntem "
"çağrısı gerçekleştirmenin ve bunu herhangi bir değişkene atamanın mümkün "
"olduğu anlamına gelir::"

#: library/typing.rst:713
#, fuzzy
msgid ""
"Notice that no type checking is performed when assigning a value of type "
":data:`Any` to a more precise type. For example, the static type checker did"
" not report an error when assigning ``a`` to ``s`` even though ``s`` was "
"declared to be of type :class:`str` and receives an :class:`int` value at "
"runtime!"
msgstr ""
":data:`Any` türünde bir değer daha kesin bir türe atanırken hiçbir tür "
"denetimi yapılmadığına dikkat edin. Örneğin, ``s``'ün :class:`int` türünde "
"olduğu bildirilmesine ve çalışma zamanında bir :class:`int` değeri almasına "
"rağmen statik tür denetleyici, ``s``'ü ``s``'e atarken bir hata bildirmedi!"

#: library/typing.rst:719
#, fuzzy
msgid ""
"Furthermore, all functions without a return type or parameter types will "
"implicitly default to using :data:`Any`::"
msgstr ""
"Ayrıca, dönüş türü veya parametre türü olmayan tüm işlevler, varsayılan "
"olarak :data:`Any`:: kullanımını varsayılan olarak kullanacaktır."

#: library/typing.rst:732
#, fuzzy
msgid ""
"This behavior allows :data:`Any` to be used as an *escape hatch* when you "
"need to mix dynamically and statically typed code."
msgstr ""
"Bu davranış, dinamik ve statik olarak yazılan kodu karıştırmanız "
"gerektiğinde :data:`Any`'nin *escape hatch* olarak kullanılmasına olanak "
"tanır."

#: library/typing.rst:735
#, fuzzy
msgid ""
"Contrast the behavior of :data:`Any` with the behavior of :class:`object`. "
"Similar to :data:`Any`, every type is a subtype of :class:`object`. However,"
" unlike :data:`Any`, the reverse is not true: :class:`object` is *not* a "
"subtype of every other type."
msgstr ""
":data:`Any`'nin davranışını :class:`object`'un davranışıyla karşılaştırın. "
":data:`Any`'ye benzer şekilde her tür, :class:`object`'un bir alt türüdür. "
"Bununla birlikte, :data:`Any`'den farklı olarak bunun tersi doğru değildir: "
":class:`object`, *not*'in diğer tüm türlerin bir alt türüdür."

#: library/typing.rst:740
#, fuzzy
msgid ""
"That means when the type of a value is :class:`object`, a type checker will "
"reject almost all operations on it, and assigning it to a variable (or using"
" it as a return value) of a more specialized type is a type error. For "
"example::"
msgstr ""
"Bu, bir değerin türü :class:`object` olduğunda, bir tür denetleyicinin bu "
"değer üzerindeki hemen hemen tüm işlemleri reddedeceği ve bunu daha özel bir"
" türdeki bir değişkene atamanın (veya onu dönüş değeri olarak kullanmanın) "
"bir tür hatası olacağı anlamına gelir. Örneğin::"

#: library/typing.rst:762
#, fuzzy
msgid ""
"Use :class:`object` to indicate that a value could be any type in a typesafe"
" manner. Use :data:`Any` to indicate that a value is dynamically typed."
msgstr ""
"Bir değerin yazım açısından güvenli bir şekilde herhangi bir tür "
"olabileceğini belirtmek için :class:`object`'u kullanın. Bir değerin dinamik"
" olarak yazıldığını belirtmek için :data:`Any`'yi kullanın."

#: library/typing.rst:767
#, fuzzy
msgid "Nominal vs structural subtyping"
msgstr "Nominal ve yapısal alt tiplendirme"

#: library/typing.rst:769
#, fuzzy
msgid ""
"Initially :pep:`484` defined the Python static type system as using *nominal"
" subtyping*. This means that a class ``A`` is allowed where a class ``B`` is"
" expected if and only if ``A`` is a subclass of ``B``."
msgstr ""
"Başlangıçta :pep:`484`, Python statik tür sistemini *nominal subtyping* "
"kullanacak şekilde tanımladı. Bu, ``B`` sınıfının beklendiği yerde ``B`` "
"sınıfına ancak ve ancak ``B``'ün ``B``'ün bir alt sınıfı olması durumunda "
"izin verildiği anlamına gelir."

#: library/typing.rst:773
#, fuzzy
msgid ""
"This requirement previously also applied to abstract base classes, such as "
":class:`~collections.abc.Iterable`. The problem with this approach is that a"
" class had to be explicitly marked to support them, which is unpythonic and "
"unlike what one would normally do in idiomatic dynamically typed Python "
"code. For example, this conforms to :pep:`484`::"
msgstr ""
"Bu gereksinim daha önce :class:`~collections.abc.Iterable` gibi soyut temel "
"sınıflara da uygulanıyordu. Bu yaklaşımın sorunu, bir sınıfın onları "
"desteklemek için açıkça işaretlenmesinin gerekmesidir; bu, tipik değildir ve"
" normalde deyimsel, dinamik olarak yazılan Python kodunda yapılandan "
"farklıdır. Örneğin, bu :pep:`484`:: ile uyumludur:"

#: library/typing.rst:786
#, fuzzy
msgid ""
":pep:`544` allows to solve this problem by allowing users to write the above"
" code without explicit base classes in the class definition, allowing "
"``Bucket`` to be implicitly considered a subtype of both ``Sized`` and "
"``Iterable[int]`` by static type checkers. This is known as *structural "
"subtyping* (or static duck-typing)::"
msgstr ""
":pep:`544`, kullanıcıların yukarıdaki kodu sınıf tanımında açık temel "
"sınıflar olmadan yazmasına izin vererek bu sorunun çözülmesine olanak tanır "
"ve ``Iterable[int]``'ün statik tür denetleyiciler tarafından dolaylı olarak "
"hem ``Iterable[int]`` hem de ``Iterable[int]``'ün bir alt türü olarak "
"değerlendirilmesine olanak tanır. Bu, *structural subtyping* (veya statik "
"ördek yazma) olarak bilinir::"

#: library/typing.rst:802
#, fuzzy
msgid ""
"Moreover, by subclassing a special class :class:`Protocol`, a user can "
"define new custom protocols to fully enjoy structural subtyping (see "
"examples below)."
msgstr ""
"Ayrıca, özel bir :class:`Protocol` sınıfını alt sınıflandırarak kullanıcı, "
"yapısal alt tiplemenin tam anlamıyla keyfini çıkarmak için yeni özel "
"protokoller tanımlayabilir (aşağıdaki örneklere bakın)."

#: library/typing.rst:807
#, fuzzy
msgid "Module contents"
msgstr "Modül içeriği"

#: library/typing.rst:809
#, fuzzy
msgid ""
"The ``typing`` module defines the following classes, functions and "
"decorators."
msgstr ""
"``typing`` modülü aşağıdaki sınıfları, işlevleri ve dekoratörleri tanımlar."

#: library/typing.rst:812
#, fuzzy
msgid "Special typing primitives"
msgstr "Özel yazma ilkelleri"

#: library/typing.rst:815
#, fuzzy
msgid "Special types"
msgstr "Özel tipler"

#: library/typing.rst:817
#, fuzzy
msgid ""
"These can be used as types in annotations. They do not support subscription "
"using ``[]``."
msgstr ""
"Bunlar ek açıklamalarda tür olarak kullanılabilir. ``[]`` kullanarak "
"aboneliği desteklemezler."

#: library/typing.rst:822
#, fuzzy
msgid "Special type indicating an unconstrained type."
msgstr "Kısıtlanmamış bir türü belirten özel tür."

#: library/typing.rst:824
#, fuzzy
msgid "Every type is compatible with :data:`Any`."
msgstr "Her tür :data:`Any` ile uyumludur."

#: library/typing.rst:825
#, fuzzy
msgid ":data:`Any` is compatible with every type."
msgstr ":data:`Any` her türle uyumludur."

#: library/typing.rst:827
#, fuzzy
msgid ""
":data:`Any` can now be used as a base class. This can be useful for avoiding"
" type checker errors with classes that can duck type anywhere or are highly "
"dynamic."
msgstr ""
":data:`Any` artık temel sınıf olarak kullanılabilir. Bu, herhangi bir yere "
"yazı yazabilen veya son derece dinamik olan sınıflarda tür denetleyici "
"hatalarından kaçınmak için yararlı olabilir."

#: library/typing.rst:834
#, fuzzy
msgid "A :ref:`constrained type variable <typing-constrained-typevar>`."
msgstr "Bir :ref:`constrained type variable <typing-constrained-typevar>`."

#: library/typing.rst:836
#, fuzzy
msgid "Definition::"
msgstr "Tanım::"

#: library/typing.rst:840
#, fuzzy
msgid ""
"``AnyStr`` is meant to be used for functions that may accept :class:`str` or"
" :class:`bytes` arguments but cannot allow the two to mix."
msgstr ""
"``AnyStr``, :class:`bytes` veya :class:`bytes` bağımsız değişkenlerini kabul"
" edebilen ancak ikisinin karışmasına izin veremeyen işlevler için "
"kullanılmak üzere tasarlanmıştır."

#: library/typing.rst:934 library/typing.rst:1011 library/typing.rst:1237
#: library/typing.rst:2813
#, fuzzy
msgid "For example::"
msgstr "Örneğin::"

#: library/typing.rst:852
#, fuzzy
msgid ""
"Note that, despite its name, ``AnyStr`` has nothing to do with the "
":class:`Any` type, nor does it mean \"any string\". In particular, "
"``AnyStr`` and ``str | bytes`` are different from each other and have "
"different use cases::"
msgstr ""
"Adına rağmen ``str | bytes``'ün :class:`Any` türüyle hiçbir ilgisi "
"olmadığını veya \"herhangi bir dize\" anlamına gelmediğini unutmayın. "
"Özellikle ``str | bytes`` ve ``str | bytes`` birbirinden farklıdır ve farklı"
" kullanım örneklerine sahiptir::"

#: library/typing.rst:869
#, fuzzy
msgid "Special type that includes only literal strings."
msgstr "Yalnızca değişmez dizeleri içeren özel tür."

#: library/typing.rst:871
#, fuzzy
msgid ""
"Any string literal is compatible with ``LiteralString``, as is another "
"``LiteralString``. However, an object typed as just ``str`` is not. A string"
" created by composing ``LiteralString``-typed objects is also acceptable as "
"a ``LiteralString``."
msgstr ""
"Herhangi bir dize değişmezi, başka bir ``LiteralString`` gibi "
"``LiteralString`` ile uyumludur. Ancak yalnızca ``LiteralString`` olarak "
"yazılan bir nesne böyle değildir. ``LiteralString`` tipi nesnelerin "
"oluşturulmasıyla oluşturulan bir dize, ``LiteralString`` olarak da kabul "
"edilebilir."

#: library/typing.rst:1957
#, fuzzy
msgid "Example:"
msgstr "Örnek:"

#: library/typing.rst:893
#, fuzzy
msgid ""
"``LiteralString`` is useful for sensitive APIs where arbitrary user-"
"generated strings could generate problems. For example, the two cases above "
"that generate type checker errors could be vulnerable to an SQL injection "
"attack."
msgstr ""
"``LiteralString``, kullanıcı tarafından oluşturulan dizelerin sorun "
"yaratabileceği hassas API'ler için kullanışlıdır. Örneğin, tür denetleyici "
"hataları üreten yukarıdaki iki durum, SQL enjeksiyon saldırısına karşı "
"savunmasız olabilir."

#: library/typing.rst:898
#, fuzzy
msgid "See :pep:`675` for more details."
msgstr "Daha fazla ayrıntı için :pep:`675`'e bakın."

#: library/typing.rst:904
#, fuzzy
msgid ""
"The `bottom type <https://en.wikipedia.org/wiki/Bottom_type>`_, a type that "
"has no members."
msgstr ""
"`bottom type <https://en.wikipedia.org/wiki/Bottom_type>`_, üyesi olmayan "
"bir tür."

#: library/typing.rst:907
#, fuzzy
msgid ""
"This can be used to define a function that should never be called, or a "
"function that never returns::"
msgstr ""
"Bu, asla çağrılmaması gereken bir işlevi veya asla geri dönmeyen bir işlevi "
"tanımlamak için kullanılabilir::"

#: library/typing.rst:927
#, fuzzy
msgid ""
"On older Python versions, :data:`NoReturn` may be used to express the same "
"concept. ``Never`` was added to make the intended meaning more explicit."
msgstr ""
"Eski Python sürümlerinde aynı kavramı ifade etmek için :data:`NoReturn` "
"kullanılabilir. Amaçlanan anlamı daha açık hale getirmek için ``Never`` "
"eklendi."

#: library/typing.rst:932
#, fuzzy
msgid "Special type indicating that a function never returns."
msgstr "Bir fonksiyonun asla geri dönmediğini belirten özel tür."

#: library/typing.rst:941
#, fuzzy
msgid ""
"``NoReturn`` can also be used as a `bottom type "
"<https://en.wikipedia.org/wiki/Bottom_type>`_, a type that has no values. "
"Starting in Python 3.11, the :data:`Never` type should be used for this "
"concept instead. Type checkers should treat the two equivalently."
msgstr ""
"``NoReturn``, değeri olmayan bir tür olan `bottom type "
"<https://en.wikipedia.org/wiki/Bottom_type>`_ olarak da kullanılabilir. "
"Python 3.11'den itibaren bu konsept için :data:`Never` tipi kullanılmalıdır."
" Tip denetleyicileri ikisine eşit şekilde davranmalıdır."

#: library/typing.rst:952
#, fuzzy
msgid "Special type to represent the current enclosed class."
msgstr "Geçerli kapalı sınıfı temsil eden özel tür."

#: library/typing.rst:968
#, fuzzy
msgid ""
"This annotation is semantically equivalent to the following, albeit in a "
"more succinct fashion::"
msgstr ""
"Bu açıklama, daha kısa ve öz bir şekilde de olsa anlamsal olarak aşağıdakine"
" eşdeğerdir::"

#: library/typing.rst:980
#, fuzzy
msgid ""
"In general, if something returns ``self``, as in the above examples, you "
"should use ``Self`` as the return annotation. If ``Foo.return_self`` was "
"annotated as returning ``\"Foo\"``, then the type checker would infer the "
"object returned from ``SubclassOfFoo.return_self`` as being of type ``Foo`` "
"rather than ``SubclassOfFoo``."
msgstr ""
"Genel olarak, yukarıdaki örneklerde olduğu gibi bir şey ``SubclassOfFoo`` "
"döndürürse, dönüş açıklaması olarak ``SubclassOfFoo``'ü kullanmalısınız. "
"``SubclassOfFoo``'e, ``SubclassOfFoo``'ü döndürecek şekilde açıklama "
"eklenmişse tür denetleyici, ``SubclassOfFoo``'ten döndürülen nesnenin "
"``SubclassOfFoo`` yerine ``SubclassOfFoo`` türünde olduğu sonucunu çıkarır."

#: library/typing.rst:986
#, fuzzy
msgid "Other common use cases include:"
msgstr "Diğer yaygın kullanım durumları şunları içerir:"

#: library/typing.rst:988
#, fuzzy
msgid ""
":class:`classmethod`\\s that are used as alternative constructors and return"
" instances of the ``cls`` parameter."
msgstr ""
"Alternatif oluşturucular olarak kullanılan :class:`classmethod`\\'lar ve "
"``cls`` parametresinin örneklerini döndürür."

#: library/typing.rst:990
#, fuzzy
msgid "Annotating an :meth:`~object.__enter__` method which returns self."
msgstr ""
"Kendini döndüren bir :meth:`~object.__enter__` yöntemine açıklama ekleme."

#: library/typing.rst:992
#, fuzzy
msgid ""
"You should not use ``Self`` as the return annotation if the method is not "
"guaranteed to return an instance of a subclass when the class is "
"subclassed::"
msgstr ""
"Yöntemin, sınıf alt sınıflara ayrıldığında bir alt sınıfın örneğini "
"döndürmesi garanti edilmiyorsa, dönüş açıklaması olarak ``Self``'ü "
"kullanmamalısınız::"

#: library/typing.rst:1003
#, fuzzy
msgid "See :pep:`673` for more details."
msgstr "Daha fazla ayrıntı için :pep:`673`'e bakın."

#: library/typing.rst:1009
#, fuzzy
msgid ""
"Special annotation for explicitly declaring a :ref:`type alias <type-"
"aliases>`."
msgstr ""
"Bir :ref:`type alias <type-aliases>`'u açıkça bildirmek için özel açıklama."

#: library/typing.rst:1017
#, fuzzy
msgid ""
"``TypeAlias`` is particularly useful on older Python versions for annotating"
" aliases that make use of forward references, as it can be hard for type "
"checkers to distinguish these from normal variable assignments:"
msgstr ""
"``TypeAlias``, tür denetleyicilerinin bunları normal değişken atamalarından "
"ayırt etmesi zor olabileceğinden, ileri referanslardan yararlanan takma "
"adlara açıklama eklemek için eski Python sürümlerinde özellikle "
"kullanışlıdır:"

#: library/typing.rst:1037
#, fuzzy
msgid "See :pep:`613` for more details."
msgstr "Daha fazla ayrıntı için :pep:`613`'e bakın."

#: library/typing.rst:1041
#, fuzzy
msgid ""
":data:`TypeAlias` is deprecated in favor of the :keyword:`type` statement, "
"which creates instances of :class:`TypeAliasType` and which natively "
"supports forward references. Note that while :data:`TypeAlias` and "
":class:`TypeAliasType` serve similar purposes and have similar names, they "
"are distinct and the latter is not the type of the former. Removal of "
":data:`TypeAlias` is not currently planned, but users are encouraged to "
"migrate to :keyword:`type` statements."
msgstr ""
":data:`TypeAlias`, :class:`TypeAliasType` örneklerini oluşturan ve ileri "
"referansları yerel olarak destekleyen :keyword:`type` deyimi lehine "
"kullanımdan kaldırıldı. :data:`TypeAlias` ve :class:`TypeAliasType`'un "
"benzer amaçlara hizmet etmesine ve benzer adlara sahip olmasına rağmen, "
"bunların farklı olduğunu ve ikincisinin birincinin türü olmadığını "
"unutmayın. :data:`TypeAlias`'nin kaldırılması şu anda planlanmamıştır ancak "
"kullanıcıların :keyword:`type` bildirimlerine geçmeleri teşvik edilmektedir."

#: library/typing.rst:1052
#, fuzzy
msgid "Special forms"
msgstr "Özel formlar"

#: library/typing.rst:1054
#, fuzzy
msgid ""
"These can be used as types in annotations. They all support subscription "
"using ``[]``, but each has a unique syntax."
msgstr ""
"Bunlar ek açıklamalarda tür olarak kullanılabilir. Hepsi ``[]`` kullanan "
"aboneliği destekler, ancak her birinin benzersiz bir sözdizimi vardır."

#: library/typing.rst:1059
#, fuzzy
msgid ""
"Union type; ``Union[X, Y]`` is equivalent to ``X | Y`` and means either X or"
" Y."
msgstr ""
"Birlik türü; ``X | Y``, ``X | Y``'e eşdeğerdir ve X veya Y anlamına gelir."

#: library/typing.rst:1061
#, fuzzy
msgid ""
"To define a union, use e.g. ``Union[int, str]`` or the shorthand ``int | "
"str``. Using that shorthand is recommended. Details:"
msgstr ""
"Bir birleşim tanımlamak için ör. ``int | str`` veya kısaca ``int | str``. Bu"
" kısaltmanın kullanılması tavsiye edilir. Detaylar:"

#: library/typing.rst:1063
#, fuzzy
msgid "The arguments must be types and there must be at least one."
msgstr "Bağımsız değişkenler türde olmalı ve en az bir tane olmalıdır."

#: library/typing.rst:1065
#, fuzzy
msgid "Unions of unions are flattened, e.g.::"
msgstr "Sendika birlikleri düzleştirildi, örneğin::"

#: library/typing.rst:1069
#, fuzzy
msgid "Unions of a single argument vanish, e.g.::"
msgstr "Tek bir argümanın birleşimleri ortadan kalkar, örneğin::"

#: library/typing.rst:1073
#, fuzzy
msgid "Redundant arguments are skipped, e.g.::"
msgstr "Gereksiz argümanlar atlanır, örneğin:::"

#: library/typing.rst:1077
#, fuzzy
msgid "When comparing unions, the argument order is ignored, e.g.::"
msgstr ""
"Birleşimleri karşılaştırırken argüman sırası göz ardı edilir, örneğin::"

#: library/typing.rst:1081
#, fuzzy
msgid "You cannot subclass or instantiate a ``Union``."
msgstr "Bir ``Union``'ü alt sınıflandıramaz veya örnekleyemezsiniz."

#: library/typing.rst:1083
#, fuzzy
msgid "You cannot write ``Union[X][Y]``."
msgstr "``Union[X][Y]``'ü yazamazsınız."

#: library/typing.rst:1085
#, fuzzy
msgid "Don't remove explicit subclasses from unions at runtime."
msgstr "Açık alt sınıfları çalışma zamanında birliklerden kaldırmayın."

#: library/typing.rst:1088
#, fuzzy
msgid ""
"Unions can now be written as ``X | Y``. See :ref:`union type "
"expressions<types-union>`."
msgstr ""
"Birleşimler artık ``X | Y`` olarak yazılabilir. Bkz. :ref:`union type "
"expressions<types-union>`."

#: library/typing.rst:1094
#, fuzzy
msgid "``Optional[X]`` is equivalent to ``X | None`` (or ``Union[X, None]``)."
msgstr ""
"``Union[X, None]``, ``Union[X, None]``'e (veya ``Union[X, None]``) "
"eşdeğerdir."

#: library/typing.rst:1096
#, fuzzy
msgid ""
"Note that this is not the same concept as an optional argument, which is one"
" that has a default.  An optional argument with a default does not require "
"the ``Optional`` qualifier on its type annotation just because it is "
"optional. For example::"
msgstr ""
"Bunun, varsayılan değeri olan isteğe bağlı bir bağımsız değişkenle aynı "
"kavram olmadığını unutmayın. Varsayılana sahip isteğe bağlı bir bağımsız "
"değişken, isteğe bağlı olduğu için tür açıklamasında ``Optional`` "
"niteleyicisini gerektirmez. Örneğin::"

#: library/typing.rst:1104
#, fuzzy
msgid ""
"On the other hand, if an explicit value of ``None`` is allowed, the use of "
"``Optional`` is appropriate, whether the argument is optional or not. For "
"example::"
msgstr ""
"Öte yandan, ``Optional``'ün açık bir değerine izin veriliyorsa, bağımsız "
"değişkenin isteğe bağlı olup olmadığına bakılmaksızın ``Optional``'ün "
"kullanımı uygundur. Örneğin::"

#: library/typing.rst:1111
#, fuzzy
msgid ""
"Optional can now be written as ``X | None``. See :ref:`union type "
"expressions<types-union>`."
msgstr ""
"İsteğe bağlı olarak artık ``X | None`` olarak yazılabilir. Bkz. :ref:`union "
"type expressions<types-union>`."

#: library/typing.rst:1117
#, fuzzy
msgid "Special form for annotating higher-order functions."
msgstr "Üst düzey fonksiyonlara açıklama eklemek için özel form."

#: library/typing.rst:1119
#, fuzzy
msgid ""
"``Concatenate`` can be used in conjunction with :ref:`Callable <annotating-"
"callables>` and :class:`ParamSpec` to annotate a higher-order callable which"
" adds, removes, or transforms parameters of another callable.  Usage is in "
"the form ``Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable]``. "
"``Concatenate`` is currently only valid when used as the first argument to a"
" :ref:`Callable <annotating-callables>`. The last parameter to "
"``Concatenate`` must be a :class:`ParamSpec` or ellipsis (``...``)."
msgstr ""
"``...``, başka bir çağrılabilirin parametrelerini ekleyen, kaldıran veya "
"dönüştüren daha yüksek dereceli bir çağrılabilire açıklama eklemek için "
":ref:`Callable <annotating-callables>` ve :class:`ParamSpec` ile birlikte "
"kullanılabilir. Kullanımı ``...`` şeklindedir. ``...`` şu anda yalnızca "
":ref:`Callable <annotating-callables>`'un ilk argümanı olarak "
"kullanıldığında geçerlidir. ``...``'ün son parametresi bir "
":class:`ParamSpec` veya üç nokta (``...``) olmalıdır."

#: library/typing.rst:1128
#, fuzzy
msgid ""
"For example, to annotate a decorator ``with_lock`` which provides a "
":class:`threading.Lock` to the decorated function,  ``Concatenate`` can be "
"used to indicate that ``with_lock`` expects a callable which takes in a "
"``Lock`` as the first argument, and returns a callable with a different type"
" signature.  In this case, the :class:`ParamSpec` indicates that the "
"returned callable's parameter types are dependent on the parameter types of "
"the callable being passed in::"
msgstr ""
"Örneğin, dekore edilmiş işleve bir :class:`ParamSpec` sağlayan bir dekoratör"
" ``Lock``'e açıklama eklemek için ``Lock``, ``Lock``'ün ilk argüman olarak "
"bir ``Lock``'ü alan ve farklı türde bir imzaya sahip bir çağrılabilir "
"döndüren bir çağrılabilir beklediğini belirtmek için kullanılabilir. Bu "
"durumda :class:`ParamSpec`, döndürülen çağrılabilir öğenin parametre "
"türlerinin, iletilen çağrılabilir öğenin parametre türlerine bağlı olduğunu "
"belirtir::"

#: library/typing.rst:1925
#, fuzzy
msgid ""
":pep:`612` -- Parameter Specification Variables (the PEP which introduced "
"``ParamSpec`` and ``Concatenate``)"
msgstr ""
":pep:`612` - Parametre Belirtim Değişkenleri (``Concatenate`` ve "
"``Concatenate``'ü tanıtan PEP)"

#: library/typing.rst:1169
#, fuzzy
msgid ":class:`ParamSpec`"
msgstr ":class:`ParamSpec`"

#: library/typing.rst:1928
#, fuzzy
msgid ":ref:`annotating-callables`"
msgstr ":ref:`annotating-callables`"

#: library/typing.rst:1174
#, fuzzy
msgid "Special typing form to define \"literal types\"."
msgstr "\"Gerçek türleri\" tanımlamak için özel yazma formu."

#: library/typing.rst:1176
#, fuzzy
msgid ""
"``Literal`` can be used to indicate to type checkers that the annotated "
"object has a value equivalent to one of the provided literals."
msgstr ""
"``Literal``, tip denetleyicilerine açıklamalı nesnenin sağlanan değişmez "
"değerlerden birine eşdeğer bir değere sahip olduğunu belirtmek için "
"kullanılabilir."

#: library/typing.rst:1192
#, fuzzy
msgid ""
"``Literal[...]`` cannot be subclassed. At runtime, an arbitrary value is "
"allowed as type argument to ``Literal[...]``, but type checkers may impose "
"restrictions. See :pep:`586` for more details about literal types."
msgstr ""
"``Literal[...]`` alt sınıflara ayrılamaz. Çalışma zamanında, "
"``Literal[...]``'e tür bağımsız değişkeni olarak rastgele bir değere izin "
"verilir, ancak tür denetleyicileri kısıtlamalar getirebilir. Değişmez türler"
" hakkında daha fazla ayrıntı için :pep:`586`'e bakın."

#: library/typing.rst:1198
#, fuzzy
msgid ""
"``Literal`` now de-duplicates parameters.  Equality comparisons of "
"``Literal`` objects are no longer order dependent. ``Literal`` objects will "
"now raise a :exc:`TypeError` exception during equality comparisons if one of"
" their parameters are not :term:`hashable`."
msgstr ""
"``Literal`` artık parametrelerin kopyalarını kaldırıyor. ``Literal`` "
"nesnelerinin eşitlik karşılaştırmaları artık sıraya bağlı değildir. "
"``Literal`` nesneleri, parametrelerinden biri :term:`hashable` değilse artık"
" eşitlik karşılaştırmaları sırasında bir :exc:`TypeError` istisnası "
"oluşturacaktır."

#: library/typing.rst:1206
#, fuzzy
msgid "Special type construct to mark class variables."
msgstr "Sınıf değişkenlerini işaretlemek için özel tip yapısı."

#: library/typing.rst:1208
#, fuzzy
msgid ""
"As introduced in :pep:`526`, a variable annotation wrapped in ClassVar "
"indicates that a given attribute is intended to be used as a class variable "
"and should not be set on instances of that class. Usage::"
msgstr ""
":pep:`526`'de tanıtıldığı gibi, ClassVar'a sarılmış bir değişken açıklaması,"
" belirli bir özelliğin bir sınıf değişkeni olarak kullanılmasının "
"amaçlandığını ve o sınıfın örnekleri üzerinde ayarlanmaması gerektiğini "
"belirtir. Kullanımı::"

#: library/typing.rst:1216
#, fuzzy
msgid ":data:`ClassVar` accepts only types and cannot be further subscribed."
msgstr ""
":data:`ClassVar` yalnızca türleri kabul eder ve daha fazla abone olunamaz."

#: library/typing.rst:1218
#, fuzzy
msgid ""
":data:`ClassVar` is not a class itself, and should not be used with "
":func:`isinstance` or :func:`issubclass`. :data:`ClassVar` does not change "
"Python runtime behavior, but it can be used by third-party type checkers. "
"For example, a type checker might flag the following code as an error::"
msgstr ""
":data:`ClassVar` başlı başına bir sınıf değildir ve :func:`issubclass` veya "
":func:`issubclass` ile kullanılmamalıdır. :data:`ClassVar`, Python çalışma "
"zamanı davranışını değiştirmez ancak üçüncü taraf tür denetleyicileri "
"tarafından kullanılabilir. Örneğin, bir tür denetleyicisi aşağıdaki kodu "
"hata olarak işaretleyebilir::"

#: library/typing.rst:1232
#, fuzzy
msgid "Special typing construct to indicate final names to type checkers."
msgstr "Dama yazmak için son adları belirtmek için özel yazma yapısı."

#: library/typing.rst:1234
#, fuzzy
msgid ""
"Final names cannot be reassigned in any scope. Final names declared in class"
" scopes cannot be overridden in subclasses."
msgstr ""
"Son adlar hiçbir kapsamda yeniden atanamaz. Sınıf kapsamlarında bildirilen "
"son adlar alt sınıflarda geçersiz kılınamaz."

#: library/typing.rst:2829
#, fuzzy
msgid ""
"There is no runtime checking of these properties. See :pep:`591` for more "
"details."
msgstr ""
"Bu özelliklerin çalışma zamanı denetimi yoktur. Daha fazla ayrıntı için "
":pep:`591`'e bakın."

#: library/typing.rst:1255
#, fuzzy
msgid "Special typing construct to mark a :class:`TypedDict` key as required."
msgstr ""
":class:`TypedDict` anahtarını gerektiği gibi işaretlemek için özel yazma "
"yapısı."

#: library/typing.rst:1257
#, fuzzy
msgid ""
"This is mainly useful for ``total=False`` TypedDicts. See :class:`TypedDict`"
" and :pep:`655` for more details."
msgstr ""
"Bu esas olarak ``total=False`` TypedDicts için kullanışlıdır. Daha fazla "
"ayrıntı için :class:`TypedDict` ve :pep:`655`'e bakın."

#: library/typing.rst:1264
#, fuzzy
msgid ""
"Special typing construct to mark a :class:`TypedDict` key as potentially "
"missing."
msgstr ""
"Bir :class:`TypedDict` anahtarını potansiyel olarak eksik olarak işaretlemek"
" için özel yazma yapısı."

#: library/typing.rst:1267
#, fuzzy
msgid "See :class:`TypedDict` and :pep:`655` for more details."
msgstr "Daha fazla ayrıntı için :class:`TypedDict` ve :pep:`655`'e bakın."

#: library/typing.rst:1273
#, fuzzy
msgid "Special typing form to add context-specific metadata to an annotation."
msgstr ""
"Bir ek açıklamaya bağlama özgü meta veriler eklemek için özel yazma formu."

#: library/typing.rst:1275
#, fuzzy
msgid ""
"Add metadata ``x`` to a given type ``T`` by using the annotation "
"``Annotated[T, x]``. Metadata added using ``Annotated`` can be used by "
"static analysis tools or at runtime. At runtime, the metadata is stored in a"
" :attr:`!__metadata__` attribute."
msgstr ""
"``Annotated`` ek açıklamasını kullanarak belirli bir ``Annotated`` türüne "
"``Annotated`` meta verileri ekleyin. ``Annotated`` kullanılarak eklenen meta"
" veriler, statik analiz araçları tarafından veya çalışma zamanında "
"kullanılabilir. Çalışma zamanında meta veriler bir :attr:`!__metadata__` "
"özelliğinde depolanır."

#: library/typing.rst:1280
#, fuzzy
msgid ""
"If a library or tool encounters an annotation ``Annotated[T, x]`` and has no"
" special logic for the metadata, it should ignore the metadata and simply "
"treat the annotation as ``T``. As such, ``Annotated`` can be useful for code"
" that wants to use annotations for purposes outside Python's static typing "
"system."
msgstr ""
"Bir kitaplık veya araç bir ``Annotated`` ek açıklamasıyla karşılaşırsa ve "
"meta veriler için özel bir mantığı yoksa, meta verileri göz ardı etmeli ve "
"ek açıklamayı yalnızca ``Annotated`` olarak ele almalıdır. Bu nedenle, "
"``Annotated``, ek açıklamaları Python'un statik yazma sisteminin dışındaki "
"amaçlarla kullanmak isteyen kod için yararlı olabilir."

#: library/typing.rst:1286
#, fuzzy
msgid ""
"Using ``Annotated[T, x]`` as an annotation still allows for static "
"typechecking of ``T``, as type checkers will simply ignore the metadata "
"``x``. In this way, ``Annotated`` differs from the :func:`@no_type_check "
"<no_type_check>` decorator, which can also be used for adding annotations "
"outside the scope of the typing system, but completely disables typechecking"
" for a function or class."
msgstr ""
"``Annotated``'ü bir açıklama olarak kullanmak, ``Annotated``'ün statik tip "
"kontrolüne hala izin verir, çünkü tip denetleyicileri ``Annotated`` meta "
"verilerini göz ardı eder. Bu şekilde ``Annotated``, yazma sisteminin kapsamı"
" dışında ek açıklamalar eklemek için de kullanılabilen ancak bir işlev veya "
"sınıf için yazım denetimini tamamen devre dışı bırakan :func:`@no_type_check"
" <no_type_check>` dekoratöründen farklıdır."

#: library/typing.rst:1293
#, fuzzy
msgid ""
"The responsibility of how to interpret the metadata lies with the the tool "
"or library encountering an ``Annotated`` annotation. A tool or library "
"encountering an ``Annotated`` type can scan through the metadata elements to"
" determine if they are of interest (e.g., using :func:`isinstance`)."
msgstr ""
"Meta verilerin nasıl yorumlanacağının sorumluluğu, bir ``Annotated`` ek "
"açıklamasıyla karşılaşan araç veya kitaplığa aittir. ``Annotated`` türüyle "
"karşılaşan bir araç veya kitaplık, ilgi çekici olup olmadıklarını belirlemek"
" için meta veri öğelerini tarayabilir (örneğin, :func:`isinstance`'yi "
"kullanarak)."

#: library/typing.rst:1301
#, fuzzy
msgid ""
"Here is an example of how you might use ``Annotated`` to add metadata to "
"type annotations if you were doing range analysis:"
msgstr ""
"Aralık analizi yapıyorsanız, tür ek açıklamalarına meta veriler eklemek için"
" ``Annotated``'ü nasıl kullanabileceğinize dair bir örneği burada "
"bulabilirsiniz:"

#: library/typing.rst:1314
#, fuzzy
msgid "Details of the syntax:"
msgstr "Sözdiziminin ayrıntıları:"

#: library/typing.rst:1316
#, fuzzy
msgid "The first argument to ``Annotated`` must be a valid type"
msgstr ""
"``Annotated``'e ilişkin ilk bağımsız değişken geçerli bir tür olmalıdır"

#: library/typing.rst:1318
#, fuzzy
msgid ""
"Multiple metadata elements can be supplied (``Annotated`` supports variadic "
"arguments)::"
msgstr ""
"Birden fazla meta veri öğesi sağlanabilir (``Annotated`` değişken "
"argümanları destekler)::"

#: library/typing.rst:1327
#, fuzzy
msgid ""
"It is up to the tool consuming the annotations to decide whether the client "
"is allowed to add multiple metadata elements to one annotation and how to "
"merge those annotations."
msgstr ""
"İstemcinin bir ek açıklamaya birden fazla meta veri öğesi eklemesine izin "
"verilip verilmeyeceğine ve bu ek açıklamaların nasıl birleştirileceğine "
"karar vermek, ek açıklamaları tüketen araca bağlıdır."

#: library/typing.rst:1331
#, fuzzy
msgid ""
"``Annotated`` must be subscripted with at least two arguments ( "
"``Annotated[int]`` is not valid)"
msgstr ""
"``Annotated[int]``'e en az iki bağımsız değişken eklenmelidir "
"(``Annotated[int]`` geçerli değil)"

#: library/typing.rst:1334
#, fuzzy
msgid ""
"The order of the metadata elements is preserved and matters for equality "
"checks::"
msgstr ""
"Meta veri öğelerinin sırası korunur ve eşitlik kontrolleri için önemlidir::"

#: library/typing.rst:1341
#, fuzzy
msgid ""
"Nested ``Annotated`` types are flattened. The order of the metadata elements"
" starts with the innermost annotation::"
msgstr ""
"İç içe geçmiş ``Annotated`` türleri düzleştirilmiştir. Meta veri öğelerinin "
"sırası en içteki açıklamayla başlar::"

#: library/typing.rst:1348
#, fuzzy
msgid "Duplicated metadata elements are not removed::"
msgstr "Yinelenen meta veri öğeleri kaldırılmaz::"

#: library/typing.rst:1354
#, fuzzy
msgid "``Annotated`` can be used with nested and generic aliases:"
msgstr "``Annotated``, iç içe geçmiş ve genel takma adlarla kullanılabilir:"

#: library/typing.rst:1368
#, fuzzy
msgid "``Annotated`` cannot be used with an unpacked :class:`TypeVarTuple`::"
msgstr ""
"``Annotated``, paketi açılmış bir :class:`TypeVarTuple` ile kullanılamaz::"

#: library/typing.rst:1372
#, fuzzy
msgid "This would be equivalent to::"
msgstr "Bu şuna eşdeğer olacaktır::"

#: library/typing.rst:1376
#, fuzzy
msgid ""
"where ``T1``, ``T2``, etc. are :class:`TypeVars <TypeVar>`. This would be "
"invalid: only one type should be passed to Annotated."
msgstr ""
"burada ``T2``, ``T2``, vb. :class:`TypeVars <TypeVar>`'dur. Bu geçersiz "
"olacaktır: Annotated'a yalnızca bir tür aktarılmalıdır."

#: library/typing.rst:1379
#, fuzzy
msgid ""
"By default, :func:`get_type_hints` strips the metadata from annotations. "
"Pass ``include_extras=True`` to have the metadata preserved:"
msgstr ""
"Varsayılan olarak :func:`get_type_hints`, meta verileri ek açıklamalardan "
"çıkarır. Meta verilerin korunmasını sağlamak için ``include_extras=True``'ü "
"iletin:"

#: library/typing.rst:1392
#, fuzzy
msgid ""
"At runtime, the metadata associated with an ``Annotated`` type can be "
"retrieved via the :attr:`!__metadata__` attribute:"
msgstr ""
"Çalışma zamanında bir ``Annotated`` türüyle ilişkili meta veriler, "
":attr:`!__metadata__` özelliği aracılığıyla alınabilir:"

#: library/typing.rst:1406
#, fuzzy
msgid ":pep:`593` - Flexible function and variable annotations"
msgstr ":pep:`593` - Esnek işlev ve değişken açıklamalar"

#: library/typing.rst:1407
#, fuzzy
msgid "The PEP introducing ``Annotated`` to the standard library."
msgstr "``Annotated``'ü standart kitaplığa tanıtan PEP."

#: library/typing.rst:1414
#, fuzzy
msgid ""
"Special typing construct for marking user-defined type guard functions."
msgstr ""
"Kullanıcı tanımlı tip koruma fonksiyonlarını işaretlemek için özel yazma "
"yapısı."

#: library/typing.rst:1416
#, fuzzy
msgid ""
"``TypeGuard`` can be used to annotate the return type of a user-defined type"
" guard function.  ``TypeGuard`` only accepts a single type argument. At "
"runtime, functions marked this way should return a boolean."
msgstr ""
"``TypeGuard``, kullanıcı tanımlı bir tür koruma fonksiyonunun dönüş türüne "
"açıklama eklemek için kullanılabilir. ``TypeGuard`` yalnızca tek tür "
"bağımsız değişkeni kabul eder. Çalışma zamanında, bu şekilde işaretlenen "
"işlevler bir boole değeri döndürmelidir."

#: library/typing.rst:1420
#, fuzzy
msgid ""
"``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static"
" type checkers to determine a more precise type of an expression within a "
"program's code flow.  Usually type narrowing is done by analyzing "
"conditional code flow and applying the narrowing to a block of code.  The "
"conditional expression here is sometimes referred to as a \"type guard\"::"
msgstr ""
"``TypeGuard``, bir programın kod akışındaki bir ifadenin daha kesin türünü "
"belirlemek için statik tür denetleyicileri tarafından kullanılan bir teknik "
"olan *type narrowing*'den yararlanmayı amaçlamaktadır. Genellikle tür "
"daraltma, koşullu kod akışını analiz ederek ve daraltmayı bir kod bloğuna "
"uygulayarak yapılır. Buradaki koşullu ifadeye bazen \"tip koruması\" adı "
"verilir::"

#: library/typing.rst:1435
#, fuzzy
msgid ""
"Sometimes it would be convenient to use a user-defined boolean function as a"
" type guard.  Such a function should use ``TypeGuard[...]`` as its return "
"type to alert static type checkers to this intention."
msgstr ""
"Bazen kullanıcı tanımlı bir boole fonksiyonunu tür koruması olarak kullanmak"
" uygun olabilir. Böyle bir işlev, statik tür denetleyicilerini bu amaç "
"konusunda uyarmak için dönüş türü olarak ``TypeGuard[...]``'ü kullanmalıdır."

#: library/typing.rst:1439
#, fuzzy
msgid ""
"Using  ``-> TypeGuard`` tells the static type checker that for a given "
"function:"
msgstr ""
"``-> TypeGuard``'ün kullanılması, statik tür denetleyiciye belirli bir işlev"
" için şunu bildirir:"

#: library/typing.rst:1442
#, fuzzy
msgid "The return value is a boolean."
msgstr "Dönüş değeri bir boole değeridir."

#: library/typing.rst:1443
#, fuzzy
msgid ""
"If the return value is ``True``, the type of its argument is the type inside"
" ``TypeGuard``."
msgstr ""
"Dönüş değeri ``TypeGuard`` ise bağımsız değişkeninin türü ``TypeGuard``'ün "
"içindeki türdür."

#: library/typing.rst:1460
#, fuzzy
msgid ""
"If ``is_str_list`` is a class or instance method, then the type in "
"``TypeGuard`` maps to the type of the second parameter after ``cls`` or "
"``self``."
msgstr ""
"``self`` bir sınıf veya örnek yöntemiyse ``self``'teki tür, ``self`` veya "
"``self``'ten sonraki ikinci parametrenin türüyle eşleşir."

#: library/typing.rst:1464
#, fuzzy
msgid ""
"In short, the form ``def foo(arg: TypeA) -> TypeGuard[TypeB]: ...``, means "
"that if ``foo(arg)`` returns ``True``, then ``arg`` narrows from ``TypeA`` "
"to ``TypeB``."
msgstr ""
"Kısaca ``TypeB`` formu, ``TypeB``'ün ``TypeB``'ü döndürmesi durumunda "
"``TypeB``'ün ``TypeB``'ten ``TypeB``'e daralması anlamına gelir."

#: library/typing.rst:1470
#, fuzzy
msgid ""
"``TypeB`` need not be a narrower form of ``TypeA`` -- it can even be a wider"
" form. The main reason is to allow for things like narrowing "
"``list[object]`` to ``list[str]`` even though the latter is not a subtype of"
" the former, since ``list`` is invariant. The responsibility of writing "
"type-safe type guards is left to the user."
msgstr ""
"``list``'ün, ``list``'ün daha dar bir formu olması gerekmez; hatta daha "
"geniş bir form bile olabilir. Bunun ana nedeni, ``list``'ün değişmez olması "
"nedeniyle ``list``'ün ``list``'ün bir alt türü olmamasına rağmen ``list``'ü "
"``list``'e daraltmak gibi şeylere izin vermektir. Tip-güvenli tip "
"korumaların yazılması sorumluluğu kullanıcıya bırakılmıştır."

#: library/typing.rst:1476
#, fuzzy
msgid ""
"``TypeGuard`` also works with type variables.  See :pep:`647` for more "
"details."
msgstr ""
"``TypeGuard`` ayrıca tür değişkenleriyle de çalışır. Daha fazla ayrıntı için"
" :pep:`647`'e bakın."

#: library/typing.rst:1483
#, fuzzy
msgid ""
"Typing operator to conceptually mark an object as having been unpacked."
msgstr ""
"Bir nesneyi ambalajı açılmış olarak kavramsal olarak işaretlemek için yazma "
"operatörü."

#: library/typing.rst:1485
#, fuzzy
msgid ""
"For example, using the unpack operator ``*`` on a :class:`type variable "
"tuple <TypeVarTuple>` is equivalent to using ``Unpack`` to mark the type "
"variable tuple as having been unpacked::"
msgstr ""
"Örneğin, bir :class:`type variable tuple <TypeVarTuple>`'da ``Unpack`` paket"
" açma operatörünün kullanılması, tuple tür değişkenini paketi açılmış olarak"
" işaretlemek için ``Unpack`` kullanmaya eşdeğerdir::"

#: library/typing.rst:1494
#, fuzzy
msgid ""
"In fact, ``Unpack`` can be used interchangeably with ``*`` in the context of"
" :class:`typing.TypeVarTuple <TypeVarTuple>` and :class:`builtins.tuple "
"<tuple>` types. You might see ``Unpack`` being used explicitly in older "
"versions of Python, where ``*`` couldn't be used in certain places::"
msgstr ""
"Aslında ``*``, :class:`builtins.tuple <tuple>` ve :class:`builtins.tuple "
"<tuple>` türleri bağlamında ``*`` ile birbirinin yerine kullanılabilir. "
"``*``'ün belirli yerlerde kullanılamadığı eski Python sürümlerinde ``*``'ün "
"açıkça kullanıldığını görebilirsiniz::"

#: library/typing.rst:1508
#, fuzzy
msgid ""
"``Unpack`` can also be used along with :class:`typing.TypedDict` for typing "
"``**kwargs`` in a function signature::"
msgstr ""
"``**kwargs``, bir işlev imzasına ``**kwargs`` yazmak için "
":class:`typing.TypedDict` ile birlikte de kullanılabilir::"

#: library/typing.rst:1521
#, fuzzy
msgid ""
"See :pep:`692` for more details on using ``Unpack`` for ``**kwargs`` typing."
msgstr ""
"``**kwargs`` yazmak için ``**kwargs``'ü kullanma hakkında daha fazla ayrıntı"
" için :pep:`692`'e bakın."

#: library/typing.rst:1526
#, fuzzy
msgid "Building generic types and type aliases"
msgstr "Genel türler ve tür takma adları oluşturma"

#: library/typing.rst:1528
#, fuzzy
msgid ""
"The following classes should not be used directly as annotations. Their "
"intended purpose is to be building blocks for creating generic types and "
"type aliases."
msgstr ""
"Aşağıdaki sınıflar doğrudan açıklama olarak kullanılmamalıdır. Amaçlanan "
"amaçları, genel türler ve tür takma adları oluşturmak için yapı taşları "
"olmaktır."

#: library/typing.rst:1532
#, fuzzy
msgid ""
"These objects can be created through special syntax (:ref:`type parameter "
"lists <type-params>` and the :keyword:`type` statement). For compatibility "
"with Python 3.11 and earlier, they can also be created without the dedicated"
" syntax, as documented below."
msgstr ""
"Bu nesneler özel sözdizimi (:ref:`type parameter lists <type-params>` ve "
":keyword:`type` ifadesi) aracılığıyla oluşturulabilir. Python 3.11 ve önceki"
" sürümleriyle uyumluluk sağlamak amacıyla, aşağıda belgelendiği gibi özel "
"sözdizimi olmadan da oluşturulabilirler."

#: library/typing.rst:1539
#, fuzzy
msgid "Abstract base class for generic types."
msgstr "Genel türler için soyut temel sınıf."

#: library/typing.rst:1541
#, fuzzy
msgid ""
"A generic type is typically declared by adding a list of type parameters "
"after the class name::"
msgstr ""
"Genel bir tür genellikle sınıf adından sonra bir tür parametreleri listesi "
"eklenerek bildirilir::"

#: library/typing.rst:1549
#, fuzzy
msgid ""
"Such a class implicitly inherits from ``Generic``. The runtime semantics of "
"this syntax are discussed in the :ref:`Language Reference <generic-"
"classes>`."
msgstr ""
"Böyle bir sınıf dolaylı olarak ``Generic``'ten miras alır. Bu sözdiziminin "
"çalışma zamanı semantiği :ref:`Language Reference <generic-classes>`'da "
"tartışılmıştır."

#: library/typing.rst:1553
#, fuzzy
msgid "This class can then be used as follows::"
msgstr "Bu sınıf daha sonra şu şekilde kullanılabilir::"

#: library/typing.rst:1561
#, fuzzy
msgid ""
"Here the brackets after the function name indicate a :ref:`generic function "
"<generic-functions>`."
msgstr ""
"Burada işlev adından sonraki parantezler bir :ref:`generic function "
"<generic-functions>`'u gösterir."

#: library/typing.rst:1564
#, fuzzy
msgid ""
"For backwards compatibility, generic classes can also be declared by "
"explicitly inheriting from ``Generic``. In this case, the type parameters "
"must be declared separately::"
msgstr ""
"Geriye dönük uyumluluk için genel sınıflar, ``Generic``'ten açıkça miras "
"alınarak da bildirilebilir. Bu durumda tür parametrelerinin ayrı olarak "
"bildirilmesi gerekir::"

#: library/typing.rst:1579
#, fuzzy
msgid "Type variable."
msgstr "Değişken yazın."

#: library/typing.rst:1581
#, fuzzy
msgid ""
"The preferred way to construct a type variable is via the dedicated syntax "
"for :ref:`generic functions <generic-functions>`, :ref:`generic classes "
"<generic-classes>`, and :ref:`generic type aliases <generic-type-aliases>`::"
msgstr ""
"Bir tür değişkeni oluşturmanın tercih edilen yolu :ref:`generic type aliases"
" <generic-type-aliases>`, :ref:`generic type aliases <generic-type-aliases>`"
" ve :ref:`generic type aliases <generic-type-aliases>`: için özel "
"sözdizimidir:"

#: library/typing.rst:1589
#, fuzzy
msgid ""
"This syntax can also be used to create bound and constrained type "
"variables::"
msgstr ""
"Bu sözdizimi aynı zamanda sınırlı ve kısıtlanmış tür değişkenleri oluşturmak"
" için de kullanılabilir::"

#: library/typing.rst:1599
#, fuzzy
msgid ""
"However, if desired, reusable type variables can also be constructed "
"manually, like so::"
msgstr ""
"Ancak istenirse yeniden kullanılabilir tür değişkenleri manuel olarak da "
"oluşturulabilir::"

#: library/typing.rst:1605
#, fuzzy
msgid ""
"Type variables exist primarily for the benefit of static type checkers.  "
"They serve as the parameters for generic types as well as for generic "
"function and type alias definitions. See :class:`Generic` for more "
"information on generic types.  Generic functions work as follows::"
msgstr ""
"Tür değişkenleri öncelikle statik tür denetleyicilerin yararına mevcuttur. "
"Genel türlerin yanı sıra genel işlev ve tür takma adı tanımları için de "
"parametre görevi görürler. Genel türler hakkında daha fazla bilgi için "
":class:`Generic`'a bakın. Genel işlevler şu şekilde çalışır::"

#: library/typing.rst:1626
#, fuzzy
msgid ""
"Note that type variables can be *bound*, *constrained*, or neither, but "
"cannot be both bound *and* constrained."
msgstr ""
"Tür değişkenlerinin *and*, *and* olabileceğini veya her ikisinin birden "
"olabileceğini ancak her ikisinin de *and* ile sınırlandırılamayacağını "
"unutmayın."

#: library/typing.rst:1629
#, fuzzy
msgid ""
"The variance of type variables is inferred by type checkers when they are "
"created through the :ref:`type parameter syntax <type-params>` or when "
"``infer_variance=True`` is passed. Manually created type variables may be "
"explicitly marked covariant or contravariant by passing ``covariant=True`` "
"or ``contravariant=True``. By default, manually created type variables are "
"invariant. See :pep:`484` and :pep:`695` for more details."
msgstr ""
"Tür değişkenlerinin varyansı, :ref:`type parameter syntax <type-params>` "
"aracılığıyla oluşturulduklarında veya ``contravariant=True`` iletildiğinde "
"tür denetleyicileri tarafından çıkarılır. Manuel olarak oluşturulan tür "
"değişkenleri, ``contravariant=True`` veya ``contravariant=True``'ü geçirerek"
" açıkça ortak değişken veya karşı değişken olarak işaretlenebilir. "
"Varsayılan olarak, elle oluşturulan tür değişkenleri değişmezdir. Daha fazla"
" ayrıntı için :pep:`695` ve :pep:`695`'e bakın."

#: library/typing.rst:1637
#, fuzzy
msgid ""
"Bound type variables and constrained type variables have different semantics"
" in several important ways. Using a *bound* type variable means that the "
"``TypeVar`` will be solved using the most specific type possible::"
msgstr ""
"Bağlı tür değişkenleri ve kısıtlanmış tür değişkenleri birkaç önemli açıdan "
"farklı anlamlara sahiptir. *bound* tipi değişkenin kullanılması, "
"``TypeVar``'ün mümkün olan en spesifik tip kullanılarak çözüleceği anlamına "
"gelir::"

#: library/typing.rst:1652
#, fuzzy
msgid ""
"Type variables can be bound to concrete types, abstract types (ABCs or "
"protocols), and even unions of types::"
msgstr ""
"Tür değişkenleri somut türlere, soyut türlere (ABC'ler veya protokoller) ve "
"hatta tür birliklerine bağlanabilir::"

#: library/typing.rst:1664
#, fuzzy
msgid ""
"Using a *constrained* type variable, however, means that the ``TypeVar`` can"
" only ever be solved as being exactly one of the constraints given::"
msgstr ""
"Ancak bir *constrained* tipi değişkenin kullanılması, ``TypeVar``'ün "
"yalnızca verilen kısıtlamalardan biri olarak çözülebileceği anlamına gelir::"

#: library/typing.rst:1675
#, fuzzy
msgid "At runtime, ``isinstance(x, T)`` will raise :exc:`TypeError`."
msgstr ""
"Çalışma zamanında ``isinstance(x, T)``, :exc:`TypeError`'ü yükseltecektir."

#: library/typing.rst:1679
#, fuzzy
msgid "The name of the type variable."
msgstr "Tür değişkeninin adı."

#: library/typing.rst:1683
#, fuzzy
msgid "Whether the type var has been explicitly marked as covariant."
msgstr "Var türünün açıkça ortak değişken olarak işaretlenip işaretlenmediği."

#: library/typing.rst:1687
#, fuzzy
msgid "Whether the type var has been explicitly marked as contravariant."
msgstr ""
"Var türünün açıkça karşıt değişken olarak işaretlenip işaretlenmediği."

#: library/typing.rst:1691
#, fuzzy
msgid ""
"Whether the type variable's variance should be inferred by type checkers."
msgstr ""
"Tür değişkeninin varyansının tür denetleyicileri tarafından çıkarılıp "
"çıkarılmayacağı."

#: library/typing.rst:1697
#, fuzzy
msgid "The bound of the type variable, if any."
msgstr "Varsa, tür değişkeninin sınırı."

#: library/typing.rst:1701
#, fuzzy
msgid ""
"For type variables created through :ref:`type parameter syntax <type-"
"params>`, the bound is evaluated only when the attribute is accessed, not "
"when the type variable is created (see :ref:`lazy-evaluation`)."
msgstr ""
":ref:`lazy-evaluation` aracılığıyla oluşturulan tür değişkenleri için sınır,"
" tür değişkeni oluşturulduğunda değil, yalnızca özniteliğe erişildiğinde "
"değerlendirilir (bkz. :ref:`lazy-evaluation`)."

#: library/typing.rst:1707
#, fuzzy
msgid "A tuple containing the constraints of the type variable, if any."
msgstr "Varsa, tür değişkeninin kısıtlamalarını içeren bir tanımlama grubu."

#: library/typing.rst:1711
#, fuzzy
msgid ""
"For type variables created through :ref:`type parameter syntax <type-"
"params>`, the constraints are evaluated only when the attribute is accessed,"
" not when the type variable is created (see :ref:`lazy-evaluation`)."
msgstr ""
":ref:`lazy-evaluation` aracılığıyla oluşturulan tür değişkenleri için "
"kısıtlamalar, tür değişkeni oluşturulduğunda değil, yalnızca özniteliğe "
"erişildiğinde değerlendirilir (bkz. :ref:`lazy-evaluation`)."

#: library/typing.rst:1717
#, fuzzy
msgid ""
"Type variables can now be declared using the :ref:`type parameter <type-"
"params>` syntax introduced by :pep:`695`. The ``infer_variance`` parameter "
"was added."
msgstr ""
"Tür değişkenleri artık :pep:`695` tarafından sunulan :ref:`type parameter "
"<type-params>` sözdizimi kullanılarak bildirilebilir. ``infer_variance`` "
"parametresi eklendi."

#: library/typing.rst:1723
#, fuzzy
msgid ""
"Type variable tuple. A specialized form of :class:`type variable <TypeVar>` "
"that enables *variadic* generics."
msgstr ""
"Değişken tuple yazın. *variadic* jeneriklerini etkinleştiren özel bir "
":class:`type variable <TypeVar>` formu."

#: library/typing.rst:1726
#, fuzzy
msgid ""
"Type variable tuples can be declared in :ref:`type parameter lists <type-"
"params>` using a single asterisk (``*``) before the name::"
msgstr ""
"Tür değişkeni tanımlamaları :ref:`type parameter lists <type-params>`'da "
"adından önce tek bir yıldız işareti (``*``) kullanılarak bildirilebilir::"

#: library/typing.rst:1732
#, fuzzy
msgid "Or by explicitly invoking the ``TypeVarTuple`` constructor::"
msgstr "Veya ``TypeVarTuple`` yapıcısını açıkça çağırarak::"

#: library/typing.rst:1740
#, fuzzy
msgid ""
"A normal type variable enables parameterization with a single type. A type "
"variable tuple, in contrast, allows parameterization with an *arbitrary* "
"number of types by acting like an *arbitrary* number of type variables "
"wrapped in a tuple. For example::"
msgstr ""
"Normal tip değişkeni, tek bir tiple parametrelendirmeye olanak sağlar. Bunun"
" tersine, bir tür değişkeni tanımlama grubu, bir tanımlama kümesine sarılmış"
" bir *arbitrary* sayıdaki tür değişkeni gibi davranarak bir *arbitrary* "
"sayıda türle parametreleştirmeye olanak tanır. Örneğin::"

#: library/typing.rst:1762
#, fuzzy
msgid ""
"Note the use of the unpacking operator ``*`` in ``tuple[T, *Ts]``. "
"Conceptually, you can think of ``Ts`` as a tuple of type variables ``(T1, "
"T2, ...)``. ``tuple[T, *Ts]`` would then become ``tuple[T, *(T1, T2, "
"...)]``, which is equivalent to ``tuple[T, T1, T2, ...]``. (Note that in "
"older versions of Python, you might see this written using :data:`Unpack "
"<Unpack>` instead, as ``Unpack[Ts]``.)"
msgstr ""
"``Unpack[Ts]``'te ``Unpack[Ts]`` paket açma operatörünün kullanıldığına "
"dikkat edin. Kavramsal olarak, ``Unpack[Ts]``'ü ``Unpack[Ts]`` tipi "
"değişkenlerden oluşan bir grup olarak düşünebilirsiniz. ``Unpack[Ts]`` daha "
"sonra ``Unpack[Ts]``'e eşdeğer olan ``Unpack[Ts]`` haline gelecektir. "
"(Python'un eski sürümlerinde bunun ``Unpack[Ts]`` yerine :data:`Unpack "
"<Unpack>` kullanılarak yazıldığını görebileceğinizi unutmayın.)"

#: library/typing.rst:1770
#, fuzzy
msgid ""
"Type variable tuples must *always* be unpacked. This helps distinguish type "
"variable tuples from normal type variables::"
msgstr ""
"Tür değişkeni tuple'larının *always* paketinden çıkarılması gerekir. Bu, tür"
" değişkeni değişkenlerini normal tür değişkenlerinden ayırmaya yardımcı "
"olur::"

#: library/typing.rst:1777
#, fuzzy
msgid ""
"Type variable tuples can be used in the same contexts as normal type "
"variables. For example, in class definitions, arguments, and return types::"
msgstr ""
"Tür değişkeni tuple'ları normal tür değişkenleriyle aynı bağlamlarda "
"kullanılabilir. Örneğin, sınıf tanımlarında, argümanlarda ve dönüş "
"türlerinde::"

#: library/typing.rst:1785
#, fuzzy
msgid ""
"Type variable tuples can be happily combined with normal type variables:"
msgstr ""
"Tip değişkeni tuple'ları normal tip değişkenlerle mutlu bir şekilde "
"birleştirilebilir:"

#: library/typing.rst:1801
#, fuzzy
msgid ""
"However, note that at most one type variable tuple may appear in a single "
"list of type arguments or type parameters::"
msgstr ""
"Ancak, tek bir tür bağımsız değişkenleri veya tür parametreleri listesinde "
"en fazla bir tür değişkeni tuple'ın görünebileceğini unutmayın::"

#: library/typing.rst:1808
#, fuzzy
msgid ""
"Finally, an unpacked type variable tuple can be used as the type annotation "
"of ``*args``::"
msgstr ""
"Son olarak, ``*args``'ün tür ek açıklaması olarak paketlenmemiş bir tür "
"değişkeni tuple kullanılabilir::"

#: library/typing.rst:1818
#, fuzzy
msgid ""
"In contrast to non-unpacked annotations of ``*args`` - e.g. ``*args: int``, "
"which would specify that *all* arguments are ``int`` - ``*args: *Ts`` "
"enables reference to the types of the *individual* arguments in ``*args``. "
"Here, this allows us to ensure the types of the ``*args`` passed to "
"``call_soon`` match the types of the (positional) arguments of ``callback``."
msgstr ""
"``callback``'ün paketlenmemiş ek açıklamalarının aksine - ör. *individual* "
"bağımsız değişkenlerinin ``callback`` - ``callback`` olduğunu belirten "
"``callback``, ``callback``'teki *individual* bağımsız değişken türlerine "
"başvuru yapılmasını sağlar. Burada bu, ``callback``'e iletilen ``callback`` "
"türlerinin ``callback``'ün (konumsal) bağımsız değişken türleriyle "
"eşleştiğinden emin olmamızı sağlar."

#: library/typing.rst:1825
#, fuzzy
msgid "See :pep:`646` for more details on type variable tuples."
msgstr ""
"Tür değişkeni tuple'ları hakkında daha fazla ayrıntı için :pep:`646`'e "
"bakın."

#: library/typing.rst:1829
#, fuzzy
msgid "The name of the type variable tuple."
msgstr "Tür değişkeni tuple'ın adı."

#: library/typing.rst:1835
#, fuzzy
msgid ""
"Type variable tuples can now be declared using the :ref:`type parameter "
"<type-params>` syntax introduced by :pep:`695`."
msgstr ""
"Tür değişkeni tanımlamaları artık :pep:`695` tarafından sunulan :ref:`type "
"parameter <type-params>` sözdizimi kullanılarak bildirilebilir."

#: library/typing.rst:1840
#, fuzzy
msgid ""
"Parameter specification variable.  A specialized version of :class:`type "
"variables <TypeVar>`."
msgstr ""
"Parametre spesifikasyonu değişkeni. :class:`type variables <TypeVar>`'un "
"özel bir sürümü."

#: library/typing.rst:1843
#, fuzzy
msgid ""
"In :ref:`type parameter lists <type-params>`, parameter specifications can "
"be declared with two asterisks (``**``)::"
msgstr ""
":ref:`type parameter lists <type-params>`'da parametre özellikleri iki "
"yıldız işaretiyle (``**``) bildirilebilir::"

#: library/typing.rst:1848
#, fuzzy
msgid ""
"For compatibility with Python 3.11 and earlier, ``ParamSpec`` objects can "
"also be created as follows::"
msgstr ""
"Python 3.11 ve önceki sürümlerle uyumluluk için ``ParamSpec`` nesneleri "
"aşağıdaki şekilde de oluşturulabilir::"

#: library/typing.rst:1853
#, fuzzy
msgid ""
"Parameter specification variables exist primarily for the benefit of static "
"type checkers.  They are used to forward the parameter types of one callable"
" to another callable -- a pattern commonly found in higher order functions "
"and decorators.  They are only valid when used in ``Concatenate``, or as the"
" first argument to ``Callable``, or as parameters for user-defined Generics."
"  See :class:`Generic` for more information on generic types."
msgstr ""
"Parametre belirtimi değişkenleri öncelikle statik tip denetleyicilerin "
"yararına mevcuttur. Bir çağrılabilirin parametre türlerini başka bir "
"çağrılabilire iletmek için kullanılırlar; bu, genellikle yüksek dereceli "
"işlevlerde ve dekoratörlerde bulunan bir modeldir. Bunlar yalnızca "
"``Callable``'te veya ``Callable``'ün ilk argümanı olarak veya kullanıcı "
"tanımlı Jenerikler için parametreler olarak kullanıldığında geçerlidir. "
"Genel türler hakkında daha fazla bilgi için :class:`Generic`'a bakın."

#: library/typing.rst:1860
#, fuzzy
msgid ""
"For example, to add basic logging to a function, one can create a decorator "
"``add_logging`` to log function calls.  The parameter specification variable"
" tells the type checker that the callable passed into the decorator and the "
"new callable returned by it have inter-dependent type parameters::"
msgstr ""
"Örneğin, bir işleve temel günlük kaydı eklemek için, işlev çağrılarını "
"günlüğe kaydedecek bir ``add_logging`` dekoratörü oluşturulabilir. Parametre"
" belirtimi değişkeni, tür denetleyiciye, dekoratöre iletilen çağrılabilirin "
"ve onun tarafından döndürülen yeni çağrılabilirin birbirine bağımlı tür "
"parametrelerine sahip olduğunu bildirir::"

#: library/typing.rst:1880
#, fuzzy
msgid ""
"Without ``ParamSpec``, the simplest way to annotate this previously was to "
"use a :class:`TypeVar` with bound ``Callable[..., Any]``.  However this "
"causes two problems:"
msgstr ""
"``Callable[..., Any]`` olmadan, daha önce buna açıklama eklemenin en basit "
"yolu, bağlı ``Callable[..., Any]``'e sahip bir :class:`TypeVar` kullanmaktı."
" Ancak bu iki soruna neden olur:"

#: library/typing.rst:1884
#, fuzzy
msgid ""
"The type checker can't type check the ``inner`` function because ``*args`` "
"and ``**kwargs`` have to be typed :data:`Any`."
msgstr ""
"``**kwargs`` ve ``**kwargs``'ün :data:`Any` yazılması gerektiğinden tür "
"denetleyici ``**kwargs`` işlevini kontrol edemiyor."

#: library/typing.rst:1886
#, fuzzy
msgid ""
":func:`~cast` may be required in the body of the ``add_logging`` decorator "
"when returning the ``inner`` function, or the static type checker must be "
"told to ignore the ``return inner``."
msgstr ""
"``return inner`` işlevi döndürülürken ``return inner`` dekoratörünün "
"gövdesinde :func:`~cast` gerekebilir veya statik tür denetleyiciye ``return "
"inner``'ü yok sayması söylenmelidir."

#: library/typing.rst:1893
#, fuzzy
msgid ""
"Since ``ParamSpec`` captures both positional and keyword parameters, "
"``P.args`` and ``P.kwargs`` can be used to split a ``ParamSpec`` into its "
"components.  ``P.args`` represents the tuple of positional parameters in a "
"given call and should only be used to annotate ``*args``.  ``P.kwargs`` "
"represents the mapping of keyword parameters to their values in a given "
"call, and should be only be used to annotate ``**kwargs``.  Both attributes "
"require the annotated parameter to be in scope. At runtime, ``P.args`` and "
"``P.kwargs`` are instances respectively of :class:`ParamSpecArgs` and "
":class:`ParamSpecKwargs`."
msgstr ""
"``P.kwargs``, hem konumsal hem de anahtar kelime parametrelerini "
"yakaladığından, ``P.kwargs`` ve ``P.kwargs``, bir ``P.kwargs``'ü "
"bileşenlerine bölmek için kullanılabilir. ``P.kwargs``, belirli bir "
"çağrıdaki konumsal parametreler kümesini temsil eder ve yalnızca "
"``P.kwargs``'e açıklama eklemek için kullanılmalıdır. ``P.kwargs``, belirli "
"bir çağrıdaki anahtar kelime parametrelerinin değerleriyle eşlenmesini "
"temsil eder ve yalnızca ``P.kwargs``'e açıklama eklemek için "
"kullanılmalıdır. Her iki özellik de açıklamalı parametrenin kapsamda "
"olmasını gerektirir. Çalışma zamanında ``P.kwargs`` ve ``P.kwargs``, "
"sırasıyla :class:`ParamSpecKwargs` ve :class:`ParamSpecKwargs`'un "
"örnekleridir."

#: library/typing.rst:1905
#, fuzzy
msgid "The name of the parameter specification."
msgstr "Parametre spesifikasyonunun adı."

#: library/typing.rst:1907
#, fuzzy
msgid ""
"Parameter specification variables created with ``covariant=True`` or "
"``contravariant=True`` can be used to declare covariant or contravariant "
"generic types.  The ``bound`` argument is also accepted, similar to "
":class:`TypeVar`.  However the actual semantics of these keywords are yet to"
" be decided."
msgstr ""
"``bound`` veya ``bound`` ile oluşturulan parametre spesifikasyonu "
"değişkenleri, ortak değişken veya karşı değişken genel türleri bildirmek "
"için kullanılabilir. :class:`TypeVar`'a benzer şekilde ``bound`` argümanı da"
" kabul edilir. Ancak bu anahtar kelimelerin gerçek anlambilimine henüz karar"
" verilmedi."

#: library/typing.rst:1917
#, fuzzy
msgid ""
"Parameter specifications can now be declared using the :ref:`type parameter "
"<type-params>` syntax introduced by :pep:`695`."
msgstr ""
"Parametre özellikleri artık :pep:`695` tarafından sunulan :ref:`type "
"parameter <type-params>` sözdizimi kullanılarak bildirilebilir."

#: library/typing.rst:1921
#, fuzzy
msgid ""
"Only parameter specification variables defined in global scope can be "
"pickled."
msgstr ""
"Yalnızca genel kapsamda tanımlanan parametre belirtimi değişkenleri "
"seçilebilir."

#: library/typing.rst:1927
#, fuzzy
msgid ":data:`Concatenate`"
msgstr ":data:`Concatenate`"

#: library/typing.rst:1933
#, fuzzy
msgid ""
"Arguments and keyword arguments attributes of a :class:`ParamSpec`. The "
"``P.args`` attribute of a ``ParamSpec`` is an instance of ``ParamSpecArgs``,"
" and ``P.kwargs`` is an instance of ``ParamSpecKwargs``. They are intended "
"for runtime introspection and have no special meaning to static type "
"checkers."
msgstr ""
":class:`ParamSpec`'un bağımsız değişkenleri ve anahtar sözcük bağımsız "
"değişkenleri nitelikleri. Bir ``ParamSpecKwargs``'ün ``ParamSpecKwargs`` "
"özelliği, ``ParamSpecKwargs``'ün bir örneğidir ve ``ParamSpecKwargs``, "
"``ParamSpecKwargs``'ün bir örneğidir. Bunlar çalışma zamanı iç gözlemi için "
"tasarlanmıştır ve statik tip denetleyiciler için özel bir anlamı yoktur."

#: library/typing.rst:1938
#, fuzzy
msgid ""
"Calling :func:`get_origin` on either of these objects will return the "
"original ``ParamSpec``:"
msgstr ""
"Bu nesnelerden herhangi birinde :func:`get_origin`'yi çağırmak orijinal "
"``ParamSpec``'ü döndürecektir:"

#: library/typing.rst:1955
#, fuzzy
msgid ""
"The type of type aliases created through the :keyword:`type` statement."
msgstr ""
":keyword:`type` deyimi aracılığıyla oluşturulan tür takma adlarının türü."

#: library/typing.rst:1969
#, fuzzy
msgid "The name of the type alias:"
msgstr "Tür takma adının adı:"

#: library/typing.rst:1979
#, fuzzy
msgid "The module in which the type alias was defined::"
msgstr "Tür takma adının tanımlandığı modül::"

#: library/typing.rst:1987
#, fuzzy
msgid ""
"The type parameters of the type alias, or an empty tuple if the alias is not"
" generic:"
msgstr ""
"Tür takma adının tür parametreleri veya takma ad genel değilse boş bir "
"tanımlama grubu:"

#: library/typing.rst:2001
#, fuzzy
msgid ""
"The type alias's value. This is :ref:`lazily evaluated <lazy-evaluation>`, "
"so names used in the definition of the alias are not resolved until the "
"``__value__`` attribute is accessed:"
msgstr ""
"Tür takma adının değeri. Bu :ref:`lazily evaluated <lazy-evaluation>`'dur, "
"dolayısıyla takma adın tanımında kullanılan adlar, ``__value__`` "
"özniteliğine erişilene kadar çözümlenmez:"

#: library/typing.rst:2019
#, fuzzy
msgid "Other special directives"
msgstr "Diğer özel direktifler"

#: library/typing.rst:2021
#, fuzzy
msgid ""
"These functions and classes should not be used directly as annotations. "
"Their intended purpose is to be building blocks for creating and declaring "
"types."
msgstr ""
"Bu işlevler ve sınıflar doğrudan açıklama olarak kullanılmamalıdır. "
"Amaçlanan amaçları, türleri oluşturmak ve bildirmek için yapı taşları "
"olmaktır."

#: library/typing.rst:2027
#, fuzzy
msgid "Typed version of :func:`collections.namedtuple`."
msgstr ":func:`collections.namedtuple`'nin yazılı versiyonu."

#: library/typing.rst:2106 library/typing.rst:3055
#, fuzzy
msgid "Usage::"
msgstr "Kullanımı::"

#: library/typing.rst:2035
#, fuzzy
msgid "This is equivalent to::"
msgstr "Bu şuna eşdeğerdir::"

#: library/typing.rst:2039
#, fuzzy
msgid ""
"To give a field a default value, you can assign to it in the class body::"
msgstr ""
"Bir alana varsayılan bir değer vermek için sınıf gövdesinde ona "
"atayabilirsiniz::"

#: library/typing.rst:2048
#, fuzzy
msgid ""
"Fields with a default value must come after any fields without a default."
msgstr ""
"Varsayılan değere sahip alanlar, varsayılan değere sahip olmayan alanlardan "
"sonra gelmelidir."

#: library/typing.rst:2050
#, fuzzy
msgid ""
"The resulting class has an extra attribute ``__annotations__`` giving a dict"
" that maps the field names to the field types.  (The field names are in the "
"``_fields`` attribute and the default values are in the ``_field_defaults`` "
"attribute, both of which are part of the :func:`~collections.namedtuple` "
"API.)"
msgstr ""
"Ortaya çıkan sınıf, alan adlarını alan türleriyle eşleştiren bir dikte veren"
" ekstra bir ``_field_defaults`` özniteliğine sahiptir. (Alan adları "
"``_field_defaults`` özelliğindedir ve varsayılan değerler "
"``_field_defaults`` özelliğindedir; bunların her ikisi de "
":func:`~collections.namedtuple` API'nin parçasıdır.)"

#: library/typing.rst:2056
#, fuzzy
msgid "``NamedTuple`` subclasses can also have docstrings and methods::"
msgstr ""
"``NamedTuple`` alt sınıfları ayrıca docstring'lere ve yöntemlere de sahip "
"olabilir::"

#: library/typing.rst:2066
#, fuzzy
msgid "``NamedTuple`` subclasses can be generic::"
msgstr "``NamedTuple`` alt sınıfları genel olabilir::"

#: library/typing.rst:2072
#, fuzzy
msgid "Backward-compatible usage::"
msgstr "Geriye dönük uyumlu kullanım::"

#: library/typing.rst:2082
#, fuzzy
msgid "Added support for :pep:`526` variable annotation syntax."
msgstr ":pep:`526` değişken açıklama sözdizimi için destek eklendi."

#: library/typing.rst:2085
#, fuzzy
msgid "Added support for default values, methods, and docstrings."
msgstr "Varsayılan değerler, yöntemler ve belge dizeleri için destek eklendi."

#: library/typing.rst:2088
#, fuzzy
msgid ""
"The ``_field_types`` and ``__annotations__`` attributes are now regular "
"dictionaries instead of instances of ``OrderedDict``."
msgstr ""
"``OrderedDict`` ve ``OrderedDict`` nitelikleri artık ``OrderedDict`` "
"örnekleri yerine normal sözlüklerdir."

#: library/typing.rst:2092
#, fuzzy
msgid ""
"Removed the ``_field_types`` attribute in favor of the more standard "
"``__annotations__`` attribute which has the same information."
msgstr ""
"Aynı bilgilere sahip daha standart ``__annotations__`` özelliğinin yerine "
"``__annotations__`` özelliği kaldırıldı."

#: library/typing.rst:2096
#, fuzzy
msgid "Added support for generic namedtuples."
msgstr "Genel adlandırılmış dosyalar için destek eklendi."

#: library/typing.rst:2101
#, fuzzy
msgid "Helper class to create low-overhead :ref:`distinct types <distinct>`."
msgstr ""
"Düşük maliyetli :ref:`distinct types <distinct>` oluşturmaya yönelik "
"yardımcı sınıf."

#: library/typing.rst:2103
#, fuzzy
msgid ""
"A ``NewType`` is considered a distinct type by a typechecker. At runtime, "
"however, calling a ``NewType`` returns its argument unchanged."
msgstr ""
"Bir ``NewType``, bir daktilo denetleyicisi tarafından ayrı bir tür olarak "
"kabul edilir. Ancak çalışma zamanında bir ``NewType``'ün çağrılması, "
"argümanını değişmeden döndürür."

#: library/typing.rst:2113
#, fuzzy
msgid "The module in which the new type is defined."
msgstr "Yeni türün tanımlandığı modül."

#: library/typing.rst:2117
#, fuzzy
msgid "The name of the new type."
msgstr "Yeni türün adı."

#: library/typing.rst:2121
#, fuzzy
msgid "The type that the new type is based on."
msgstr "Yeni türün temel aldığı tür."

#: library/typing.rst:2125
#, fuzzy
msgid "``NewType`` is now a class rather than a function."
msgstr "``NewType`` artık bir işlevden ziyade bir sınıftır."

#: library/typing.rst:2130
#, fuzzy
msgid "Base class for protocol classes."
msgstr "Protokol sınıfları için temel sınıf."

#: library/typing.rst:2132
#, fuzzy
msgid "Protocol classes are defined like this::"
msgstr "Protokol sınıfları şu şekilde tanımlanır::"

#: library/typing.rst:2138
#, fuzzy
msgid ""
"Such classes are primarily used with static type checkers that recognize "
"structural subtyping (static duck-typing), for example::"
msgstr ""
"Bu tür sınıflar öncelikle yapısal alt tiplemeyi (statik ördek yazma) tanıyan"
" statik tip denetleyicilerle birlikte kullanılır, örneğin::"

#: library/typing.rst:2150
#, fuzzy
msgid ""
"See :pep:`544` for more details. Protocol classes decorated with "
":func:`runtime_checkable` (described later) act as simple-minded runtime "
"protocols that check only the presence of given attributes, ignoring their "
"type signatures."
msgstr ""
"Daha fazla ayrıntı için :pep:`544`'e bakın. :func:`runtime_checkable` (daha "
"sonra açıklanacaktır) ile donatılan protokol sınıfları, tür imzalarını göz "
"ardı ederek yalnızca belirli özniteliklerin varlığını kontrol eden basit "
"çalışma zamanı protokolleri olarak hareket eder."

#: library/typing.rst:2155
#, fuzzy
msgid "Protocol classes can be generic, for example::"
msgstr "Protokol sınıfları genel olabilir, örneğin::"

#: library/typing.rst:2161
#, fuzzy
msgid ""
"In code that needs to be compatible with Python 3.11 or older, generic "
"Protocols can be written as follows::"
msgstr ""
"Python 3.11 veya daha eski sürümlerle uyumlu olması gereken kodlarda genel "
"Protokoller şu şekilde yazılabilir:"

#: library/typing.rst:2174
#, fuzzy
msgid "Mark a protocol class as a runtime protocol."
msgstr "Bir protokol sınıfını çalışma zamanı protokolü olarak işaretleyin."

#: library/typing.rst:2176
#, fuzzy
msgid ""
"Such a protocol can be used with :func:`isinstance` and :func:`issubclass`. "
"This raises :exc:`TypeError` when applied to a non-protocol class.  This "
"allows a simple-minded structural check, very similar to \"one trick "
"ponies\" in :mod:`collections.abc` such as "
":class:`~collections.abc.Iterable`.  For example::"
msgstr ""
"Böyle bir protokol :func:`issubclass` ve :func:`issubclass` ile "
"kullanılabilir. Bu, protokol dışı bir sınıfa uygulandığında "
":exc:`TypeError`'ü yükseltir. Bu, :class:`~collections.abc.Iterable` gibi "
":mod:`collections.abc`'deki \"tek hileli midillilere\" çok benzer, basit "
"fikirli bir yapısal kontrole olanak tanır. Örneğin::"

#: library/typing.rst:2196
#, fuzzy
msgid ""
":func:`!runtime_checkable` will check only the presence of the required "
"methods or attributes, not their type signatures or types. For example, "
":class:`ssl.SSLObject` is a class, therefore it passes an :func:`issubclass`"
" check against :ref:`Callable <annotating-callables>`. However, the "
"``ssl.SSLObject.__init__`` method exists only to raise a :exc:`TypeError` "
"with a more informative message, therefore making it impossible to call "
"(instantiate) :class:`ssl.SSLObject`."
msgstr ""
":func:`issubclass`, tür imzalarını veya türlerini değil, yalnızca gerekli "
"yöntemlerin veya özniteliklerin varlığını denetleyecektir. Örneğin, "
":class:`ssl.SSLObject` bir sınıf olduğundan :ref:`Callable <annotating-"
"callables>`'a karşı bir :func:`issubclass` kontrolünden geçer. Bununla "
"birlikte, ``ssl.SSLObject.__init__`` yöntemi yalnızca bir :exc:`TypeError`'ü"
" daha bilgilendirici bir mesajla yükseltmek için mevcuttur, bu nedenle "
":class:`ssl.SSLObject`'un çağrılmasını (örneklenmesini) imkansız hale "
"getirir."

#: library/typing.rst:2207
#, fuzzy
msgid ""
"An :func:`isinstance` check against a runtime-checkable protocol can be "
"surprisingly slow compared to an ``isinstance()`` check against a non-"
"protocol class. Consider using alternative idioms such as :func:`hasattr` "
"calls for structural checks in performance-sensitive code."
msgstr ""
"Çalışma zamanı tarafından denetlenebilen bir protokole karşı yapılan "
":func:`hasattr` denetimi, protokol dışı bir sınıfa karşı yapılan "
"``isinstance()`` denetimine kıyasla şaşırtıcı derecede yavaş olabilir. "
"Performansa duyarlı kodda yapısal kontroller için :func:`hasattr` çağrıları "
"gibi alternatif deyimler kullanmayı düşünün."

#: library/typing.rst:2215
#, fuzzy
msgid ""
"The internal implementation of :func:`isinstance` checks against runtime-"
"checkable protocols now uses :func:`inspect.getattr_static` to look up "
"attributes (previously, :func:`hasattr` was used). As a result, some objects"
" which used to be considered instances of a runtime-checkable protocol may "
"no longer be considered instances of that protocol on Python 3.12+, and vice"
" versa. Most users are unlikely to be affected by this change."
msgstr ""
":func:`hasattr` kontrollerinin çalışma zamanı tarafından kontrol edilebilir "
"protokollere karşı dahili uygulaması artık özniteliklere bakmak için "
":func:`hasattr`'yi kullanıyor (daha önce :func:`hasattr` kullanılıyordu). "
"Sonuç olarak, eskiden çalışma zamanı tarafından kontrol edilebilir bir "
"protokolün örnekleri olarak kabul edilen bazı nesneler artık Python 3.12+ "
"üzerinde bu protokolün örnekleri olarak kabul edilmeyebilir (ve bunun tersi "
"de geçerlidir). Çoğu kullanıcının bu değişiklikten etkilenmesi pek olası "
"değildir."

#: library/typing.rst:2224
#, fuzzy
msgid ""
"The members of a runtime-checkable protocol are now considered \"frozen\" at"
" runtime as soon as the class has been created. Monkey-patching attributes "
"onto a runtime-checkable protocol will still work, but will have no impact "
"on :func:`isinstance` checks comparing objects to the protocol. See "
":ref:`\"What's new in Python 3.12\" <whatsnew-typing-py312>` for more "
"details."
msgstr ""
"Çalışma zamanı tarafından kontrol edilebilen bir protokolün üyeleri, artık "
"sınıf oluşturulduktan sonra çalışma zamanında \"dondurulmuş\" olarak "
"değerlendirilmektedir. Çalışma zamanı tarafından kontrol edilebilir bir "
"protokole maymun yama özellikleri uygulanmaya devam edecek ancak nesneleri "
"protokolle karşılaştıran :func:`isinstance` kontrolleri üzerinde hiçbir "
"etkisi olmayacak. Daha fazla ayrıntı için :ref:`\"What's new in Python "
"3.12\" <whatsnew-typing-py312>`'a bakın."

#: library/typing.rst:2235
#, fuzzy
msgid ""
"Special construct to add type hints to a dictionary. At runtime it is a "
"plain :class:`dict`."
msgstr ""
"Bir sözlüğe tür ipuçları eklemek için özel yapı. Çalışma zamanında düz bir "
":class:`dict`'dur."

#: library/typing.rst:2238
#, fuzzy
msgid ""
"``TypedDict`` declares a dictionary type that expects all of its instances "
"to have a certain set of keys, where each key is associated with a value of "
"a consistent type. This expectation is not checked at runtime but is only "
"enforced by type checkers. Usage::"
msgstr ""
"``TypedDict``, tüm örneklerinin belirli bir anahtar kümesine sahip olmasını "
"bekleyen ve her anahtarın tutarlı türdeki bir değerle ilişkilendirildiği bir"
" sözlük türü bildirir. Bu beklenti çalışma zamanında kontrol edilmez ancak "
"yalnızca tür denetleyicileri tarafından uygulanır. Kullanımı::"

#: library/typing.rst:2254
#, fuzzy
msgid ""
"To allow using this feature with older versions of Python that do not "
"support :pep:`526`, ``TypedDict`` supports two additional equivalent "
"syntactic forms:"
msgstr ""
"Bu özelliğin :pep:`526`'i desteklemeyen eski Python sürümleriyle "
"kullanılmasına izin vermek için ``TypedDict``, iki ek eşdeğer sözdizimsel "
"formu destekler:"

#: library/typing.rst:2258
#, fuzzy
msgid "Using a literal :class:`dict` as the second argument::"
msgstr "İkinci argüman olarak gerçek bir :class:`dict` kullanma::"

#: library/typing.rst:2262
#, fuzzy
msgid "Using keyword arguments::"
msgstr "Anahtar kelime bağımsız değişkenlerini kullanma::"

#: library/typing.rst:2269
#, fuzzy
msgid ""
"The keyword-argument syntax is deprecated in 3.11 and will be removed in "
"3.13. It may also be unsupported by static type checkers."
msgstr ""
"Anahtar kelime-argüman sözdizimi 3.11'de kullanımdan kaldırıldı ve 3.13'te "
"kaldırılacak. Ayrıca statik tip denetleyiciler tarafından da desteklenmiyor "
"olabilir."

#: library/typing.rst:2270
#, fuzzy
msgid ""
"The functional syntax should also be used when any of the keys are not valid"
" :ref:`identifiers <identifiers>`, for example because they are keywords or "
"contain hyphens. Example::"
msgstr ""
"İşlevsel sözdizimi, anahtarlardan herhangi biri geçerli :ref:`identifiers "
"<identifiers>` olmadığında da kullanılmalıdır; örneğin bunlar anahtar sözcük"
" olduğundan veya kısa çizgi içerdiğinden. Örnek::"

#: library/typing.rst:2282
#, fuzzy
msgid ""
"By default, all keys must be present in a ``TypedDict``. It is possible to "
"mark individual keys as non-required using :data:`NotRequired`::"
msgstr ""
"Varsayılan olarak tüm anahtarların bir ``TypedDict``'te bulunması gerekir. "
":data:`NotRequired`:: kullanılarak tek tek anahtarların gerekli olmadığı "
"şeklinde işaretlenmesi mümkündür."

#: library/typing.rst:2293
#, fuzzy
msgid ""
"This means that a ``Point2D`` ``TypedDict`` can have the ``label`` key "
"omitted."
msgstr ""
"Bu, bir ``label`` ``label``'te ``label`` anahtarının atlanabileceği anlamına"
" gelir."

#: library/typing.rst:2296
#, fuzzy
msgid ""
"It is also possible to mark all keys as non-required by default by "
"specifying a totality of ``False``::"
msgstr ""
"``False``:: toplamını belirterek tüm anahtarları varsayılan olarak gerekli "
"olmayan olarak işaretlemek de mümkündür:"

#: library/typing.rst:2306
#, fuzzy
msgid ""
"This means that a ``Point2D`` ``TypedDict`` can have any of the keys "
"omitted. A type checker is only expected to support a literal ``False`` or "
"``True`` as the value of the ``total`` argument. ``True`` is the default, "
"and makes all items defined in the class body required."
msgstr ""
"Bu, bir ``True`` ``True``'te herhangi bir anahtarın atlanabileceği anlamına "
"gelir. Bir tür denetleyicinin, ``True`` bağımsız değişkeninin değeri olarak "
"yalnızca gerçek bir ``True`` veya ``True``'ü desteklemesi beklenir. ``True``"
" varsayılandır ve sınıf gövdesinde tanımlanan tüm öğelerin gerekli olmasını "
"sağlar."

#: library/typing.rst:2311
#, fuzzy
msgid ""
"Individual keys of a ``total=False`` ``TypedDict`` can be marked as required"
" using :data:`Required`::"
msgstr ""
"``TypedDict`` ``TypedDict``'ün ayrı ayrı anahtarları, :data:`Required` "
"kullanılarak gerektiği şekilde işaretlenebilir::"

#: library/typing.rst:2326
#, fuzzy
msgid ""
"It is possible for a ``TypedDict`` type to inherit from one or more other "
"``TypedDict`` types using the class-based syntax. Usage::"
msgstr ""
"Bir ``TypedDict`` türünün, sınıf tabanlı sözdizimini kullanarak bir veya "
"daha fazla diğer ``TypedDict`` türünden miras alması mümkündür. Kullanımı::"

#: library/typing.rst:2333
#, fuzzy
msgid ""
"``Point3D`` has three items: ``x``, ``y`` and ``z``. It is equivalent to "
"this definition::"
msgstr ""
"``z``'ün üç öğesi vardır: ``z``, ``z`` ve ``z``. Bu tanıma eşdeğerdir::"

#: library/typing.rst:2341
#, fuzzy
msgid ""
"A ``TypedDict`` cannot inherit from a non-\\ ``TypedDict`` class, except for"
" :class:`Generic`. For example::"
msgstr ""
"Bir ``TypedDict``, :class:`Generic` dışında ``TypedDict`` olmayan bir "
"sınıftan miras alamaz. Örneğin::"

#: library/typing.rst:2356
#, fuzzy
msgid "A ``TypedDict`` can be generic::"
msgstr "Bir ``TypedDict`` genel olabilir::"

#: library/typing.rst:2362
#, fuzzy
msgid ""
"To create a generic ``TypedDict`` that is compatible with Python 3.11 or "
"lower, inherit from :class:`Generic` explicitly:"
msgstr ""
"Python 3.11 veya daha düşük sürümlerle uyumlu genel bir ``TypedDict`` "
"oluşturmak için :class:`Generic`'dan açıkça miras alın:"

#: library/typing.rst:2373
#, fuzzy
msgid ""
"A ``TypedDict`` can be introspected via annotations dicts (see "
":ref:`annotations-howto` for more information on annotations best "
"practices), :attr:`__total__`, :attr:`__required_keys__`, and "
":attr:`__optional_keys__`."
msgstr ""
"Bir ``TypedDict``, açıklama dikteleri (en iyi açıklama uygulamaları hakkında"
" daha fazla bilgi için :ref:`annotations-howto`'a bakın), "
":attr:`__optional_keys__`, :attr:`__optional_keys__` ve "
":attr:`__optional_keys__` aracılığıyla iç gözlem yapılabilir."

#: library/typing.rst:2379
#, fuzzy
msgid ""
"``Point2D.__total__`` gives the value of the ``total`` argument. Example:"
msgstr "``total``, ``total`` bağımsız değişkeninin değerini verir. Örnek:"

#: library/typing.rst:2401
#, fuzzy
msgid ""
"``Point2D.__required_keys__`` and ``Point2D.__optional_keys__`` return "
":class:`frozenset` objects containing required and non-required keys, "
"respectively."
msgstr ""
"``Point2D.__optional_keys__`` ve ``Point2D.__optional_keys__``, sırasıyla "
"gerekli ve gerekli olmayan anahtarları içeren :class:`frozenset` nesnelerini"
" döndürür."

#: library/typing.rst:2404
#, fuzzy
msgid ""
"Keys marked with :data:`Required` will always appear in "
"``__required_keys__`` and keys marked with :data:`NotRequired` will always "
"appear in ``__optional_keys__``."
msgstr ""
":data:`NotRequired` ile işaretlenen anahtarlar her zaman "
"``__optional_keys__``'te görünecek ve :data:`NotRequired` ile işaretlenen "
"anahtarlar her zaman ``__optional_keys__``'te görünecektir."

#: library/typing.rst:2407
#, fuzzy
msgid ""
"For backwards compatibility with Python 3.10 and below, it is also possible "
"to use inheritance to declare both required and non-required keys in the "
"same ``TypedDict`` . This is done by declaring a ``TypedDict`` with one "
"value for the ``total`` argument and then inheriting from it in another "
"``TypedDict`` with a different value for ``total``:"
msgstr ""
"Python 3.10 ve altıyla geriye dönük uyumluluk için, aynı ``total``'te hem "
"gerekli hem de gerekli olmayan anahtarları bildirmek için kalıtımı kullanmak"
" da mümkündür. Bu, ``total`` bağımsız değişkeni için bir değere sahip bir "
"``total`` bildirilerek ve ardından ``total`` için farklı bir değere sahip "
"başka bir ``total``'te bundan miras alınarak yapılır:"

#: library/typing.rst:2430
#, fuzzy
msgid ""
"See :pep:`589` for more examples and detailed rules of using ``TypedDict``."
msgstr ""
"Daha fazla örnek ve ``TypedDict`` kullanımına ilişkin ayrıntılı kurallar "
"için :pep:`589`'e bakın."

#: library/typing.rst:2434
#, fuzzy
msgid ""
"Added support for marking individual keys as :data:`Required` or "
":data:`NotRequired`. See :pep:`655`."
msgstr ""
"Tek tek anahtarların :data:`NotRequired` veya :data:`NotRequired` olarak "
"işaretlenmesine yönelik destek eklendi. Bkz. :pep:`655`."

#: library/typing.rst:2438
#, fuzzy
msgid "Added support for generic ``TypedDict``\\ s."
msgstr "Genel ``TypedDict``\\'ler için destek eklendi."

#: library/typing.rst:2442
#, fuzzy
msgid "Protocols"
msgstr "Protokoller"

#: library/typing.rst:2444
#, fuzzy
msgid ""
"The following protocols are provided by the typing module. All are decorated"
" with :func:`@runtime_checkable <runtime_checkable>`."
msgstr ""
"Aşağıdaki protokoller yazma modülü tarafından sağlanır. Hepsi "
":func:`@runtime_checkable <runtime_checkable>` ile dekore edilmiştir."

#: library/typing.rst:2449
#, fuzzy
msgid ""
"An ABC with one abstract method ``__abs__`` that is covariant in its return "
"type."
msgstr ""
"Dönüş türünde ortak değişken olan ``__abs__`` soyut yöntemine sahip bir ABC."

#: library/typing.rst:2454
#, fuzzy
msgid "An ABC with one abstract method ``__bytes__``."
msgstr "Tek soyut yönteme sahip bir ABC ``__bytes__``."

#: library/typing.rst:2458
#, fuzzy
msgid "An ABC with one abstract method ``__complex__``."
msgstr "Tek soyut yönteme sahip bir ABC ``__complex__``."

#: library/typing.rst:2462
#, fuzzy
msgid "An ABC with one abstract method ``__float__``."
msgstr "Tek soyut yönteme sahip bir ABC ``__float__``."

#: library/typing.rst:2466
#, fuzzy
msgid "An ABC with one abstract method ``__index__``."
msgstr "Tek soyut yönteme sahip bir ABC ``__index__``."

#: library/typing.rst:2472
#, fuzzy
msgid "An ABC with one abstract method ``__int__``."
msgstr "Tek soyut yönteme sahip bir ABC ``__int__``."

#: library/typing.rst:2476
#, fuzzy
msgid ""
"An ABC with one abstract method ``__round__`` that is covariant in its "
"return type."
msgstr ""
"Dönüş türünde ortak değişken olan ``__round__`` soyut yöntemine sahip bir "
"ABC."

#: library/typing.rst:2480
#, fuzzy
msgid "ABCs for working with IO"
msgstr "IO ile çalışmaya yönelik ABC'ler"

#: library/typing.rst:2486
#, fuzzy
msgid ""
"Generic type ``IO[AnyStr]`` and its subclasses ``TextIO(IO[str])`` and "
"``BinaryIO(IO[bytes])`` represent the types of I/O streams such as returned "
"by :func:`open`."
msgstr ""
"Genel tip ``BinaryIO(IO[bytes])`` ve onun alt sınıfları "
"``BinaryIO(IO[bytes])`` ve ``BinaryIO(IO[bytes])``, :func:`open` tarafından "
"döndürülen G/Ç akışı türlerini temsil eder."

#: library/typing.rst:2492
#, fuzzy
msgid "Functions and decorators"
msgstr "Fonksiyonlar ve dekoratörler"

#: library/typing.rst:2496
#, fuzzy
msgid "Cast a value to a type."
msgstr "Bir türe değer atama."

#: library/typing.rst:2498
#, fuzzy
msgid ""
"This returns the value unchanged.  To the type checker this signals that the"
" return value has the designated type, but at runtime we intentionally don't"
" check anything (we want this to be as fast as possible)."
msgstr ""
"Bu, değeri değişmeden döndürür. Tür denetleyiciye bu, dönüş değerinin "
"belirlenen türe sahip olduğu sinyalini verir, ancak çalışma zamanında "
"kasıtlı olarak hiçbir şeyi kontrol etmiyoruz (bunun mümkün olduğu kadar "
"hızlı olmasını istiyoruz)."

#: library/typing.rst:2505
#, fuzzy
msgid ""
"Ask a static type checker to confirm that *val* has an inferred type of "
"*typ*."
msgstr ""
"Statik tür denetleyicisinden *typ*'in çıkarımlanmış bir *typ* türüne sahip "
"olduğunu doğrulamasını isteyin."

#: library/typing.rst:2507
#, fuzzy
msgid ""
"At runtime this does nothing: it returns the first argument unchanged with "
"no checks or side effects, no matter the actual type of the argument."
msgstr ""
"Çalışma zamanında bu hiçbir şey yapmaz: argümanın gerçek türü ne olursa "
"olsun, hiçbir kontrol veya yan etki olmadan ilk argümanı değişmeden "
"döndürür."

#: library/typing.rst:2510
#, fuzzy
msgid ""
"When a static type checker encounters a call to ``assert_type()``, it emits "
"an error if the value is not of the specified type::"
msgstr ""
"Statik tür denetleyicisi ``assert_type()``'e yapılan bir çağrıyla "
"karşılaştığında, değer belirtilen türde değilse bir hata verir::"

#: library/typing.rst:2517
#, fuzzy
msgid ""
"This function is useful for ensuring the type checker's understanding of a "
"script is in line with the developer's intentions::"
msgstr ""
"Bu işlev, tür denetleyicinin bir komut dosyasını anlamasının geliştiricinin "
"amaçlarına uygun olmasını sağlamak için kullanışlıdır::"

#: library/typing.rst:2531
#, fuzzy
msgid ""
"Ask a static type checker to confirm that a line of code is unreachable."
msgstr ""
"Statik tür denetleyicisinden bir kod satırının erişilemez olduğunu "
"doğrulamasını isteyin."

#: library/typing.rst:2533
#, fuzzy
msgid "Example::"
msgstr "Örnek::"

#: library/typing.rst:2544
#, fuzzy
msgid ""
"Here, the annotations allow the type checker to infer that the last case can"
" never execute, because ``arg`` is either an :class:`int` or a :class:`str`,"
" and both options are covered by earlier cases."
msgstr ""
"Burada ek açıklamalar, ``arg``'ün ya bir :class:`str` ya da :class:`str` "
"olması ve her iki seçeneğin de önceki vakaların kapsamına girmesi nedeniyle "
"tür denetleyicinin son vakanın hiçbir zaman yürütülemeyeceği sonucunu "
"çıkarmasına olanak tanır."

#: library/typing.rst:2549
#, fuzzy
msgid ""
"If a type checker finds that a call to ``assert_never()`` is reachable, it "
"will emit an error. For example, if the type annotation for ``arg`` was "
"instead ``int | str | float``, the type checker would emit an error pointing"
" out that ``unreachable`` is of type :class:`float`. For a call to "
"``assert_never`` to pass type checking, the inferred type of the argument "
"passed in must be the bottom type, :data:`Never`, and nothing else."
msgstr ""
"Bir tür denetleyici ``assert_never``'e yapılan bir çağrının ulaşılabilir "
"olduğunu tespit ederse bir hata verecektir. Örneğin, ``assert_never`` için "
"tür ek açıklaması bunun yerine ``assert_never`` ise tür denetleyici, "
"``assert_never``'ün :class:`float` türünde olduğunu belirten bir hata "
"verecektir. ``assert_never``'e yapılan çağrının tür denetimini geçmesi için,"
" aktarılan bağımsız değişkenin türetilen türünün alt tür olan :data:`Never` "
"olması ve başka hiçbir şeyin olmaması gerekir."

#: library/typing.rst:2557
#, fuzzy
msgid "At runtime, this throws an exception when called."
msgstr "Çalışma zamanında bu çağrıldığında bir istisna atar."

#: library/typing.rst:2560
#, fuzzy
msgid ""
"`Unreachable Code and Exhaustiveness Checking "
"<https://typing.readthedocs.io/en/latest/source/unreachable.html>`__ has "
"more information about exhaustiveness checking with static typing."
msgstr ""
"`Unreachable Code and Exhaustiveness Checking "
"<https://typing.readthedocs.io/en/latest/source/unreachable.html>`__, statik"
" yazmayla kapsamlılık denetimi hakkında daha fazla bilgiye sahiptir."

#: library/typing.rst:2568
#, fuzzy
msgid "Reveal the inferred static type of an expression."
msgstr "Bir ifadenin çıkarımlanan statik türünü ortaya çıkarın."

#: library/typing.rst:2570
#, fuzzy
msgid ""
"When a static type checker encounters a call to this function, it emits a "
"diagnostic with the type of the argument. For example::"
msgstr ""
"Statik tip denetleyici bu fonksiyona bir çağrıyla karşılaştığında, argümanın"
" tipini içeren bir tanılama yayınlar. Örneğin::"

#: library/typing.rst:2576
#, fuzzy
msgid ""
"This can be useful when you want to debug how your type checker handles a "
"particular piece of code."
msgstr ""
"Bu, tür denetleyicinizin belirli bir kod parçasını nasıl işlediğini hata "
"ayıklamak istediğinizde yararlı olabilir."

#: library/typing.rst:2579
#, fuzzy
msgid ""
"The function returns its argument unchanged, which allows using it within an"
" expression::"
msgstr ""
"İşlev, argümanını değişmeden döndürür, bu da onun bir ifade içinde "
"kullanılmasına olanak tanır::"

#: library/typing.rst:2584
#, fuzzy
msgid ""
"Most type checkers support ``reveal_type()`` anywhere, even if the name is "
"not imported from ``typing``. Importing the name from ``typing`` allows your"
" code to run without runtime errors and communicates intent more clearly."
msgstr ""
"Çoğu tür denetleyicisi, ad ``typing``'ten içe aktarılmamış olsa bile "
"``typing``'ü her yerde destekler. Adı ``typing``'ten içe aktarmak, kodunuzun"
" çalışma zamanı hataları olmadan çalışmasına olanak tanır ve amacı daha net "
"bir şekilde iletir."

#: library/typing.rst:2589
#, fuzzy
msgid ""
"At runtime, this function prints the runtime type of its argument to stderr "
"and returns it unchanged::"
msgstr ""
"Çalışma zamanında bu işlev, bağımsız değişkeninin çalışma zamanı türünü "
"stderr'e yazdırır ve onu değişmeden döndürür::"

#: library/typing.rst:2601
#, fuzzy
msgid ""
"Decorator to mark an object as providing :func:`dataclass "
"<dataclasses.dataclass>`-like behavior."
msgstr ""
"Bir nesneyi :func:`dataclass <dataclasses.dataclass>` benzeri davranış "
"sağlayacak şekilde işaretlemek için dekoratör."

#: library/typing.rst:2604
#, fuzzy
msgid ""
"``dataclass_transform`` may be used to decorate a class, metaclass, or a "
"function that is itself a decorator. The presence of "
"``@dataclass_transform()`` tells a static type checker that the decorated "
"object performs runtime \"magic\" that transforms a class in a similar way "
"to :func:`@dataclasses.dataclass <dataclasses.dataclass>`."
msgstr ""
"``@dataclass_transform()`` bir sınıfı, metasınıfı veya kendisi de dekoratör "
"olan bir işlevi süslemek için kullanılabilir. ``@dataclass_transform()``'ün "
"varlığı, statik tür denetleyiciye, dekore edilmiş nesnenin, bir sınıfı "
":func:`@dataclasses.dataclass <dataclasses.dataclass>`'ye benzer şekilde "
"dönüştüren çalışma zamanı \"sihri\" gerçekleştirdiğini bildirir."

#: library/typing.rst:2611
#, fuzzy
msgid "Example usage with a decorator function:"
msgstr "Dekoratör işleviyle örnek kullanım:"

#: library/typing.rst:2625
#, fuzzy
msgid "On a base class::"
msgstr "Temel sınıfta::"

#: library/typing.rst:2634
#, fuzzy
msgid "On a metaclass::"
msgstr "Bir metasınıfta::"

#: library/typing.rst:2645
#, fuzzy
msgid ""
"The ``CustomerModel`` classes defined above will be treated by type checkers"
" similarly to classes created with :func:`@dataclasses.dataclass "
"<dataclasses.dataclass>`. For example, type checkers will assume these "
"classes have ``__init__`` methods that accept ``id`` and ``name``."
msgstr ""
"Yukarıda tanımlanan ``name`` sınıfları, tür denetleyicileri tarafından "
":func:`@dataclasses.dataclass <dataclasses.dataclass>` ile oluşturulan "
"sınıflara benzer şekilde ele alınacaktır. Örneğin, tür denetleyicileri bu "
"sınıfların ``name`` ve ``name``'ü kabul eden ``name`` yöntemlerine sahip "
"olduğunu varsayacaktır."

#: library/typing.rst:2651
#, fuzzy
msgid ""
"The decorated class, metaclass, or function may accept the following bool "
"arguments which type checkers will assume have the same effect as they would"
" have on the :func:`@dataclasses.dataclass<dataclasses.dataclass>` "
"decorator: ``init``, ``eq``, ``order``, ``unsafe_hash``, ``frozen``, "
"``match_args``, ``kw_only``, and ``slots``. It must be possible for the "
"value of these arguments (``True`` or ``False``) to be statically evaluated."
msgstr ""
"Dekore edilmiş sınıf, metasınıf veya işlev, tür denetleyicilerinin "
":func:`@dataclasses.dataclass<dataclasses.dataclass>` dekoratöründe sahip "
"olacakları ile aynı etkiye sahip olduğunu varsayacakları aşağıdaki bool "
"bağımsız değişkenlerini kabul edebilir: ``False``, ``False``, ``False``, "
"``False``, ``False``, ``False``, ``False`` ve ``False``. Bu bağımsız "
"değişkenlerin (``False`` veya ``False``) değerinin statik olarak "
"değerlendirilmesi mümkün olmalıdır."

#: library/typing.rst:2659
#, fuzzy
msgid ""
"The arguments to the ``dataclass_transform`` decorator can be used to "
"customize the default behaviors of the decorated class, metaclass, or "
"function:"
msgstr ""
"``dataclass_transform`` dekoratörünün argümanları, dekore edilmiş sınıfın, "
"metasınıfın veya fonksiyonun varsayılan davranışlarını özelleştirmek için "
"kullanılabilir:"

#: library/typing.rst:0
#, fuzzy
msgid "Parameters"
msgstr "Parametreler"

#: library/typing.rst:2663
#, fuzzy
msgid ""
"Indicates whether the ``eq`` parameter is assumed to be ``True`` or "
"``False`` if it is omitted by the caller. Defaults to ``True``."
msgstr ""
"Arayan tarafından atlanırsa ``True`` parametresinin ``True`` veya ``True`` "
"olarak kabul edilip edilmediğini belirtir. Varsayılan olarak ``True``'tür."

#: library/typing.rst:2668
#, fuzzy
msgid ""
"Indicates whether the ``order`` parameter is assumed to be ``True`` or "
"``False`` if it is omitted by the caller. Defaults to ``False``."
msgstr ""
"Arayan tarafından atlanırsa ``False`` parametresinin ``False`` veya "
"``False`` olarak kabul edilip edilmediğini belirtir. Varsayılan olarak "
"``False``'tür."

#: library/typing.rst:2673
#, fuzzy
msgid ""
"Indicates whether the ``kw_only`` parameter is assumed to be ``True`` or "
"``False`` if it is omitted by the caller. Defaults to ``False``."
msgstr ""
"Arayan tarafından atlanırsa ``False`` parametresinin ``False`` veya "
"``False`` olarak kabul edilip edilmediğini belirtir. Varsayılan olarak "
"``False``'tür."

#: library/typing.rst:2678
#, fuzzy
msgid ""
"Indicates whether the ``frozen`` parameter is assumed to be ``True`` or "
"``False`` if it is omitted by the caller. Defaults to ``False``.  .. "
"versionadded:: 3.12"
msgstr ""
"Arayan tarafından atlanırsa ``False`` parametresinin ``False`` veya "
"``False`` olarak kabul edilip edilmediğini belirtir. Varsayılan olarak "
"``False``'tür. ..versiyon eklendi:: 3.12"

#: library/typing.rst:2679
#, fuzzy
msgid ""
"Indicates whether the ``frozen`` parameter is assumed to be ``True`` or "
"``False`` if it is omitted by the caller. Defaults to ``False``."
msgstr ""
"Arayan tarafından atlanırsa ``False`` parametresinin ``False`` veya "
"``False`` olarak kabul edilip edilmediğini belirtir. Varsayılan olarak "
"``False``'tür."

#: library/typing.rst:2685
#, fuzzy
msgid ""
"Specifies a static list of supported classes or functions that describe "
"fields, similar to :func:`dataclasses.field`. Defaults to ``()``."
msgstr ""
":func:`dataclasses.field`'ye benzer şekilde, alanları tanımlayan, "
"desteklenen sınıfların veya işlevlerin statik bir listesini belirtir. "
"Varsayılan olarak ``()``'tür."

#: library/typing.rst:2691
#, fuzzy
msgid ""
"Arbitrary other keyword arguments are accepted in order to allow for "
"possible future extensions."
msgstr ""
"Gelecekteki olası uzantılara izin vermek için keyfi diğer anahtar kelime "
"argümanları kabul edilir."

#: library/typing.rst:2695
#, fuzzy
msgid ""
"Type checkers recognize the following optional parameters on field "
"specifiers:"
msgstr ""
"Tür denetleyicileri, alan belirticilerde aşağıdaki isteğe bağlı "
"parametreleri tanır:"

#: library/typing.rst:2698
#, fuzzy
msgid "**Recognised parameters for field specifiers**"
msgstr "**Recognised parameters for field specifiers**"

#: library/typing.rst:2702
#, fuzzy
msgid "Parameter name"
msgstr "Parametre adı"

#: library/typing.rst:2703
#, fuzzy
msgid "Description"
msgstr "Tanım"

#: library/typing.rst:2704
#, fuzzy
msgid "``init``"
msgstr "``init``"

#: library/typing.rst:2705
#, fuzzy
msgid ""
"Indicates whether the field should be included in the synthesized "
"``__init__`` method. If unspecified, ``init`` defaults to ``True``."
msgstr ""
"Alanın sentezlenen ``True`` yöntemine dahil edilip edilmeyeceğini belirtir. "
"Belirtilmezse ``True`` varsayılan olarak ``True`` olur."

#: library/typing.rst:2708
#, fuzzy
msgid "``default``"
msgstr "``default``"

#: library/typing.rst:2709
#, fuzzy
msgid "Provides the default value for the field."
msgstr "Alan için varsayılan değeri sağlar."

#: library/typing.rst:2710
#, fuzzy
msgid "``default_factory``"
msgstr "``default_factory``"

#: library/typing.rst:2711
#, fuzzy
msgid ""
"Provides a runtime callback that returns the default value for the field. If"
" neither ``default`` nor ``default_factory`` are specified, the field is "
"assumed to have no default value and must be provided a value when the class"
" is instantiated."
msgstr ""
"Alan için varsayılan değeri döndüren bir çalışma zamanı geri çağrısı sağlar."
" ``default_factory`` veya ``default_factory`` belirtilmezse alanın "
"varsayılan bir değeri olmadığı ve sınıf başlatıldığında bir değer sağlanması"
" gerektiği varsayılır."

#: library/typing.rst:2716
#, fuzzy
msgid "``factory``"
msgstr "``factory``"

#: library/typing.rst:2717
#, fuzzy
msgid "An alias for the ``default_factory`` parameter on field specifiers."
msgstr "Alan belirticilerindeki ``default_factory`` parametresinin takma adı."

#: library/typing.rst:2718
#, fuzzy
msgid "``kw_only``"
msgstr "``kw_only``"

#: library/typing.rst:2719
#, fuzzy
msgid ""
"Indicates whether the field should be marked as keyword-only. If ``True``, "
"the field will be keyword-only. If ``False``, it will not be keyword-only. "
"If unspecified, the value of the ``kw_only`` parameter on the object "
"decorated with ``dataclass_transform`` will be used, or if that is "
"unspecified, the value of ``kw_only_default`` on ``dataclass_transform`` "
"will be used."
msgstr ""
"Alanın yalnızca anahtar kelime olarak işaretlenip işaretlenmeyeceğini "
"belirtir. ``dataclass_transform`` ise alan yalnızca anahtar kelime "
"olacaktır. ``dataclass_transform`` ise yalnızca anahtar kelime olmayacaktır."
" Belirtilmemişse ``dataclass_transform`` ile dekore edilmiş nesne üzerindeki"
" ``dataclass_transform`` parametresinin değeri, belirtilmemişse "
"``dataclass_transform`` üzerindeki ``dataclass_transform`` değeri "
"kullanılacaktır."

#: library/typing.rst:2725
#, fuzzy
msgid "``alias``"
msgstr "``alias``"

#: library/typing.rst:2726
#, fuzzy
msgid ""
"Provides an alternative name for the field. This alternative name is used in"
" the synthesized ``__init__`` method."
msgstr ""
"Alan için alternatif bir ad sağlar. Bu alternatif ad, sentezlenen "
"``__init__`` yönteminde kullanılır."

#: library/typing.rst:2729
#, fuzzy
msgid ""
"At runtime, this decorator records its arguments in the "
"``__dataclass_transform__`` attribute on the decorated object. It has no "
"other runtime effect."
msgstr ""
"Çalışma zamanında bu dekoratör, bağımsız değişkenlerini dekore edilen "
"nesnenin ``__dataclass_transform__`` özniteliğine kaydeder. Başka bir "
"çalışma zamanı etkisi yoktur."

#: library/typing.rst:2733
#, fuzzy
msgid "See :pep:`681` for more details."
msgstr "Daha fazla ayrıntı için :pep:`681`'e bakın."

#: library/typing.rst:2739
#, fuzzy
msgid "Decorator for creating overloaded functions and methods."
msgstr "Aşırı yüklenmiş işlevler ve yöntemler oluşturmak için dekoratör."

#: library/typing.rst:2741
#, fuzzy
msgid ""
"The ``@overload`` decorator allows describing functions and methods that "
"support multiple different combinations of argument types. A series of "
"``@overload``-decorated definitions must be followed by exactly one "
"non-``@overload``-decorated definition (for the same function/method)."
msgstr ""
"``@overload`` dekoratörü, bağımsız değişken türlerinin birden çok farklı "
"kombinasyonunu destekleyen işlevlerin ve yöntemlerin tanımlanmasına olanak "
"tanır. Bir dizi ``@overload`` ile dekore edilmiş tanımın ardından tam olarak"
" bir ``@overload`` ile dekore edilmemiş tanım gelmelidir (aynı işlev/yöntem "
"için)."

#: library/typing.rst:2746
#, fuzzy
msgid ""
"``@overload``-decorated definitions are for the benefit of the type checker "
"only, since they will be overwritten by the non-``@overload``-decorated "
"definition. The non-``@overload``-decorated definition, meanwhile, will be "
"used at runtime but should be ignored by a type checker.  At runtime, "
"calling an ``@overload``-decorated function directly will raise "
":exc:`NotImplementedError`."
msgstr ""
"``@overload`` ile dekore edilmiş tanımlar, ``@overload`` ile dekore "
"edilmemiş tanım tarafından bunların üzerine yazılacağından yalnızca tür "
"denetleyicinin yararınadır. Bu arada, ``@overload`` ile dekore edilmemiş "
"tanım çalışma zamanında kullanılacaktır ancak bir tür denetleyici tarafından"
" göz ardı edilmelidir. Çalışma zamanında, ``@overload`` ile dekore edilmiş "
"bir fonksiyonun doğrudan çağrılması :exc:`NotImplementedError`'ü "
"yükseltecektir."

#: library/typing.rst:2754
#, fuzzy
msgid ""
"An example of overload that gives a more precise type than can be expressed "
"using a union or a type variable:"
msgstr ""
"Bir birleşim veya tür değişkeni kullanılarak ifade edilebilecek olandan daha"
" kesin bir tür veren bir aşırı yük örneği:"

#: library/typing.rst:2771
#, fuzzy
msgid ""
"See :pep:`484` for more details and comparison with other typing semantics."
msgstr ""
"Daha fazla ayrıntı ve diğer yazım anlamlarıyla karşılaştırma için "
":pep:`484`'e bakın."

#: library/typing.rst:2773
#, fuzzy
msgid ""
"Overloaded functions can now be introspected at runtime using "
":func:`get_overloads`."
msgstr ""
"Aşırı yüklenen işlevler artık çalışma zamanında :func:`get_overloads` "
"kullanılarak incelenebiliyor."

#: library/typing.rst:2780
#, fuzzy
msgid ""
"Return a sequence of :func:`@overload <overload>`-decorated definitions for "
"*func*."
msgstr ""
"*func* için :func:`@overload <overload>` ile dekore edilmiş tanımların bir "
"dizisini döndürün."

#: library/typing.rst:2783
#, fuzzy
msgid ""
"*func* is the function object for the implementation of the overloaded "
"function. For example, given the definition of ``process`` in the "
"documentation for :func:`@overload <overload>`, ``get_overloads(process)`` "
"will return a sequence of three function objects for the three defined "
"overloads. If called on a function with no overloads, ``get_overloads()`` "
"returns an empty sequence."
msgstr ""
"*func*, aşırı yüklenmiş işlevin uygulanmasına yönelik işlev nesnesidir. "
"Örneğin, :func:`@overload <overload>` belgelerinde ``get_overloads()``'ün "
"tanımı göz önüne alındığında, ``get_overloads()``, tanımlanan üç aşırı "
"yükleme için üç işlev nesnesinden oluşan bir dizi döndürecektir. Aşırı "
"yükleme olmayan bir işlev çağrılırsa ``get_overloads()`` boş bir dizi "
"döndürür."

#: library/typing.rst:2790
#, fuzzy
msgid ""
"``get_overloads()`` can be used for introspecting an overloaded function at "
"runtime."
msgstr ""
"``get_overloads()``, çalışma zamanında aşırı yüklenmiş bir fonksiyonun iç "
"gözlemi için kullanılabilir."

#: library/typing.rst:2798
#, fuzzy
msgid "Clear all registered overloads in the internal registry."
msgstr "Dahili kayıt defterindeki tüm kayıtlı aşırı yüklemeleri temizleyin."

#: library/typing.rst:2800
#, fuzzy
msgid "This can be used to reclaim the memory used by the registry."
msgstr ""
"Bu, kayıt defteri tarafından kullanılan belleği geri kazanmak için "
"kullanılabilir."

#: library/typing.rst:2807
#, fuzzy
msgid "Decorator to indicate final methods and final classes."
msgstr "Son yöntemleri ve son sınıfları belirtmek için dekoratör."

#: library/typing.rst:2809
#, fuzzy
msgid ""
"Decorating a method with ``@final`` indicates to a type checker that the "
"method cannot be overridden in a subclass. Decorating a class with "
"``@final`` indicates that it cannot be subclassed."
msgstr ""
"Bir yöntemin ``@final`` ile donatılması, tür denetleyiciye yöntemin bir alt "
"sınıfta geçersiz kılınamayacağını gösterir. Bir sınıfın ``@final`` ile "
"dekore edilmesi, o sınıfın alt sınıflara ayrılamayacağını gösterir."

#: library/typing.rst:2834
#, fuzzy
msgid ""
"The decorator will now attempt to set a ``__final__`` attribute to ``True`` "
"on the decorated object. Thus, a check like ``if getattr(obj, \"__final__\","
" False)`` can be used at runtime to determine whether an object ``obj`` has "
"been marked as final. If the decorated object does not support setting "
"attributes, the decorator returns the object unchanged without raising an "
"exception."
msgstr ""
"Dekoratör şimdi dekore edilen nesnede ``obj``'e bir ``obj`` niteliği "
"ayarlamaya çalışacaktır. Böylece, ``obj`` gibi bir kontrol çalışma zamanında"
" bir ``obj`` nesnesinin son olarak işaretlenip işaretlenmediğini belirlemek "
"için kullanılabilir. Dekore edilen nesne, ayar niteliklerini "
"desteklemiyorsa, dekoratör, bir istisna oluşturmadan nesneyi değişmeden "
"döndürür."

#: library/typing.rst:2845
#, fuzzy
msgid "Decorator to indicate that annotations are not type hints."
msgstr "Ek açıklamaların tür ipuçları olmadığını belirtmek için dekoratör."

#: library/typing.rst:2847
#, fuzzy
msgid ""
"This works as a class or function :term:`decorator`.  With a class, it "
"applies recursively to all methods and classes defined in that class (but "
"not to methods defined in its superclasses or subclasses). Type checkers "
"will ignore all annotations in a function or class with this decorator."
msgstr ""
"Bu, :term:`decorator` sınıfı veya işlevi olarak çalışır. Bir sınıf söz "
"konusu olduğunda, o sınıfta tanımlanan tüm yöntemlere ve sınıflara "
"yinelemeli olarak uygulanır (ancak üst sınıflarında veya alt sınıflarında "
"tanımlanan yöntemlere uygulanmaz). Tür denetleyicileri, bu dekoratörle bir "
"işlev veya sınıftaki tüm ek açıklamaları göz ardı edecektir."

#: library/typing.rst:2853
#, fuzzy
msgid "``@no_type_check`` mutates the decorated object in place."
msgstr "``@no_type_check``, dekore edilmiş nesneyi yerinde değiştirir."

#: library/typing.rst:2857
#, fuzzy
msgid "Decorator to give another decorator the :func:`no_type_check` effect."
msgstr "Dekoratör başka bir dekoratöre :func:`no_type_check` efekti verecek."

#: library/typing.rst:2859
#, fuzzy
msgid ""
"This wraps the decorator with something that wraps the decorated function in"
" :func:`no_type_check`."
msgstr ""
"Bu, dekoratörü :func:`no_type_check`'de dekore edilmiş işlevi saran bir "
"şeyle sarar."

#: library/typing.rst:2865
#, fuzzy
msgid ""
"Decorator to indicate that a method in a subclass is intended to override a "
"method or attribute in a superclass."
msgstr ""
"Dekoratör, bir alt sınıftaki bir yöntemin, bir üst sınıftaki bir yöntemi "
"veya niteliği geçersiz kılmayı amaçladığını belirtir."

#: library/typing.rst:2868
#, fuzzy
msgid ""
"Type checkers should emit an error if a method decorated with ``@override`` "
"does not, in fact, override anything. This helps prevent bugs that may occur"
" when a base class is changed without an equivalent change to a child class."
msgstr ""
"``@override`` ile süslenmiş bir yöntem aslında herhangi bir şeyi geçersiz "
"kılmıyorsa, tür denetleyicilerinin bir hata vermesi gerekir. Bu, alt sınıfta"
" eşdeğer bir değişiklik yapılmadan temel sınıf değiştirildiğinde ortaya "
"çıkabilecek hataların önlenmesine yardımcı olur."

#: library/typing.rst:2890
#, fuzzy
msgid "There is no runtime checking of this property."
msgstr "Bu özelliğin çalışma zamanı denetimi yoktur."

#: library/typing.rst:2892
#, fuzzy
msgid ""
"The decorator will attempt to set an ``__override__`` attribute to ``True`` "
"on the decorated object. Thus, a check like ``if getattr(obj, "
"\"__override__\", False)`` can be used at runtime to determine whether an "
"object ``obj`` has been marked as an override.  If the decorated object does"
" not support setting attributes, the decorator returns the object unchanged "
"without raising an exception."
msgstr ""
"Dekoratör, dekore edilen nesnede ``obj``'e bir ``obj`` niteliği ayarlamaya "
"çalışacaktır. Böylece, ``obj`` gibi bir kontrol, çalışma zamanında bir "
"``obj`` nesnesinin geçersiz kılma olarak işaretlenip işaretlenmediğini "
"belirlemek için kullanılabilir. Dekore edilen nesne, ayar niteliklerini "
"desteklemiyorsa, dekoratör, bir istisna oluşturmadan nesneyi değişmeden "
"döndürür."

#: library/typing.rst:2899
#, fuzzy
msgid "See :pep:`698` for more details."
msgstr "Daha fazla ayrıntı için :pep:`698`'e bakın."

#: library/typing.rst:2906
#, fuzzy
msgid "Decorator to mark a class or function as unavailable at runtime."
msgstr ""
"Bir sınıfı veya işlevi çalışma zamanında kullanılamaz olarak işaretlemek "
"için dekoratör."

#: library/typing.rst:2908
#, fuzzy
msgid ""
"This decorator is itself not available at runtime. It is mainly intended to "
"mark classes that are defined in type stub files if an implementation "
"returns an instance of a private class::"
msgstr ""
"Bu dekoratörün kendisi çalışma zamanında mevcut değildir. Bir uygulamanın "
"özel bir sınıfın örneğini döndürmesi durumunda, esas olarak tür saplama "
"dosyalarında tanımlanan sınıfları işaretlemek amaçlanır::"

#: library/typing.rst:2919
#, fuzzy
msgid ""
"Note that returning instances of private classes is not recommended. It is "
"usually preferable to make such classes public."
msgstr ""
"Özel sınıfların örneklerinin döndürülmesinin önerilmediğini unutmayın. Bu "
"tür sınıfların herkese açık hale getirilmesi genellikle tercih edilir."

#: library/typing.rst:2923
#, fuzzy
msgid "Introspection helpers"
msgstr "İç gözlem yardımcıları"

#: library/typing.rst:2927
#, fuzzy
msgid ""
"Return a dictionary containing type hints for a function, method, module or "
"class object."
msgstr ""
"Bir işlev, yöntem, modül veya sınıf nesnesi için tür ipuçlarını içeren bir "
"sözlük döndürün."

#: library/typing.rst:2930
#, fuzzy
msgid ""
"This is often the same as ``obj.__annotations__``. In addition, forward "
"references encoded as string literals are handled by evaluating them in "
"``globals`` and ``locals`` namespaces. For a class ``C``, return a "
"dictionary constructed by merging all the ``__annotations__`` along "
"``C.__mro__`` in reverse order."
msgstr ""
"Bu genellikle ``C.__mro__`` ile aynıdır. Ayrıca string değişmezleri olarak "
"kodlanan ileri referanslar, ``C.__mro__`` ve ``C.__mro__`` ad alanlarında "
"değerlendirilerek işlenir. Bir ``C.__mro__`` sınıfı için, tüm "
"``C.__mro__``'ün ``C.__mro__`` boyunca ters sırayla birleştirilmesiyle "
"oluşturulmuş bir sözlük döndürün."

#: library/typing.rst:2936
#, fuzzy
msgid ""
"The function recursively replaces all ``Annotated[T, ...]`` with ``T``, "
"unless ``include_extras`` is set to ``True`` (see :class:`Annotated` for "
"more information). For example:"
msgstr ""
"``True``, ``True`` olarak ayarlanmadığı sürece, işlev yinelemeli olarak tüm "
"``True``'ü ``True`` ile değiştirir (daha fazla bilgi için "
":class:`Annotated`'a bakın). Örneğin:"

#: library/typing.rst:2953
#, fuzzy
msgid ""
":func:`get_type_hints` does not work with imported :ref:`type aliases <type-"
"aliases>` that include forward references. Enabling postponed evaluation of "
"annotations (:pep:`563`) may remove the need for most forward references."
msgstr ""
":func:`get_type_hints`, ileri referanslar içeren içe aktarılan :ref:`type "
"aliases <type-aliases>` ile çalışmaz. Ek açıklamaların (:pep:`563`) "
"ertelenmiş değerlendirmesinin etkinleştirilmesi, çoğu ileri referans "
"ihtiyacını ortadan kaldırabilir."

#: library/typing.rst:2958
#, fuzzy
msgid ""
"Added ``include_extras`` parameter as part of :pep:`593`. See the "
"documentation on :data:`Annotated` for more information."
msgstr ""
":pep:`593`'in bir parçası olarak ``include_extras`` parametresi eklendi. "
"Daha fazla bilgi için :data:`Annotated` belgelerine bakın."

#: library/typing.rst:2962
#, fuzzy
msgid ""
"Previously, ``Optional[t]`` was added for function and method annotations if"
" a default value equal to ``None`` was set. Now the annotation is returned "
"unchanged."
msgstr ""
"Daha önce, ``None``'e eşit bir varsayılan değer ayarlanmışsa işlev ve yöntem"
" açıklamaları için ``None`` ekleniyordu. Artık ek açıklama değişmeden "
"döndürülür."

#: library/typing.rst:2969
#, fuzzy
msgid ""
"Get the unsubscripted version of a type: for a typing object of the form "
"``X[Y, Z, ...]`` return ``X``."
msgstr ""
"Bir türün abone olunmamış sürümünü edinin: ``X`` formundaki bir yazma "
"nesnesi için ``X`` değerini döndürün."

#: library/typing.rst:2972
#, fuzzy
msgid ""
"If ``X`` is a typing-module alias for a builtin or :mod:`collections` class,"
" it will be normalized to the original class. If ``X`` is an instance of "
":class:`ParamSpecArgs` or :class:`ParamSpecKwargs`, return the underlying "
":class:`ParamSpec`. Return ``None`` for unsupported objects."
msgstr ""
"``None``, yerleşik bir sınıf veya :mod:`collections` sınıfı için bir yazma "
"modülü takma adıysa orijinal sınıfa normalleştirilecektir. ``None``, "
":class:`ParamSpec` veya :class:`ParamSpec`'un bir örneğiyse temeldeki "
":class:`ParamSpec`'u döndürün. Desteklenmeyen nesneler için ``None``'ü "
"döndürün."

#: library/typing.rst:3001
#, fuzzy
msgid "Examples:"
msgstr "Örnekler:"

#: library/typing.rst:2993
#, fuzzy
msgid ""
"Get type arguments with all substitutions performed: for a typing object of "
"the form ``X[Y, Z, ...]`` return ``(Y, Z, ...)``."
msgstr ""
"Gerçekleştirilen tüm değişikliklerle birlikte tür bağımsız değişkenlerini "
"alın: ``(Y, Z, ...)`` biçimindeki bir yazma nesnesi için ``(Y, Z, ...)`` "
"değerini döndürün."

#: library/typing.rst:2996
#, fuzzy
msgid ""
"If ``X`` is a union or :class:`Literal` contained in another generic type, "
"the order of ``(Y, Z, ...)`` may be different from the order of the original"
" arguments ``[Y, Z, ...]`` due to type caching. Return ``()`` for "
"unsupported objects."
msgstr ""
"``()`` bir birleşimse veya başka bir genel türde yer alan :class:`Literal` "
"ise, tür önbelleğe alma nedeniyle ``()``'ün sırası orijinal ``()`` bağımsız "
"değişkenlerinin sırasından farklı olabilir. Desteklenmeyen nesneler için "
"``()``'ü döndürün."

#: library/typing.rst:3013
#, fuzzy
msgid "Check if a type is a :class:`TypedDict`."
msgstr "Türün :class:`TypedDict` olup olmadığını kontrol edin."

#: library/typing.rst:3034
#, fuzzy
msgid ""
"Class used for internal typing representation of string forward references."
msgstr "Dize ileri başvurularının dahili yazım temsili için kullanılan sınıf."

#: library/typing.rst:3036
#, fuzzy
msgid ""
"For example, ``List[\"SomeClass\"]`` is implicitly transformed into "
"``List[ForwardRef(\"SomeClass\")]``.  ``ForwardRef`` should not be "
"instantiated by a user, but may be used by introspection tools."
msgstr ""
"Örneğin, ``ForwardRef`` örtülü olarak ``ForwardRef``'e dönüştürülür. "
"``ForwardRef`` bir kullanıcı tarafından oluşturulmamalıdır ancak iç gözlem "
"araçları tarafından kullanılabilir."

#: library/typing.rst:3041
#, fuzzy
msgid ""
":pep:`585` generic types such as ``list[\"SomeClass\"]`` will not be "
"implicitly transformed into ``list[ForwardRef(\"SomeClass\")]`` and thus "
"will not automatically resolve to ``list[SomeClass]``."
msgstr ""
"``list[SomeClass]`` gibi :pep:`585` genel türleri, dolaylı olarak "
"``list[SomeClass]``'e dönüştürülmeyecek ve dolayısıyla otomatik olarak "
"``list[SomeClass]``'e çözümlenmeyecektir."

#: library/typing.rst:3048
#, fuzzy
msgid "Constant"
msgstr "Devamlı"

#: library/typing.rst:3052
#, fuzzy
msgid ""
"A special constant that is assumed to be ``True`` by 3rd party static type "
"checkers. It is ``False`` at runtime."
msgstr ""
"3. taraf statik tip denetleyiciler tarafından ``False`` olduğu varsayılan "
"özel bir sabit. Çalışma zamanında ``False``'tür."

#: library/typing.rst:3063
#, fuzzy
msgid ""
"The first type annotation must be enclosed in quotes, making it a \"forward "
"reference\", to hide the ``expensive_mod`` reference from the interpreter "
"runtime.  Type annotations for local variables are not evaluated, so the "
"second annotation does not need to be enclosed in quotes."
msgstr ""
"``expensive_mod`` referansını yorumlayıcı çalışma zamanından gizlemek için "
"ilk tür açıklamasının tırnak içine alınması gerekir, bu da onu bir \"ileri "
"referans\" haline getirir. Yerel değişkenlere ilişkin tür açıklamaları "
"değerlendirilmez, bu nedenle ikinci açıklamanın tırnak içine alınmasına "
"gerek yoktur."

#: library/typing.rst:3070
#, fuzzy
msgid ""
"If ``from __future__ import annotations`` is used, annotations are not "
"evaluated at function definition time. Instead, they are stored as strings "
"in ``__annotations__``. This makes it unnecessary to use quotes around the "
"annotation (see :pep:`563`)."
msgstr ""
"``__annotations__`` kullanılıyorsa ek açıklamalar işlev tanımı zamanında "
"değerlendirilmez. Bunun yerine ``__annotations__``'te dizeler olarak "
"depolanırlar. Bu, ek açıklamanın etrafında tırnak işareti kullanılmasını "
"gereksiz kılar (bkz. :pep:`563`)."

#: library/typing.rst:3082
#, fuzzy
msgid "Deprecated aliases"
msgstr "Kullanımdan kaldırılan takma adlar"

#: library/typing.rst:3084
#, fuzzy
msgid ""
"This module defines several deprecated aliases to pre-existing standard "
"library classes. These were originally included in the typing module in "
"order to support parameterizing these generic classes using ``[]``. However,"
" the aliases became redundant in Python 3.9 when the corresponding pre-"
"existing classes were enhanced to support ``[]`` (see :pep:`585`)."
msgstr ""
"Bu modül, önceden var olan standart kütüphane sınıflarına yönelik, "
"kullanımdan kaldırılmış çeşitli takma adları tanımlar. Bunlar, ``[]`` "
"kullanılarak bu genel sınıfların parametrelendirilmesini desteklemek için "
"orijinal olarak yazma modülüne dahil edilmiştir. Ancak Python 3.9'da ilgili "
"önceden var olan sınıflar ``[]``'ü destekleyecek şekilde geliştirildiğinde "
"takma adlar gereksiz hale geldi (bkz. :pep:`585`)."

#: library/typing.rst:3091
#, fuzzy
msgid ""
"The redundant types are deprecated as of Python 3.9. However, while the "
"aliases may be removed at some point, removal of these aliases is not "
"currently planned. As such, no deprecation warnings are currently issued by "
"the interpreter for these aliases."
msgstr ""
"Yedekli türler Python 3.9'dan itibaren kullanımdan kaldırılmıştır. Ancak "
"takma adların bir noktada kaldırılması mümkün olsa da bu takma adların "
"kaldırılması şu anda planlanmamıştır. Bu nedenle, tercüman tarafından bu "
"takma adlar için şu anda herhangi bir kullanımdan kaldırma uyarısı "
"yayınlanmamaktadır."

#: library/typing.rst:3096
#, fuzzy
msgid ""
"If at some point it is decided to remove these deprecated aliases, a "
"deprecation warning will be issued by the interpreter for at least two "
"releases prior to removal. The aliases are guaranteed to remain in the "
"typing module without deprecation warnings until at least Python 3.14."
msgstr ""
"Bir noktada bu kullanımdan kaldırılmış takma adların kaldırılmasına karar "
"verilirse, yorumlayıcı tarafından kaldırılmadan önce en az iki sürüm için "
"bir kullanımdan kaldırma uyarısı verilecektir. Takma adların, en azından "
"Python 3.14'e kadar kullanımdan kaldırma uyarıları olmadan yazma modülünde "
"kalması garanti edilir."

#: library/typing.rst:3101
#, fuzzy
msgid ""
"Type checkers are encouraged to flag uses of the deprecated types if the "
"program they are checking targets a minimum Python version of 3.9 or newer."
msgstr ""
"Tip denetleyicilerinin, kontrol ettikleri programın minimum Python 3.9 veya "
"daha yeni bir sürümünü hedeflemesi durumunda, kullanımdan kaldırılan "
"türlerin kullanımlarını işaretlemeleri teşvik edilir."

#: library/typing.rst:3107
#, fuzzy
msgid "Aliases to built-in types"
msgstr "Yerleşik türlerin takma adları"

#: library/typing.rst:3111
#, fuzzy
msgid "Deprecated alias to :class:`dict`."
msgstr ":class:`dict` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3113
#, fuzzy
msgid ""
"Note that to annotate arguments, it is preferred to use an abstract "
"collection type such as :class:`Mapping` rather than to use :class:`dict` or"
" :class:`!typing.Dict`."
msgstr ""
"Bağımsız değişkenlere açıklama eklemek için :class:`!typing.Dict` veya "
":class:`!typing.Dict` yerine :class:`!typing.Dict` gibi soyut bir koleksiyon"
" türünün kullanılmasının tercih edildiğini unutmayın."

#: library/typing.rst:3359
#, fuzzy
msgid "This type can be used as follows::"
msgstr "Bu tür şu şekilde kullanılabilir::"

#: library/typing.rst:3122
#, fuzzy
msgid ""
":class:`builtins.dict <dict>` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.dict <dict>` artık abone olmayı (``[]``) destekliyor. Bkz. "
":pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3128
#, fuzzy
msgid "Deprecated alias to :class:`list`."
msgstr ":class:`list` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3130
#, fuzzy
msgid ""
"Note that to annotate arguments, it is preferred to use an abstract "
"collection type such as :class:`Sequence` or :class:`Iterable` rather than "
"to use :class:`list` or :class:`!typing.List`."
msgstr ""
"Bağımsız değişkenlere açıklama eklemek için :class:`!typing.List` veya "
":class:`!typing.List` yerine :class:`!typing.List` veya "
":class:`!typing.List` gibi soyut bir koleksiyon türünün kullanılmasının "
"tercih edildiğini unutmayın."

#: library/typing.rst:3134
#, fuzzy
msgid "This type may be used as follows::"
msgstr "Bu tür şu şekilde kullanılabilir::"

#: library/typing.rst:3142
#, fuzzy
msgid ""
":class:`builtins.list <list>` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.list <list>` artık abone olmayı (``[]``) destekliyor. Bkz. "
":pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3148
#, fuzzy
msgid "Deprecated alias to :class:`builtins.set <set>`."
msgstr ":class:`builtins.set <set>` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3150
#, fuzzy
msgid ""
"Note that to annotate arguments, it is preferred to use an abstract "
"collection type such as :class:`AbstractSet` rather than to use :class:`set`"
" or :class:`!typing.Set`."
msgstr ""
"Bağımsız değişkenlere açıklama eklemek için :class:`!typing.Set` veya "
":class:`!typing.Set` yerine :class:`!typing.Set` gibi soyut bir koleksiyon "
"türünün kullanılmasının tercih edildiğini unutmayın."

#: library/typing.rst:3154
#, fuzzy
msgid ""
":class:`builtins.set <set>` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.set <set>` artık abone olmayı (``[]``) destekliyor. Bkz. "
":pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3160
#, fuzzy
msgid "Deprecated alias to :class:`builtins.frozenset <frozenset>`."
msgstr ""
":class:`builtins.frozenset <frozenset>` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3162
#, fuzzy
msgid ""
":class:`builtins.frozenset <frozenset>` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.frozenset <frozenset>` artık abone olmayı (``[]``) "
"destekliyor. Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3169
#, fuzzy
msgid "Deprecated alias for :class:`tuple`."
msgstr ":class:`tuple` için kullanımdan kaldırılan takma ad."

#: library/typing.rst:3171
#, fuzzy
msgid ""
":class:`tuple` and ``Tuple`` are special-cased in the type system; see "
":ref:`annotating-tuples` for more details."
msgstr ""
":class:`tuple` ve ``Tuple``, tip sisteminde özel kasalıdır; daha fazla "
"ayrıntı için :ref:`annotating-tuples`'a bakın."

#: library/typing.rst:3174
#, fuzzy
msgid ""
":class:`builtins.tuple <tuple>` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.tuple <tuple>` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3180
#, fuzzy
msgid "Deprecated alias to :class:`type`."
msgstr ":class:`type` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3182
#, fuzzy
msgid ""
"See :ref:`type-of-class-objects` for details on using :class:`type` or "
"``typing.Type`` in type annotations."
msgstr ""
"Tür açıklamalarında :class:`type` veya ``typing.Type`` kullanımına ilişkin "
"ayrıntılar için :ref:`type-of-class-objects`'a bakın."

#: library/typing.rst:3187
#, fuzzy
msgid ""
":class:`builtins.type <type>` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`builtins.type <type>` artık abone olmayı (``[]``) destekliyor. Bkz. "
":pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3194
#, fuzzy
msgid "Aliases to types in :mod:`collections`"
msgstr ":mod:`collections`'deki türlere yönelik takma adlar"

#: library/typing.rst:3198
#, fuzzy
msgid "Deprecated alias to :class:`collections.defaultdict`."
msgstr ":class:`collections.defaultdict` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3202
#, fuzzy
msgid ""
":class:`collections.defaultdict` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.defaultdict` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3208
#, fuzzy
msgid "Deprecated alias to :class:`collections.OrderedDict`."
msgstr ":class:`collections.OrderedDict` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3212
#, fuzzy
msgid ""
":class:`collections.OrderedDict` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.OrderedDict` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3218
#, fuzzy
msgid "Deprecated alias to :class:`collections.ChainMap`."
msgstr ":class:`collections.ChainMap` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3223
#, fuzzy
msgid ""
":class:`collections.ChainMap` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.ChainMap` artık abone olmayı (``[]``) destekliyor. Bkz. "
":pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3229
#, fuzzy
msgid "Deprecated alias to :class:`collections.Counter`."
msgstr ":class:`collections.Counter` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3234
#, fuzzy
msgid ""
":class:`collections.Counter` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.Counter` artık abone olmayı (``[]``) destekliyor. Bkz. "
":pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3240
#, fuzzy
msgid "Deprecated alias to :class:`collections.deque`."
msgstr ":class:`collections.deque` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3245
#, fuzzy
msgid ""
":class:`collections.deque` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.deque` artık abone olmayı (``[]``) destekliyor. Bkz. "
":pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3252
#, fuzzy
msgid "Aliases to other concrete types"
msgstr "Diğer beton türlerine takma adlar"

#: library/typing.rst:3257
#, fuzzy
msgid ""
"The ``typing.io`` namespace is deprecated and will be removed. These types "
"should be directly imported from ``typing`` instead."
msgstr ""
"``typing`` ad alanı kullanımdan kaldırıldı ve kaldırılacak. Bu türler bunun "
"yerine doğrudan ``typing``'ten içe aktarılmalıdır."

#: library/typing.rst:3261
#, fuzzy
msgid ""
"Deprecated aliases corresponding to the return types from :func:`re.compile`"
" and :func:`re.match`."
msgstr ""
":func:`re.match` ve :func:`re.match`'den gelen dönüş türlerine karşılık "
"gelen, kullanımdan kaldırılan takma adlar."

#: library/typing.rst:3264
#, fuzzy
msgid ""
"These types (and the corresponding functions) are generic over "
":data:`AnyStr`. ``Pattern`` can be specialised as ``Pattern[str]`` or "
"``Pattern[bytes]``; ``Match`` can be specialised as ``Match[str]`` or "
"``Match[bytes]``."
msgstr ""
"Bu türler (ve karşılık gelen işlevler) :data:`AnyStr` üzerinde geneldir. "
"``Match[bytes]``, ``Match[bytes]`` veya ``Match[bytes]`` olarak "
"özelleştirilebilir; ``Match[bytes]``, ``Match[bytes]`` veya ``Match[bytes]``"
" olarak özelleştirilebilir."

#: library/typing.rst:3272
#, fuzzy
msgid ""
"The ``typing.re`` namespace is deprecated and will be removed. These types "
"should be directly imported from ``typing`` instead."
msgstr ""
"``typing`` ad alanı kullanımdan kaldırıldı ve kaldırılacak. Bu türler bunun "
"yerine doğrudan ``typing``'ten içe aktarılmalıdır."

#: library/typing.rst:3273
#, fuzzy
msgid ""
"Classes ``Pattern`` and ``Match`` from :mod:`re` now support ``[]``. See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":mod:`re`'deki ``[]`` ve ``[]`` sınıfları artık ``[]``'ü desteklemektedir. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3279
#, fuzzy
msgid "Deprecated alias for :class:`str`."
msgstr ":class:`str` için kullanımdan kaldırılan takma ad."

#: library/typing.rst:3281
#, fuzzy
msgid ""
"``Text`` is provided to supply a forward compatible path for Python 2 code: "
"in Python 2, ``Text`` is an alias for ``unicode``."
msgstr ""
"``unicode``, Python 2 kodu için ileri uyumlu bir yol sağlamak üzere "
"sağlanmıştır: Python 2'de ``unicode``, ``unicode``'ün takma adıdır."

#: library/typing.rst:3285
#, fuzzy
msgid ""
"Use ``Text`` to indicate that a value must contain a unicode string in a "
"manner that is compatible with both Python 2 and Python 3::"
msgstr ""
"Bir değerin hem Python 2 hem de Python 3 ile uyumlu olacak şekilde bir "
"unicode dize içermesi gerektiğini belirtmek için ``Text``'ü kullanın::"

#: library/typing.rst:3293
#, fuzzy
msgid ""
"Python 2 is no longer supported, and most type checkers also no longer "
"support type checking Python 2 code. Removal of the alias is not currently "
"planned, but users are encouraged to use :class:`str` instead of ``Text``."
msgstr ""
"Python 2 artık desteklenmiyor ve çoğu tür denetleyicisi de artık Python 2 "
"kodunun tür denetimini desteklemiyor. Takma adın kaldırılması şu anda "
"planlanmamıştır ancak kullanıcıların ``Text`` yerine :class:`str` "
"kullanmaları teşvik edilmektedir."

#: library/typing.rst:3303
#, fuzzy
msgid "Aliases to container ABCs in :mod:`collections.abc`"
msgstr ":mod:`collections.abc`'deki kapsayıcı ABC'lerin takma adları"

#: library/typing.rst:3307
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Set`."
msgstr ":class:`collections.abc.Set` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3309
#, fuzzy
msgid ""
":class:`collections.abc.Set` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Set` artık abone olmayı (``[]``) destekliyor. Bkz. "
":pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3315
#, fuzzy
msgid ""
"This type represents the types :class:`bytes`, :class:`bytearray`, and "
":class:`memoryview` of byte sequences."
msgstr ""
"Bu tür, bayt dizilerinin :class:`memoryview`, :class:`memoryview` ve "
":class:`memoryview` türlerini temsil eder."

#: library/typing.rst:3319
#, fuzzy
msgid ""
"Prefer :class:`collections.abc.Buffer`, or a union like ``bytes | bytearray "
"| memoryview``."
msgstr ""
":class:`collections.abc.Buffer`'u veya ``bytes | bytearray | memoryview`` "
"gibi bir birleşimi tercih edin."

#: library/typing.rst:3323
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Collection`."
msgstr ":class:`collections.abc.Collection` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3327
#, fuzzy
msgid ""
":class:`collections.abc.Collection` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Collection` artık abone olmayı (``[]``) destekliyor."
" Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3333
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Container`."
msgstr ":class:`collections.abc.Container` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3335
#, fuzzy
msgid ""
":class:`collections.abc.Container` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Container` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3341
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.ItemsView`."
msgstr ":class:`collections.abc.ItemsView` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3343
#, fuzzy
msgid ""
":class:`collections.abc.ItemsView` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.ItemsView` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3349
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.KeysView`."
msgstr ":class:`collections.abc.KeysView` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3351
#, fuzzy
msgid ""
":class:`collections.abc.KeysView` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.KeysView` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3357
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Mapping`."
msgstr ":class:`collections.abc.Mapping` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3364
#, fuzzy
msgid ""
":class:`collections.abc.Mapping` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Mapping` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3370
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.MappingView`."
msgstr ""
":class:`collections.abc.MappingView` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3372
#, fuzzy
msgid ""
":class:`collections.abc.MappingView` now supports subscripting (``[]``). See"
" :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MappingView` artık abone olmayı (``[]``) "
"destekliyor. Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3378
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.MutableMapping`."
msgstr ""
":class:`collections.abc.MutableMapping` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3380
#, fuzzy
msgid ""
":class:`collections.abc.MutableMapping` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableMapping` artık abone olmayı (``[]``) "
"destekliyor. Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3387
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.MutableSequence`."
msgstr ""
":class:`collections.abc.MutableSequence` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3389
#, fuzzy
msgid ""
":class:`collections.abc.MutableSequence` now supports subscripting (``[]``)."
" See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableSequence` artık abone olmayı (``[]``) "
"destekliyor. Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3396
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.MutableSet`."
msgstr ":class:`collections.abc.MutableSet` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3398
#, fuzzy
msgid ""
":class:`collections.abc.MutableSet` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.MutableSet` artık abone olmayı (``[]``) destekliyor."
" Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3404
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Sequence`."
msgstr ":class:`collections.abc.Sequence` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3406
#, fuzzy
msgid ""
":class:`collections.abc.Sequence` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Sequence` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3412
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.ValuesView`."
msgstr ":class:`collections.abc.ValuesView` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3414
#, fuzzy
msgid ""
":class:`collections.abc.ValuesView` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.ValuesView` artık abone olmayı (``[]``) destekliyor."
" Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3421
#, fuzzy
msgid "Aliases to asynchronous ABCs in :mod:`collections.abc`"
msgstr ":mod:`collections.abc`'deki eşzamansız ABC'lerin takma adları"

#: library/typing.rst:3425
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Coroutine`."
msgstr ":class:`collections.abc.Coroutine` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3427
#, fuzzy
msgid ""
"The variance and order of type variables correspond to those of "
":class:`Generator`, for example::"
msgstr ""
"Tür değişkenlerinin varyansı ve sırası :class:`Generator`'unkilere karşılık "
"gelir, örneğin::"

#: library/typing.rst:3438
#, fuzzy
msgid ""
":class:`collections.abc.Coroutine` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Coroutine` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3444
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.AsyncGenerator`."
msgstr ""
":class:`collections.abc.AsyncGenerator` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3446
#, fuzzy
msgid ""
"An async generator can be annotated by the generic type "
"``AsyncGenerator[YieldType, SendType]``. For example::"
msgstr ""
"Bir eşzamansız oluşturucuya ``AsyncGenerator[YieldType, SendType]`` genel "
"türüyle açıklama eklenebilir. Örneğin::"

#: library/typing.rst:3455
#, fuzzy
msgid ""
"Unlike normal generators, async generators cannot return a value, so there "
"is no ``ReturnType`` type parameter. As with :class:`Generator`, the "
"``SendType`` behaves contravariantly."
msgstr ""
"Normal oluşturucuların aksine, eşzamansız oluşturucular bir değer "
"döndüremez, dolayısıyla ``SendType`` tipi parametre yoktur. "
":class:`Generator`'da olduğu gibi, ``SendType`` de ters değişkenlik "
"gösterir."

#: library/typing.rst:3459
#, fuzzy
msgid ""
"If your generator will only yield values, set the ``SendType`` to ``None``::"
msgstr ""
"Jeneratörünüz yalnızca değer üretecekse ``None``'ü ``None`` olarak "
"ayarlayın::"

#: library/typing.rst:3467
#, fuzzy
msgid ""
"Alternatively, annotate your generator as having a return type of either "
"``AsyncIterable[YieldType]`` or ``AsyncIterator[YieldType]``::"
msgstr ""
"Alternatif olarak, oluşturucunuza ``AsyncIterator[YieldType]`` veya "
"``AsyncIterator[YieldType]`` dönüş türüne sahip olacak şekilde açıklama "
"ekleyin::"

#: library/typing.rst:3477
#, fuzzy
msgid ""
":class:`collections.abc.AsyncGenerator` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsyncGenerator` artık abone olmayı (``[]``) "
"destekliyor. Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3484
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.AsyncIterable`."
msgstr ""
":class:`collections.abc.AsyncIterable` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3488
#, fuzzy
msgid ""
":class:`collections.abc.AsyncIterable` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsyncIterable` artık abone olmayı (``[]``) "
"destekliyor. Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3494
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.AsyncIterator`."
msgstr ""
":class:`collections.abc.AsyncIterator` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3498
#, fuzzy
msgid ""
":class:`collections.abc.AsyncIterator` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.AsyncIterator` artık abone olmayı (``[]``) "
"destekliyor. Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3504
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Awaitable`."
msgstr ":class:`collections.abc.Awaitable` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3508
#, fuzzy
msgid ""
":class:`collections.abc.Awaitable` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Awaitable` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3515
#, fuzzy
msgid "Aliases to other ABCs in :mod:`collections.abc`"
msgstr ":mod:`collections.abc`'deki diğer ABC'lerin takma adları"

#: library/typing.rst:3519
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Iterable`."
msgstr ":class:`collections.abc.Iterable` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3521
#, fuzzy
msgid ""
":class:`collections.abc.Iterable` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Iterable` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3527
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Iterator`."
msgstr ":class:`collections.abc.Iterator` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3529
#, fuzzy
msgid ""
":class:`collections.abc.Iterator` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Iterator` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3535
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Callable`."
msgstr ":class:`collections.abc.Callable` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3537
#, fuzzy
msgid ""
"See :ref:`annotating-callables` for details on how to use "
":class:`collections.abc.Callable` and ``typing.Callable`` in type "
"annotations."
msgstr ""
"Tür açıklamalarında :class:`collections.abc.Callable` ve "
"``typing.Callable``'ün nasıl kullanılacağına ilişkin ayrıntılar için "
":ref:`annotating-callables`'a bakın."

#: library/typing.rst:3540
#, fuzzy
msgid ""
":class:`collections.abc.Callable` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Callable` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3550
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Generator`."
msgstr ":class:`collections.abc.Generator` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3552
#, fuzzy
msgid ""
"A generator can be annotated by the generic type ``Generator[YieldType, "
"SendType, ReturnType]``. For example::"
msgstr ""
"Bir oluşturucuya ``Generator[YieldType, SendType, ReturnType]`` genel "
"türüyle açıklama eklenebilir. Örneğin::"

#: library/typing.rst:3561
#, fuzzy
msgid ""
"Note that unlike many other generics in the typing module, the ``SendType`` "
"of :class:`Generator` behaves contravariantly, not covariantly or "
"invariantly."
msgstr ""
"Yazma modülündeki diğer birçok jenerikten farklı olarak, "
":class:`Generator`'un ``SendType``'ünün eşdeğişken veya değişmez olarak "
"değil, ters-değişken davrandığını unutmayın."

#: library/typing.rst:3565
#, fuzzy
msgid ""
"If your generator will only yield values, set the ``SendType`` and "
"``ReturnType`` to ``None``::"
msgstr ""
"Jeneratörünüz yalnızca değer verecekse ``None`` ve ``None``'ü ``None`` "
"olarak ayarlayın::"

#: library/typing.rst:3573
#, fuzzy
msgid ""
"Alternatively, annotate your generator as having a return type of either "
"``Iterable[YieldType]`` or ``Iterator[YieldType]``::"
msgstr ""
"Alternatif olarak, oluşturucunuza ``Iterator[YieldType]`` veya "
"``Iterator[YieldType]`` dönüş türüne sahip olacak şekilde açıklama ekleyin::"

#: library/typing.rst:3581
#, fuzzy
msgid ""
":class:`collections.abc.Generator` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Generator` artık abone olmayı (``[]``) destekliyor. "
"Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3587
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Hashable`."
msgstr ":class:`collections.abc.Hashable` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3589
#, fuzzy
msgid "Use :class:`collections.abc.Hashable` directly instead."
msgstr "Bunun yerine doğrudan :class:`collections.abc.Hashable`'u kullanın."

#: library/typing.rst:3594
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Reversible`."
msgstr ":class:`collections.abc.Reversible` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3596
#, fuzzy
msgid ""
":class:`collections.abc.Reversible` now supports subscripting (``[]``). See "
":pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`collections.abc.Reversible` artık abone olmayı (``[]``) destekliyor."
" Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3602
#, fuzzy
msgid "Deprecated alias to :class:`collections.abc.Sized`."
msgstr ":class:`collections.abc.Sized` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3604
#, fuzzy
msgid "Use :class:`collections.abc.Sized` directly instead."
msgstr "Bunun yerine doğrudan :class:`collections.abc.Sized`'u kullanın."

#: library/typing.rst:3610
#, fuzzy
msgid "Aliases to :mod:`contextlib` ABCs"
msgstr ":mod:`contextlib` ABC'lerin takma adları"

#: library/typing.rst:3614
#, fuzzy
msgid "Deprecated alias to :class:`contextlib.AbstractContextManager`."
msgstr ""
":class:`contextlib.AbstractContextManager` takma adı kullanımdan kaldırıldı."

#: library/typing.rst:3619
#, fuzzy
msgid ""
":class:`contextlib.AbstractContextManager` now supports subscripting "
"(``[]``). See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`contextlib.AbstractContextManager` artık abone olmayı (``[]``) "
"destekliyor. Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3626
#, fuzzy
msgid "Deprecated alias to :class:`contextlib.AbstractAsyncContextManager`."
msgstr ""
":class:`contextlib.AbstractAsyncContextManager` takma adı kullanımdan "
"kaldırıldı."

#: library/typing.rst:3631
#, fuzzy
msgid ""
":class:`contextlib.AbstractAsyncContextManager` now supports subscripting "
"(``[]``). See :pep:`585` and :ref:`types-genericalias`."
msgstr ""
":class:`contextlib.AbstractAsyncContextManager` artık abone olmayı (``[]``) "
"destekliyor. Bkz. :pep:`585` ve :ref:`types-genericalias`."

#: library/typing.rst:3637
#, fuzzy
msgid "Deprecation Timeline of Major Features"
msgstr "Başlıca Özelliklerin Kullanımdan Kaldırılması Zaman Çizelgesi"

#: library/typing.rst:3639
#, fuzzy
msgid ""
"Certain features in ``typing`` are deprecated and may be removed in a future"
" version of Python. The following table summarizes major deprecations for "
"your convenience. This is subject to change, and not all deprecations are "
"listed."
msgstr ""
"``typing``'teki bazı özellikler kullanımdan kaldırılmıştır ve Python'un "
"gelecekteki bir sürümünde kaldırılabilir. Aşağıdaki tabloda size kolaylık "
"sağlamak amacıyla önemli kullanımdan kaldırılanlar özetlenmektedir. Bu "
"değişiklik gösterebilir ve kullanımdan kaldırılanların tümü listelenmez."

#: library/typing.rst:3646
#, fuzzy
msgid "Feature"
msgstr "Özellik"

#: library/typing.rst:3647
#, fuzzy
msgid "Deprecated in"
msgstr "Kullanımdan kaldırıldı"

#: library/typing.rst:3648
#, fuzzy
msgid "Projected removal"
msgstr "Öngörülen kaldırma"

#: library/typing.rst:3649
#, fuzzy
msgid "PEP/issue"
msgstr "KEP/sayı"

#: library/typing.rst:3650
#, fuzzy
msgid "``typing.io`` and ``typing.re`` submodules"
msgstr "``typing.re`` ve ``typing.re`` alt modülleri"

#: library/typing.rst:3651
#, fuzzy
msgid "3.8"
msgstr "3.8"

#: library/typing.rst:3652
#, fuzzy
msgid "3.13"
msgstr "3.13"

#: library/typing.rst:3653
#, fuzzy
msgid ":issue:`38291`"
msgstr ":issue:`38291`"

#: library/typing.rst:3654
#, fuzzy
msgid "``typing`` versions of standard collections"
msgstr "Standart koleksiyonların ``typing`` sürümleri"

#: library/typing.rst:3659
#, fuzzy
msgid "3.9"
msgstr "3.9"

#: library/typing.rst:3656
#, fuzzy
msgid "Undecided (see :ref:`deprecated-aliases` for more information)"
msgstr "Kararsızım (daha fazla bilgi için :ref:`deprecated-aliases`'a bakın)"

#: library/typing.rst:3657
#, fuzzy
msgid ":pep:`585`"
msgstr ":pep:`585`"

#: library/typing.rst:3658
#, fuzzy
msgid ":class:`typing.ByteString`"
msgstr ":class:`typing.ByteString`"

#: library/typing.rst:3660
#, fuzzy
msgid "3.14"
msgstr "3.14"

#: library/typing.rst:3661
#, fuzzy
msgid ":gh:`91896`"
msgstr ":gh:'91896'"

#: library/typing.rst:3662
#, fuzzy
msgid ":data:`typing.Text`"
msgstr ":data:`typing.Text`"

#: library/typing.rst:3663
#, fuzzy
msgid "3.11"
msgstr "3.11"

#: library/typing.rst:3668 library/typing.rst:3672
#, fuzzy
msgid "Undecided"
msgstr "Kararsız"

#: library/typing.rst:3665
#, fuzzy
msgid ":gh:`92332`"
msgstr ":gh:'92332'"

#: library/typing.rst:3666
#, fuzzy
msgid ":class:`typing.Hashable` and :class:`typing.Sized`"
msgstr ":class:`typing.Sized` ve :class:`typing.Sized`"

#: library/typing.rst:3671
#, fuzzy
msgid "3.12"
msgstr "3.12"

#: library/typing.rst:3669
#, fuzzy
msgid ":gh:`94309`"
msgstr ":gh:'94309'"

#: library/typing.rst:3670
#, fuzzy
msgid ":data:`typing.TypeAlias`"
msgstr ":data:`typing.TypeAlias`"

#: library/typing.rst:3673
#, fuzzy
msgid ":pep:`695`"
msgstr ":pep:`695`"
