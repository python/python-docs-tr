# Python Documentation Turkish Translation
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-17 01:28+0300\n"
"PO-Revision-Date: 2022-12-29 00:15+0300\n"
"Last-Translator: \n"
"Language-Team: TURKISH <python.docs.tr@gmail.com>\n"
"Language: tr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.2.2\n"

#: tutorial/modules.rst:5
msgid "Modules"
msgstr "Modüller"

#: tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the definitions "
"you have made (functions and variables) are lost. Therefore, if you want to "
"write a somewhat longer program, you are better off using a text editor to "
"prepare the input for the interpreter and running it with that file as input "
"instead.  This is known as creating a *script*.  As your program gets "
"longer, you may want to split it into several files for easier maintenance.  "
"You may also want to use a handy function that you've written in several "
"programs without copying its definition into each program."
msgstr ""
"Python yorumlayıcısından çıkıp tekrar girerseniz, yaptığınız tanımlar "
"(fonksiyonlar  ve değişkenler) kaybolur. Bu nedenle, daha uzun bir program "
"yazmak istiyorsanız, girdiyi yorumlayıcıya hazırlarken bir metin "
"düzenleyicisi kullanmak ve o dosyayla girdi olarak çalıştırmak daha iyidir.  "
"Bu bir *script* oluşturma olarak bilinir.  Programınız uzadıkça, daha kolay "
"bakım için birkaç dosyaya bölmek isteyebilirsiniz.  Ayrıca, tanımını her "
"programa kopyalamadan, birkaç programda yazdığınız kullanışlı bir fonksiyonu "
"kullanmak isteyebilirsiniz."

#: tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use them "
"in a script or in an interactive instance of the interpreter. Such a file is "
"called a *module*; definitions from a module can be *imported* into other "
"modules or into the *main* module (the collection of variables that you have "
"access to in a script executed at the top level and in calculator mode)."
msgstr ""
"Bunu desteklemek için Python, tanımları bir dosyaya koymanın ve bunları bir "
"komut dosyasında veya yorumlayıcının etkileşimli bir örneğinde kullanmanın "
"bir yolunu sağlar. Böyle bir dosyaya *module* denir; bir modülden alınan "
"tanımlar diğer modüllere veya *main* modülüne (en üst düzeyde ve hesap "
"makinesi modunda yürütülen bir komut dosyasında erişiminiz olan "
"değişkenlerin derlenmesi) aktarılabilir."

#: tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The file "
"name is the module name with the suffix :file:`.py` appended.  Within a "
"module, the module's name (as a string) is available as the value of the "
"global variable ``__name__``.  For instance, use your favorite text editor "
"to create a file called :file:`fibo.py` in the current directory with the "
"following contents::"
msgstr ""
"Modül, Python tanımlarını ve ifadelerini içeren bir dosyadır.  Dosya adı, :"
"file:`.py` son ekini içeren modül adıdır.  Bir modül içinde, modülün adı "
"(dize olarak) ``__name__`` genel değişkeninin değeri olarak kullanılabilir.  "
"Örneğin, geçerli dizinde aşağıdaki içeriklerle :file:`fibo.py` adlı bir "
"dosya oluşturmak için en sevdiğiniz metin düzenleyicisini kullanın::"

#: tutorial/modules.rst:45
msgid ""
"Now enter the Python interpreter and import this module with the following "
"command::"
msgstr ""
"Şimdi Python yorumlayıcısına girin ve bu modülü aşağıdaki komutla içe "
"aktarın::"

#: tutorial/modules.rst:50
msgid ""
"This does not add the names of the functions defined in ``fibo``  directly "
"to the current :term:`namespace` (see :ref:`tut-scopes` for more details); "
"it only adds the module name ``fibo`` there. Using the module name you can "
"access the functions::"
msgstr ""
"Bu, ``fibo`` 'da tanımlanan işlevlerin adlarını doğrudan geçerli :term:"
"`namespace` 'e  eklemez (daha fazla ayrıntı için bkz. :ref:`tut-scopes`); "
"oraya sadece ``fibo`` modül adını ekler. Modül adını kullanarak şu işlevlere "
"erişebilirsiniz:"

#: tutorial/modules.rst:62
msgid ""
"If you intend to use a function often you can assign it to a local name::"
msgstr ""
"Bir işlevi sık sık kullanmayı düşünüyorsanız, işlevi yerel bir ada "
"atayabilirsiniz::"

#: tutorial/modules.rst:72
msgid "More on Modules"
msgstr "Modüller hakkında daha fazla"

#: tutorial/modules.rst:74
msgid ""
"A module can contain executable statements as well as function definitions. "
"These statements are intended to initialize the module. They are executed "
"only the *first* time the module name is encountered in an import statement. "
"[#]_ (They are also run if the file is executed as a script.)"
msgstr ""
"Bir modül, işlev tanımlarının yanı sıra çalıştırılabilir ifadeler de "
"içerebilir. Bu ifadeler modülü başlatmayı amaçlamaktadır. Yalnızca bir "
"import ifadesinde modül adıyla karşılaşıldığında *ilk* kez yürütülürler. "
"[#]_ (Dosya komut dosyası olarak yürütülürse de çalıştırılırlar.)"

#: tutorial/modules.rst:79
msgid ""
"Each module has its own private namespace, which is used as the global "
"namespace by all functions defined in the module. Thus, the author of a "
"module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if you "
"know what you are doing you can touch a module's global variables with the "
"same notation used to refer to its functions, ``modname.itemname``."
msgstr ""
"Her modülün, modülde tanımlanan tüm işlevler tarafından genel ad alanı "
"olarak kullanılan kendi özel ad alanı vardır. Böylece, bir modülün yazarı, "
"bir kullanıcının genel değişkenleriyle yanlışlıkla çakışma endişesi "
"duymadan, modüldeki genel değişkenleri kullanabilir. Öte yandan, ne "
"yaptığınızı biliyorsanız, bir modülün global değişkenlerine, işlevlerine "
"atıfta bulunmak için kullanılan ``modname.itemname`` notasyonuyla "
"dokunabilirsiniz."

#: tutorial/modules.rst:86
msgid ""
"Modules can import other modules.  It is customary but not required to place "
"all :keyword:`import` statements at the beginning of a module (or script, "
"for that matter).  The imported module names, if placed at the top level of "
"a module (outside any functions or classes), are added to the module's "
"global namespace."
msgstr ""
"Modüller diğer modülleri içe aktarabilir. Tüm :keyword:`import` ifadelerinin "
"bir modülün (veya bu konuda betiğin) başına yerleştirilmesi alışılmış bir "
"durumdur ancak gerekli değildir. İçe aktarılan modül adları, bir modülün en "
"üst düzeyine yerleştirilirse (herhangi bir işlev veya sınıfın dışında), "
"modülün genel ad alanına eklenir."

#: tutorial/modules.rst:91
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's namespace.  For example::"
msgstr ""
":keyword:`import` ifadesinin, bir modülden adları doğrudan içe aktaran "
"modülün ad alanına aktaran bir çeşidi vardır. Örneğin::"

#: tutorial/modules.rst:98
msgid ""
"This does not introduce the module name from which the imports are taken in "
"the local namespace (so in the example, ``fibo`` is not defined)."
msgstr ""
"Bu, içe aktarmaların yerel ad alanında alındığı modül adını tanıtmaz(bu "
"nedenle örnekte ``fibo`` tanımlanmamıştır)."

#: tutorial/modules.rst:101
msgid "There is even a variant to import all names that a module defines::"
msgstr ""
"Bir modülün tanımladığı tüm adları içe aktarmak için bir varyant bile "
"vardır::"

#: tutorial/modules.rst:107
msgid ""
"This imports all names except those beginning with an underscore (``_``). In "
"most cases Python programmers do not use this facility since it introduces "
"an unknown set of names into the interpreter, possibly hiding some things "
"you have already defined."
msgstr ""
"Bu, alt çizgiyle başlayanlar (``_``) dışındaki tüm isimleri alır. Çoğu "
"durumda Python programcıları bu özelliği kullanmaz, çünkü yorumlayıcıya "
"bilinmeyen bir ad kümesi ekler ve muhtemelen önceden tanımladığınız bazı "
"şeyleri gizler."

#: tutorial/modules.rst:112
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"Genel olarak, bir modülden veya paketten ``*`` içeri aktarma uygulamasının, "
"genellikle okunamayan koda neden olduğundan hoş karşılanmadığına dikkat "
"edin. Ancak, etkileşimli oturumlarda yazmayı kaydetmek için kullanmak sorun "
"değildir."

#: tutorial/modules.rst:116
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"Modül adının ardından :keyword:`!as` geliyorsa, :keyword:`!as` 'den sonraki "
"ad doğrudan içe aktarılan modüle bağlanır."

#: tutorial/modules.rst:125
msgid ""
"This is effectively importing the module in the same way that ``import "
"fibo`` will do, with the only difference of it being available as ``fib``."
msgstr ""
"Bu, modülün ``import fibo`` 'nun yapacağı şekilde etkin bir şekilde içe "
"aktarılmasıdır, tek farkı ``fib`` olarak mevcut olmasıdır."

#: tutorial/modules.rst:128
msgid ""
"It can also be used when utilising :keyword:`from` with similar effects::"
msgstr ""
"Benzer efektlere sahip :keyword:`from` kullanılırken de kullanılabilir::"

#: tutorial/modules.rst:137
msgid ""
"For efficiency reasons, each module is only imported once per interpreter "
"session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test interactively, "
"use :func:`importlib.reload`, e.g. ``import importlib; importlib."
"reload(modulename)``."
msgstr ""
"Verimlilik nedeniyle, her modül yorumlayıcı oturumu başına yalnızca bir kez "
"içe aktarılır.  Bu nedenle, modüllerinizi değiştirirseniz, yorumlayıcıyı "
"yeniden başlatmanız gerekir - veya etkileşimli olarak test etmek istediğiniz "
"tek bir modülse, :func:`importlib.reload`, örneğin ``importlib; importlib."
"reload(modulename)``."

#: tutorial/modules.rst:147
msgid "Executing modules as scripts"
msgstr "Modülleri komut dosyası olarak yürütme"

#: tutorial/modules.rst:149
msgid "When you run a Python module with ::"
msgstr "Bir Python modülünü :: ile çalıştırdığınızda::"

#: tutorial/modules.rst:153
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding "
"this code at the end of your module::"
msgstr ""
"modüldeki kod, içe aktardığınız gibi yürütülür, ancak ``__name__`` "
"``\"__main__\"`` olarak ayarlanır. Bu, modülünüzün sonuna bu kodu ekleyerek:"

#: tutorial/modules.rst:161
msgid ""
"you can make the file usable as a script as well as an importable module, "
"because the code that parses the command line only runs if the module is "
"executed as the \"main\" file:"
msgstr ""
"dosyayı bir komut dosyası ve içe aktarılabilir bir modül olarak "
"kullanılabilir hale getirebilirsiniz, çünkü komut satırını ayrıştıran kod "
"yalnızca modül \"main\" dosya olarak yürütülürse çalışır:"

#: tutorial/modules.rst:170
msgid "If the module is imported, the code is not run::"
msgstr "Modül içe aktarılırsa kod çalıştırılmaz::"

#: tutorial/modules.rst:175
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes a "
"test suite)."
msgstr ""
"Bu genellikle bir modüle uygun bir kullanıcı arabirimi sağlamak veya test "
"amacıyla kullanılır (modülü komut dosyası olarak çalıştırmak bir test paketi "
"yürütür)."

#: tutorial/modules.rst:182
msgid "The Module Search Path"
msgstr "Modül Arama Yolu"

#: tutorial/modules.rst:186
msgid ""
"When a module named :mod:`spam` is imported, the interpreter first searches "
"for a built-in module with that name. These module names are listed in :data:"
"`sys.builtin_module_names`. If not found, it then searches for a file named :"
"file:`spam.py` in a list of directories given by the variable :data:`sys."
"path`.  :data:`sys.path` is initialized from these locations:"
msgstr ""
":mod:`spam` adlı bir modül içe aktarıldığında, yorumlayıcı önce bu ada sahip "
"yerleşik bir modül arar. Bu modül adları :data:`sys.builtin_module_names` "
"içinde listelenmiştir. Bulunamazsa, :data:`sys.path` değişkeni tarafından "
"verilen dizin listesinde :file:`spam.py` adlı bir dosyayı arar. :data:`sys."
"path` şu konumlardan başlatılır:"

#: tutorial/modules.rst:192
msgid ""
"The directory containing the input script (or the current directory when no "
"file is specified)."
msgstr ""
"Girdi komut dosyasını içeren dizin (veya dosya belirtilmediğinde geçerli "
"dizin)."

#: tutorial/modules.rst:194
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as the "
"shell variable :envvar:`PATH`)."
msgstr ""
":envvar:`PYTHONPATH` (kabuk değişkeni :envvar:`PATH` ile aynı sözdizimine "
"sahip dizin adlarının listesi)."

#: tutorial/modules.rst:196
msgid ""
"The installation-dependent default (by convention including a ``site-"
"packages`` directory, handled by the :mod:`site` module)."
msgstr ""
"Kuruluma bağlı varsayılan (kural olarak, :mod:`site` modülü tarafından "
"işlenen bir \"site-packages\" dizini dahil)."

#: tutorial/modules.rst:199
msgid "More details are at :ref:`sys-path-init`."
msgstr "Daha fazla ayrıntı :ref:`sys-path-init` adresindedir."

#: tutorial/modules.rst:202
msgid ""
"On file systems which support symlinks, the directory containing the input "
"script is calculated after the symlink is followed. In other words the "
"directory containing the symlink is **not** added to the module search path."
msgstr ""
"Symlink'leri destekleyen dosya sistemlerinde, symlink izlendikten sonra "
"girdi komut dosyasını içeren dizin hesaplanır. Başka bir deyişle, symlink "
"içeren dizin modül arama yoluna **not** eklenir."

#: tutorial/modules.rst:206
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of the "
"search path, ahead of the standard library path. This means that scripts in "
"that directory will be loaded instead of modules of the same name in the "
"library directory. This is an error unless the replacement is intended.  See "
"section :ref:`tut-standardmodules` for more information."
msgstr ""
"Başlatıldıktan sonra Python programları :data:`sys.path` değiştirebilir.  "
"Çalıştırılmakta olan komut dosyasını içeren dizin, arama yolunun başına, "
"standart kitaplık yolunun önüne yerleştirilir. Bu, kitaplık dizininde aynı "
"ada sahip modüller yerine bu dizindeki komut dosyalarının yüklanacağı "
"anlamına gelir. Değiştirme amaçlanmadığı sürece bu bir hatadır.  Daha fazla "
"bilgi için :ref:`tut-standardmodules` bölümüne bakın."

#: tutorial/modules.rst:219
msgid "\"Compiled\" Python files"
msgstr "\"Derlenmiş\" Python dosyaları"

#: tutorial/modules.rst:221
msgid ""
"To speed up loading modules, Python caches the compiled version of each "
"module in the ``__pycache__`` directory under the name :file:`module."
"{version}.pyc`, where the version encodes the format of the compiled file; "
"it generally contains the Python version number.  For example, in CPython "
"release 3.3 the compiled version of spam.py would be cached as ``__pycache__/"
"spam.cpython-33.pyc``.  This naming convention allows compiled modules from "
"different releases and different versions of Python to coexist."
msgstr ""
"Modüllerin yüklenmesini hızlandırmak için Python, her modülün derlenmiş "
"sürümünü ``__pycache__`` dizininde :file:`module.{version}.pyc` adı altında "
"önbelleğe alır; burada sürüm, derlenen dosyanın biçimini kodlar; genellikle "
"Python sürüm numarasını içerir. Örneğin, CPython 3.3 sürümünde spam.py'nin "
"derlenmiş sürümü ``__pycache__/spam.cpython-33.pyc`` olarak önbelleğe "
"alınacaktır. Bu adlandırma kuralı, farklı sürümlerden ve Python'un farklı "
"sürümlerinden derlenmiş modüllerin bir arada var olmasına izin verir."

#: tutorial/modules.rst:229
msgid ""
"Python checks the modification date of the source against the compiled "
"version to see if it's out of date and needs to be recompiled.  This is a "
"completely automatic process.  Also, the compiled modules are platform-"
"independent, so the same library can be shared among systems with different "
"architectures."
msgstr ""
"Python, eski olup olmadığını ve yeniden derlenmesi gerekip gerekmediğini "
"görmek için kaynağın değişiklik tarihini derlenmiş sürümle karşılaştırır. Bu "
"tamamen otomatik bir işlemdir. Ayrıca, derlenen modüller platformdan "
"bağımsızdır, bu nedenle aynı kitaplık farklı mimarilere sahip sistemler "
"arasında paylaşılabilir."

#: tutorial/modules.rst:234
msgid ""
"Python does not check the cache in two circumstances.  First, it always "
"recompiles and does not store the result for the module that's loaded "
"directly from the command line.  Second, it does not check the cache if "
"there is no source module.  To support a non-source (compiled only) "
"distribution, the compiled module must be in the source directory, and there "
"must not be a source module."
msgstr ""
"Python iki durumda önbelleği kontrol etmez. İlk olarak, doğrudan komut "
"satırından yüklenen modülün sonucunu her zaman yeniden derler ve saklamaz. "
"İkincisi, kaynak modül yoksa önbelleği kontrol etmez. Kaynak olmayan "
"(yalnızca derlenmiş) bir dağıtımı desteklemek için, derlenen modül kaynak "
"dizinde olmalı ve bir kaynak modül olmamalıdır."

#: tutorial/modules.rst:241
msgid "Some tips for experts:"
msgstr "Uzmanlar için bazı ipuçları:"

#: tutorial/modules.rst:243
msgid ""
"You can use the :option:`-O` or :option:`-OO` switches on the Python command "
"to reduce the size of a compiled module.  The ``-O`` switch removes assert "
"statements, the ``-OO`` switch removes both assert statements and __doc__ "
"strings.  Since some programs may rely on having these available, you should "
"only use this option if you know what you're doing.  \"Optimized\" modules "
"have an ``opt-`` tag and are usually smaller.  Future releases may change "
"the effects of optimization."
msgstr ""
"Derlenmiş bir modülün boyutunu küçültmek için Python komutundaki :option:`-"
"O` veya :option:`-OO` anahtarlarını kullanabilirsiniz. ``-O`` anahtarı, "
"onaylama ifadelerini kaldırır, ``-OO`` anahtarı, hem assert ifadelerini hem "
"de __doc__ dizelerini kaldırır. Bazı programlar bunların kullanılabilir "
"olmasına güvenebileceğinden, bu seçeneği yalnızca ne yaptığınızı "
"biliyorsanız kullanmalısınız. \"Optimize edilmiş\" modüller bir \"opt-\" "
"etiketine sahiptir ve genellikle daha küçüktür. Gelecekteki sürümler, "
"optimizasyonun etkilerini değiştirebilir."

#: tutorial/modules.rst:251
msgid ""
"A program doesn't run any faster when it is read from a ``.pyc`` file than "
"when it is read from a ``.py`` file; the only thing that's faster about ``."
"pyc`` files is the speed with which they are loaded."
msgstr ""
"Bir program ``.pyc`` dosyasından okunduğunda, ``.py`` dosyasından "
"okunduğundan daha hızlı çalışmaz; ``.pyc`` dosyaları hakkında daha hızlı "
"olan tek şey, yüklenme hızlarıdır."

#: tutorial/modules.rst:255
msgid ""
"The module :mod:`compileall` can create .pyc files for all modules in a "
"directory."
msgstr ""
":mod:`compileall` modülü, bir dizindeki tüm modüller için .pyc dosyaları "
"oluşturabilir."

#: tutorial/modules.rst:258
msgid ""
"There is more detail on this process, including a flow chart of the "
"decisions, in :pep:`3147`."
msgstr ""
":pep:`3147` 'de, kararların bir akış şeması da dahil olmak üzere, bu süreç "
"hakkında daha fazla ayrıntı bulunmaktadır."

#: tutorial/modules.rst:265
msgid "Standard Modules"
msgstr "Standart modüller"

#: tutorial/modules.rst:269
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter).  "
"Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such modules "
"is a configuration option which also depends on the underlying platform.  "
"For example, the :mod:`winreg` module is only provided on Windows systems. "
"One particular module deserves some attention: :mod:`sys`, which is built "
"into every Python interpreter.  The variables ``sys.ps1`` and ``sys.ps2`` "
"define the strings used as primary and secondary prompts::"
msgstr ""
"Python, ayrı bir belge olan Python Kütüphanesi Referansında (bundan sonra "
"\"Kütüphane Referansı\") açıklanan standart modüllerden oluşan bir kütüphane "
"ile birlikte gelir. Bazı modüller yorumlayıcıya yerleştirilmiştir; bunlar, "
"dilin çekirdeğinin bir parçası olmayan, ancak yine de verimlilik için veya "
"sistem çağrıları gibi işletim sistemi ilkellerine erişim sağlamak için "
"yerleşik olan işlemlere erişim sağlar. Bu tür modüller seti, aynı zamanda "
"temel platforma da bağlı olan bir yapılandırma seçeneğidir. Örneğin, :mod:"
"`winreg` modülü yalnızca Windows sistemlerinde sağlanır. Belirli bir modül "
"biraz ilgiyi hak ediyor: Her Python yorumlayıcısında yerleşik olan :mod:"
"`sys`. ``sys.ps1`` ve ``sys.ps2`` değişkenleri, birincil ve ikincil bilgi "
"istemleri olarak kullanılan dizeleri tanımlar:"

#: tutorial/modules.rst:292
msgid ""
"These two variables are only defined if the interpreter is in interactive "
"mode."
msgstr "Bu iki değişken yalnızca yorumlayıcı etkileşimli moddaysa tanımlanır."

#: tutorial/modules.rst:294
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default path "
"taken from the environment variable :envvar:`PYTHONPATH`, or from a built-in "
"default if :envvar:`PYTHONPATH` is not set.  You can modify it using "
"standard list operations::"
msgstr ""
"``sys.path`` değişkeni, yorumlayıcının modüller için arama yolunu belirleyen "
"bir dizeler listesidir. :envvar:`PYTHONPATH` ortam değişkeninden veya :"
"envvar:`PYTHONPATH` ayarlanmamışsa yerleşik bir varsayılan değerden alınan "
"varsayılan bir yola başlatılır. Standart liste işlemlerini kullanarak "
"değiştirebilirsiniz::"

#: tutorial/modules.rst:307
msgid "The :func:`dir` Function"
msgstr ":func:`dir` Fonksiyonu"

#: tutorial/modules.rst:309
msgid ""
"The built-in function :func:`dir` is used to find out which names a module "
"defines.  It returns a sorted list of strings::"
msgstr ""
"Yerleşik fonksiyon :func:`dir`, bir modülün hangi adları tanımladığını "
"bulmak için kullanılır. Sıralanmış bir dize listesi döndürür::"

#: tutorial/modules.rst:338
msgid ""
"Without arguments, :func:`dir` lists the names you have defined currently::"
msgstr ""
"Argümanlar olmadan, :func:`dir`, şu anda tanımladığınız adları listeler::"

#: tutorial/modules.rst:346
msgid ""
"Note that it lists all types of names: variables, modules, functions, etc."
msgstr ""
"Her tür adın listelendiğini unutmayın: değişkenler, modüller, fonksiyonlar "
"vb."

#: tutorial/modules.rst:350
msgid ""
":func:`dir` does not list the names of built-in functions and variables.  If "
"you want a list of those, they are defined in the standard module :mod:"
"`builtins`::"
msgstr ""
":func:`dir` yerleşik fonksiyonlarun ve değişkenlerin adlarını listelemez. "
"Bunların bir listesini istiyorsanız, standart modül :mod:`builtins` 'de "
"tanımlanırlar::"

#: tutorial/modules.rst:389
msgid "Packages"
msgstr "Paketler"

#: tutorial/modules.rst:391
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`A.B` designates "
"a submodule named ``B`` in a package named ``A``.  Just like the use of "
"modules saves the authors of different modules from having to worry about "
"each other's global variable names, the use of dotted module names saves the "
"authors of multi-module packages like NumPy or Pillow from having to worry "
"about each other's module names."
msgstr ""
"Paketler, \"noktalı modül adlarını\" kullanarak Python'un modül ad alanını "
"yapılandırmanın bir yoludur. Örneğin, modül adı :mod:`A.B`, \"A\" adlı bir "
"pakette \"B\" adlı bir alt modülü belirtir. Modüllerin kullanılması, farklı "
"modüllerin yazarlarını birbirlerinin global değişken adları hakkında "
"endişelenmekten kurtardığı gibi, noktalı modül adlarının kullanılması, NumPy "
"veya Pillow gibi çok modüllü paketlerin yazarlarını birbirlerinin modül "
"adları hakkında endişelenmekten kurtarır."

#: tutorial/modules.rst:399
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for the "
"uniform handling of sound files and sound data.  There are many different "
"sound file formats (usually recognized by their extension, for example: :"
"file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to create and "
"maintain a growing collection of modules for the conversion between the "
"various file formats. There are also many different operations you might "
"want to perform on sound data (such as mixing, adding echo, applying an "
"equalizer function, creating an artificial stereo effect), so in addition "
"you will be writing a never-ending stream of modules to perform these "
"operations.  Here's a possible structure for your package (expressed in "
"terms of a hierarchical filesystem):"
msgstr ""
"Ses dosyalarının ve ses verilerinin tek tip işlenmesi için bir modül "
"koleksiyonu (\"paket\") tasarlamak istediğinizi varsayalım. Birçok farklı "
"ses dosyası biçimi vardır (genellikle uzantılarıyla tanınır, örneğin: :file:"
"`.wav`, :file:`.aiff`, :file:`.au`) bu nedenle, çeşitli dosya biçimleri "
"arasında dönüşüm için büyüyen bir modül koleksiyonu oluşturmanız ve "
"sürdürmeniz gerekebilir. Ses verileri üzerinde gerçekleştirmek "
"isteyebileceğiniz birçok farklı işlem de vardır (karıştırma, eko ekleme, "
"ekolayzır işlevi uygulama, yapay bir stereo efekti oluşturma gibi) bu "
"nedenle ek olarak, bu işlemleri gerçekleştirmek için hiç bitmeyen bir modül "
"akışı yazıyor olacaksınız. İşte paketiniz için olası bir yapı (hiyerarşik "
"bir dosya sistemi cinsinden ifade edilir):"

#: tutorial/modules.rst:436
msgid ""
"When importing the package, Python searches through the directories on ``sys."
"path`` looking for the package subdirectory."
msgstr ""
"Paketi içe aktarırken Python, paket alt dizinini arayan ``sys.path`` "
"üzerindeki dizinleri arar."

#: tutorial/modules.rst:439
msgid ""
"The :file:`__init__.py` files are required to make Python treat directories "
"containing the file as packages.  This prevents directories with a common "
"name, such as ``string``, unintentionally hiding valid modules that occur "
"later on the module search path. In the simplest case, :file:`__init__.py` "
"can just be an empty file, but it can also execute initialization code for "
"the package or set the ``__all__`` variable, described later."
msgstr ""
"Python'un dosyayı içeren dizinleri paketler olarak ele alması için :file:"
"`__init__.py` dosyaları gereklidir. Bu, ``string`` gibi ortak bir ada sahip "
"dizinlerin, daha sonra modül arama yolunda oluşan geçerli modülleri "
"istemeden gizlemesini önler. En basit durumda, :file:`__init__.py` yalnızca "
"boş bir dosya olabilir, ancak aynı zamanda paket için başlatma kodunu "
"çalıştırabilir veya daha sonra açıklanacak olan ``__all__`` değişkenini "
"ayarlayabilir."

#: tutorial/modules.rst:446
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr ""
"Paketin kullanıcıları, paketin içindeki ayrı modülleri içe aktarabilir, "
"örneğin::"

#: tutorial/modules.rst:451
msgid ""
"This loads the submodule :mod:`sound.effects.echo`.  It must be referenced "
"with its full name. ::"
msgstr ""
"Bu, :mod:`sound.effects.echo` alt modülünü yükler. Tam adı ile referans "
"gösterilmelidir. ::"

#: tutorial/modules.rst:456
msgid "An alternative way of importing the submodule is::"
msgstr "Alt modülü içe aktarmanın alternatif bir yolu::"

#: tutorial/modules.rst:460
msgid ""
"This also loads the submodule :mod:`echo`, and makes it available without "
"its package prefix, so it can be used as follows::"
msgstr ""
"Bu ayrıca :mod:`echo` alt modülünü yükler ve paket öneki olmadan "
"kullanılabilir hale getirir, böylece aşağıdaki gibi kullanılabilir::"

#: tutorial/modules.rst:465
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr ""
"Yine başka bir varyasyon, istenen işlevi veya değişkeni doğrudan içe "
"aktarmaktır::"

#: tutorial/modules.rst:469
msgid ""
"Again, this loads the submodule :mod:`echo`, but this makes its function :"
"func:`echofilter` directly available::"
msgstr ""
"Yine, bu, :mod:`echo` alt modülünü yükler, ancak bu, :func:`echofilter` "
"fonksiyonunu doğrudan kullanılabilir hale getirir::"

#: tutorial/modules.rst:474
msgid ""
"Note that when using ``from package import item``, the item can be either a "
"submodule (or subpackage) of the package, or some  other name defined in the "
"package, like a function, class or variable.  The ``import`` statement first "
"tests whether the item is defined in the package; if not, it assumes it is a "
"module and attempts to load it.  If it fails to find it, an :exc:"
"`ImportError` exception is raised."
msgstr ""
"``from package import item`` kullanırken, öğenin paketin bir alt modülü "
"(veya alt paketi) veya pakette tanımlanmış bir fonksiyon, sınıf veya "
"değişken gibi başka bir ad olabileceğini unutmayın. ``import`` ifadesi önce "
"öğenin pakette tanımlanıp tanımlanmadığını test eder; değilse modül olduğunu "
"varsayar ve yüklemeye çalışır. Onu bulamazsa, bir :exc:`ImportError` "
"istisnası ortaya çıkar."

#: tutorial/modules.rst:481
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, each "
"item except for the last must be a package; the last item can be a module or "
"a package but can't be a class or function or variable defined in the "
"previous item."
msgstr ""
"Aksine, ``import item.subitem.subsubitem`` gibi bir sözdizimi kullanırken, "
"sonuncusu hariç her öğe bir paket olmalıdır; son öğe bir modül veya paket "
"olabilir, ancak önceki öğede tanımlanan bir sınıf, fonksiyon veya değişken "
"olamaz."

#: tutorial/modules.rst:490
msgid "Importing \\* From a Package"
msgstr "Bir Paketten \\* İçe Aktarma"

#: tutorial/modules.rst:494
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, finds "
"which submodules are present in the package, and imports them all.  This "
"could take a long time and importing sub-modules might have unwanted side-"
"effects that should only happen when the sub-module is explicitly imported."
msgstr ""
"Şimdi, kullanıcı ``from sound.effects import *`` yazdığında ne olur? İdeal "
"olarak, bunun bir şekilde dosya sistemine gitmesi, pakette hangi alt "
"modüllerin bulunduğunu bulması ve hepsini içe aktarması umulur. Bu uzun "
"zaman alabilir ve alt modüllerin içe aktarılması, yalnızca alt modül açıkça "
"içe aktarıldığında gerçekleşmesi gereken istenmeyen yan etkilere neden "
"olabilir."

#: tutorial/modules.rst:500
msgid ""
"The only solution is for the package author to provide an explicit index of "
"the package.  The :keyword:`import` statement uses the following convention: "
"if a package's :file:`__init__.py` code defines a list named ``__all__``, it "
"is taken to be the list of module names that should be imported when ``from "
"package import *`` is encountered.  It is up to the package author to keep "
"this list up-to-date when a new version of the package is released.  Package "
"authors may also decide not to support it, if they don't see a use for "
"importing \\* from their package.  For example, the file :file:`sound/"
"effects/__init__.py` could contain the following code::"
msgstr ""
"Tek çözüm, paket yazarının paketin açık bir dizinini sağlamasıdır. :keyword:"
"`import` ifadesi aşağıdaki kuralı kullanır: eğer bir paketin :file:`__init__."
"py` kodu ``__all__`` adlı bir liste tanımlarsa, ``from package import *`` "
"ile karşılaşıldığında alınması gereken modül adlarının listesi olarak "
"alınır. Paketin yeni bir sürümü yayınlandığında bu listeyi güncel tutmak "
"paket yazarının sorumluluğundadır. Paket yazarları, paketlerinden \\* içe "
"aktarmak için bir kullanım görmezlerse, onu desteklememeye de karar "
"verebilirler. Örneğin, :file:`sound/effects/__init__.py` dosyası şu kodu "
"içerebilir::"

#: tutorial/modules.rst:512
msgid ""
"This would mean that ``from sound.effects import *`` would import the three "
"named submodules of the :mod:`sound.effects` package."
msgstr ""
"Bu, ``from sound.effects import *`` öğesinin :mod:`sound` paketinin "
"adlandırılmış üç alt modülünü içe aktaracağı anlamına gelir."

#: tutorial/modules.rst:515
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import *`` "
"does *not* import all submodules from the package :mod:`sound.effects` into "
"the current namespace; it only ensures that the package :mod:`sound.effects` "
"has been imported (possibly running any initialization code in :file:"
"`__init__.py`) and then imports whatever names are defined in the package.  "
"This includes any names defined (and submodules explicitly loaded) by :file:"
"`__init__.py`.  It also includes any submodules of the package that were "
"explicitly loaded by previous :keyword:`import` statements.  Consider this "
"code::"
msgstr ""
"``__all__`` tanımlı değilse, ``from sound.effects import *`` ifadesi :mod:"
"`sound.effects` paketindeki tüm alt modülleri geçerli ad alanına *almaz*; "
"yalnızca :mod:`sound.effects` paketinin içe aktarılmasını sağlar (mümkünse "
"herhangi bir başlatma kodunu :file:`__init__.py` içinde çalıştırır) ve "
"ardından pakette tanımlanan adları içe aktarır. Bu, :file:`__init__.py` "
"tarafından tanımlanan tüm adları (ve açıkça yüklenen alt modülleri) içerir. "
"Ayrıca, önceki :keyword:`import` ifadeleri tarafından açıkça yüklenen "
"paketin tüm alt modüllerini de içerir. Bu kodu dikkate alın ::"

#: tutorial/modules.rst:528
msgid ""
"In this example, the :mod:`echo` and :mod:`surround` modules are imported in "
"the current namespace because they are defined in the :mod:`sound.effects` "
"package when the ``from...import`` statement is executed.  (This also works "
"when ``__all__`` is defined.)"
msgstr ""
"Bu örnekte, :mod:`echo` ve :mod:`surround` modülleri geçerli ad alanına "
"aktarılır, çünkü bunlar ``from...import`` ifadesi yürütüldüğünde :mod:`sound."
"effects` paketinde tanımlanmışlardır. (Bu aynı zamanda ``__all__`` "
"tanımlandığında da çalışır.)"

#: tutorial/modules.rst:533
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"Bazı modüller, ``import *`` kullandığınızda yalnızca belirli kalıpları takip "
"eden adları dışa aktarmak üzere tasarlanmış olsa da, üretim kodunda yine de "
"kötü uygulama olarak kabul edilir."

#: tutorial/modules.rst:537
msgid ""
"Remember, there is nothing wrong with using ``from package import "
"specific_submodule``!  In fact, this is the recommended notation unless the "
"importing module needs to use submodules with the same name from different "
"packages."
msgstr ""
"Unutmayın, ``from package import specific_submodule`` kullanmanın yanlış bir "
"tarafı yok! Aslında, içe aktarma modülünün farklı paketlerden aynı ada sahip "
"alt modülleri kullanması gerekmedikçe, önerilen gösterim budur."

#: tutorial/modules.rst:546
msgid "Intra-package References"
msgstr "Paket İçi Referanslar"

#: tutorial/modules.rst:548
msgid ""
"When packages are structured into subpackages (as with the :mod:`sound` "
"package in the example), you can use absolute imports to refer to submodules "
"of siblings packages.  For example, if the module :mod:`sound.filters."
"vocoder` needs to use the :mod:`echo` module in the :mod:`sound.effects` "
"package, it can use ``from sound.effects import echo``."
msgstr ""
"Paketler alt paketler halinde yapılandırıldığında (örnekteki :mod:`sound` "
"paketinde olduğu gibi), kardeş paketlerin alt modüllerine atıfta bulunmak "
"için mutlak içe aktarma kullanabilirsiniz. Örneğin, :mod:`sound.filters."
"vocoder` modülünün :mod:`sound.effects` paketindeki :mod:`echo` modülünü "
"kullanması gerekiyorsa, ``from sound.effects import echo`` 'yu kullanabilir."

#: tutorial/modules.rst:554
msgid ""
"You can also write relative imports, with the ``from module import name`` "
"form of import statement.  These imports use leading dots to indicate the "
"current and parent packages involved in the relative import.  From the :mod:"
"`surround` module for example, you might use::"
msgstr ""
"Ayrıca, içe aktarma ifadesinin ``from module import name`` formuyla göreli "
"içe aktarmaları da yazabilirsiniz. Bu içe aktarmalar, göreli içe aktarmada "
"yer alan mevcut ve ana paketleri belirtmek için baştaki noktaları kullanır. "
"Örneğin :mod:`surround` modülünden şunları kullanabilirsiniz::"

#: tutorial/modules.rst:563
msgid ""
"Note that relative imports are based on the name of the current module.  "
"Since the name of the main module is always ``\"__main__\"``, modules "
"intended for use as the main module of a Python application must always use "
"absolute imports."
msgstr ""
"Göreceli içe aktarmaların geçerli modülün adını temel aldığını unutmayın. "
"Ana modülün adı her zaman ``\"__main__\"`` olduğundan, Python uygulamasının "
"ana modülü olarak kullanılması amaçlanan modüller her zaman mutlak içe "
"aktarma kullanmalıdır."

#: tutorial/modules.rst:569
msgid "Packages in Multiple Directories"
msgstr "Birden Çok Dizindeki Paketler"

#: tutorial/modules.rst:571
msgid ""
"Packages support one more special attribute, :attr:`__path__`.  This is "
"initialized to be a list containing the name of the directory holding the "
"package's :file:`__init__.py` before the code in that file is executed.  "
"This variable can be modified; doing so affects future searches for modules "
"and subpackages contained in the package."
msgstr ""
"Paketler bir özel özelliği daha destekler, :attr:`__path__`. Bu, o dosyadaki "
"kod yürütülmeden önce paketin :file:`__init__.py` dosyasını tutan dizinin "
"adını içeren bir liste olacak şekilde başlatılır. Bu değişken "
"değiştirilebilir; bunu yapmak, pakette bulunan modüller ve alt paketler için "
"gelecekteki aramaları etkiler."

#: tutorial/modules.rst:577
msgid ""
"While this feature is not often needed, it can be used to extend the set of "
"modules found in a package."
msgstr ""
"Bu özelliğe sıklıkla ihtiyaç duyulmasa da, bir pakette bulunan modül "
"dizisini genişletmek için kullanılabilir."

#: tutorial/modules.rst:582
msgid "Footnotes"
msgstr "Dipnotlar"

#: tutorial/modules.rst:583
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; the "
"execution of a module-level function definition adds the function name to "
"the module's global namespace."
msgstr ""
"Aslında işlev tanımları aynı zamanda 'çalıştırılan' 'ifadelerdir'; modül "
"düzeyinde bir işlev tanımının çalıştırılması, işlev adını modülün genel ad "
"alanına ekler."
