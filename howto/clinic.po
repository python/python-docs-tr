# Python Documentation Turkish Translation
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-04 18:33+0000\n"
"PO-Revision-Date: 2023-05-02 01:31+0300\n"
"Last-Translator: \n"
"Language-Team: TURKISH <python.docs.tr@gmail.com>\n"
"Language: tr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.2.2\n"

#: howto/clinic.rst:8
msgid "Argument Clinic How-To"
msgstr "Argüman Kliniği Nasıl Yapılır"

#: howto/clinic.rst:13
msgid ""
"The Argument Clinic How-TO has been moved to the `Python Developer's Guide "
"<https://devguide.python.org/development-tools/clinic/>`__."
msgstr ""

#~ msgid "author"
#~ msgstr "yazar"

#~ msgid "Larry Hastings"
#~ msgstr "Larry Hastings"

#~ msgid "Abstract"
#~ msgstr "Soyut"

#, fuzzy
#~ msgid ""
#~ "Argument Clinic is considered internal-only for CPython.  Its use is not "
#~ "supported for files outside CPython, and no guarantees are made regarding "
#~ "backwards compatibility for future versions.  In other words: if you "
#~ "maintain an external C extension for CPython, you're welcome to "
#~ "experiment with Argument Clinic in your own code.  But the version of "
#~ "Argument Clinic that ships with the next version of CPython *could* be "
#~ "totally incompatible and break all your code."
#~ msgstr ""
#~ "Şu anda Argüman Kliniği CPython için dahili olarak kabul edilmektedir.  "
#~ "CPython dışındaki dosyalar için kullanımı desteklenmemektedir ve gelecek "
#~ "sürümler için geriye dönük uyumluluk konusunda herhangi bir garanti "
#~ "verilmemektedir.  Başka bir deyişle: CPython için harici bir C uzantısına "
#~ "sahipseniz, Argüman Kliniği'ni kendi kodunuzda deneyebilirsiniz.  Ancak "
#~ "CPython'un bir sonraki sürümüyle birlikte gelen Argüman Kliniği sürümü * "
#~ "tamamen uyumsuz olabilir ve tüm kodunuzu bozabilir."

#, fuzzy
#~ msgid "Basic concepts"
#~ msgstr "Temel Kavramlar ve Kullanım"

#, fuzzy
#~ msgid "When it finds one, it reads everything up to the :term:`end line`:"
#~ msgstr ""
#~ "Bir tane bulduğunda, tam olarak buna benzeyen bir satıra kadar her şeyi "
#~ "okur:"

#, fuzzy
#~ msgid ""
#~ "If you run Argument Clinic on the same file a second time, Argument "
#~ "Clinic will discard the old :term:`output` and write out the new output "
#~ "with a fresh :term:`checksum line`. If the :term:`input` hasn't changed, "
#~ "the output won't change either."
#~ msgstr ""
#~ "Argüman Kliniği'ni aynı dosya üzerinde ikinci kez çalıştırırsanız, "
#~ "Argüman Kliniği eski çıktıyı atacak ve yeni çıktıyı yeni bir sağlama "
#~ "toplamı satırıyla birlikte yazacaktır.  Ancak, girdi değişmemişse, çıktı "
#~ "da değişmeyecektir."

#, fuzzy
#~ msgid "The text between the :term:`end line` and the :term:`checksum line`."
#~ msgstr "Bitiş satırı ile sağlama toplamı satırı arasında *çıktı* bulunur."

#, fuzzy
#~ msgid "block"
#~ msgstr "``block````block``"

#, fuzzy
#~ msgid "Classes for extending Argument Clinic"
#~ msgstr "Argüman Kliniğinin Hedefleri"

#, fuzzy
#~ msgid ""
#~ "The C type to use for this variable. :attr:`!type` should be a Python "
#~ "string specifying the type, e.g. ``'int'``. If this is a pointer type, "
#~ "the type string should end with ``' *'``."
#~ msgstr ""
#~ "Bu değişken için kullanılacak C türü. ``type`` türü belirten bir Python "
#~ "dizesi olmalıdır, örneğin ``int``. Eğer bu bir gösterici tipiyse, tip "
#~ "dizesi ``' *'`` ile bitmelidir."

#~ msgid ""
#~ "The Python default value for this parameter, as a Python value. Or the "
#~ "magic value ``unspecified`` if there is no default."
#~ msgstr ""
#~ "Bir Python değeri olarak bu parametre için Python varsayılan değeri. Veya "
#~ "varsayılan değer yoksa ``unspecified`` sihirli değeri."

#, fuzzy
#~ msgid ""
#~ ":attr:`!default` as it should appear in Python code, as a string. Or "
#~ "``None`` if there is no default."
#~ msgstr ""
#~ "``default`` Python kodunda görünmesi gerektiği gibi, bir string olarak. "
#~ "Veya varsayılan yoksa ``None``."

#, fuzzy
#~ msgid ""
#~ ":attr:`!default` as it should appear in C code, as a string. Or ``None`` "
#~ "if there is no default."
#~ msgstr ""
#~ "C kodunda görünmesi gerektiği gibi, bir dize olarak ``default``. Veya "
#~ "varsayılan yoksa ``None``."

#~ msgid ""
#~ "The default value used to initialize the C variable when there is no "
#~ "default, but not specifying a default may result in an \"uninitialized "
#~ "variable\" warning.  This can easily happen when using option groups—"
#~ "although properly written code will never actually use this value, the "
#~ "variable does get passed in to the impl, and the C compiler will complain "
#~ "about the \"use\" of the uninitialized value.  This value should always "
#~ "be a non-empty string."
#~ msgstr ""
#~ "Varsayılan bir değer olmadığında C değişkenini başlatmak için kullanılan "
#~ "varsayılan değerdir, ancak varsayılan bir değer belirtilmemesi "
#~ "\"başlatılmamış değişken\" uyarısına neden olabilir.  Bu durum, seçenek "
#~ "grupları kullanıldığında kolaylıkla meydana gelebilir; doğru yazılmış kod "
#~ "bu değeri hiçbir zaman kullanmayacak olsa da, değişken impl'ye aktarılır "
#~ "ve C derleyicisi başlatılmamış değerin \"kullanımından\" şikayet eder.  "
#~ "Bu değer her zaman boş olmayan bir dize olmalıdır."

#~ msgid "The name of the C converter function, as a string."
#~ msgstr "C dönüştürücü işlevinin bir dize olarak adı."

#~ msgid ""
#~ "A boolean value.  If true, Argument Clinic will add a ``&`` in front of "
#~ "the name of the variable when passing it into the impl function."
#~ msgstr ""
#~ "Boolean bir değer.  Eğer true ise, Argüman Kliniği değişkeni impl "
#~ "fonksiyonuna aktarırken değişkenin isminin önüne bir ``&`` ekler."

#~ msgid ""
#~ "A boolean value.  If true, Argument Clinic will add a ``&`` in front of "
#~ "the name of the variable when passing it into :c:func:`PyArg_ParseTuple`."
#~ msgstr ""
#~ "Boolean bir değer.  Eğer true ise, Argüman Kliniği :c:func:"
#~ "`PyArg_ParseTuple` içine aktarırken değişkenin isminin önüne bir ``&`` "
#~ "ekleyecektir."

#, fuzzy
#~ msgid ""
#~ "The best way to get a sense of how Argument Clinic works is to convert a "
#~ "function to work with it.  Here, then, are the bare minimum steps you'd "
#~ "need to follow to convert a function to work with Argument Clinic.  Note "
#~ "that for code you plan to check in to CPython, you really should take the "
#~ "conversion farther, using some of the :ref:`advanced concepts <clinic-"
#~ "howtos>` you'll see later on in the document, like :ref:`clinic-howto-"
#~ "return-converters` and :ref:`clinic-howto-self-converter`. But we'll keep "
#~ "it simple for this walkthrough so you can learn."
#~ msgstr ""
#~ "Argüman Kliniği'nin nasıl çalıştığını anlamanın en iyi yolu, bir "
#~ "fonksiyonu onunla çalışacak şekilde dönüştürmektir.  O halde burada, bir "
#~ "fonksiyonu Argüman Kliniği ile çalışacak şekilde dönüştürmek için "
#~ "izlemeniz gereken asgari adımlar yer almaktadır.  CPython'da kontrol "
#~ "etmeyi planladığınız kod için, belgede daha sonra göreceğiniz bazı "
#~ "gelişmiş kavramları (\"dönüş dönüştürücüler\" ve \"öz dönüştürücüler\" "
#~ "gibi) kullanarak dönüştürmeyi gerçekten daha ileri götürmeniz gerektiğini "
#~ "unutmayın. Ancak öğrenebilmeniz için bu kılavuz için basit tutacağız."

#, fuzzy
#~ msgid ""
#~ "First, make sure you're working with a freshly updated checkout of the "
#~ "CPython trunk."
#~ msgstr ""
#~ "CPython trunk'ın yeni güncellenmiş bir checkout'u ile çalıştığınızdan "
#~ "emin olun."

#, fuzzy
#~ msgid ""
#~ "Next, find a Python builtin that calls either :c:func:`PyArg_ParseTuple` "
#~ "or :c:func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted to "
#~ "work with Argument Clinic yet. For this tutorial, we'll be using :py:meth:"
#~ "`_pickle.Pickler.dump <pickle.Pickler.dump>`."
#~ msgstr ""
#~ ":c:func:`PyArg_ParseTuple` veya :c:func:`PyArg_ParseTupleAndKeywords` "
#~ "çağıran ve henüz Argüman Kliniği ile çalışmak üzere dönüştürülmemiş bir "
#~ "Python yerleşik bileşeni bulun. Benim örneğim için ``_pickle.Pickler."
#~ "dump()`` kullanıyorum."

#, fuzzy
#~ msgid ""
#~ "If the call to the :c:func:`!PyArg_Parse*` function uses any of the "
#~ "following format units...:"
#~ msgstr ""
#~ "Eğer ``PyArg_Parse`` fonksiyonuna yapılan çağrı aşağıdaki format "
#~ "birimlerinden herhangi birini kullanıyorsa:"

#, fuzzy
#~ msgid ""
#~ "... or if it has multiple calls to :c:func:`PyArg_ParseTuple`, you should "
#~ "choose a different function. (See :ref:`clinic-howto-advanced-converters` "
#~ "for those scenarios.)"
#~ msgstr ""
#~ "veya :c:func:`PyArg_ParseTuple` için birden fazla çağrı varsa, farklı bir "
#~ "işlev seçmelisiniz.  Argüman Kliniği bu senaryoların tümünü *destekler*.  "
#~ "Ancak bunlar ileri düzey konulardır - ilk fonksiyonunuz için daha basit "
#~ "bir şey yapalım."

#, fuzzy
#~ msgid ""
#~ "Also, if the function has multiple calls to :c:func:`!PyArg_ParseTuple` "
#~ "or :c:func:`PyArg_ParseTupleAndKeywords` where it supports different "
#~ "types for the same argument, or if the function uses something besides :c:"
#~ "func:`!PyArg_Parse*` functions to parse its arguments, it probably isn't "
#~ "suitable for conversion to Argument Clinic.  Argument Clinic doesn't "
#~ "support generic functions or polymorphic parameters."
#~ msgstr ""
#~ "Ayrıca, fonksiyonun aynı argüman için farklı türleri desteklediği :c:func:"
#~ "`PyArg_ParseTuple` veya :c:func:`PyArg_ParseTupleAndKeywords` için birden "
#~ "fazla çağrısı varsa veya fonksiyon argümanlarını ayrıştırmak için "
#~ "PyArg_Parse fonksiyonları dışında bir şey kullanıyorsa, muhtemelen "
#~ "Argüman Kliniğine dönüştürmek için uygun değildir.  Argüman Kliniği genel "
#~ "fonksiyonları veya çok biçimli parametreleri desteklemez."

#, fuzzy
#~ msgid ""
#~ "Next, add the following boilerplate above the function, creating our "
#~ "input block::"
#~ msgstr ""
#~ "Bloğumuzu oluşturmak için fonksiyonun üzerine aşağıdaki şablonu ekleyin::"

#, fuzzy
#~ msgid ""
#~ "Cut the docstring and paste it in between the ``[clinic]`` lines, "
#~ "removing all the junk that makes it a properly quoted C string. When "
#~ "you're done you should have just the text, based at the left margin, with "
#~ "no line wider than 80 characters. Argument Clinic will preserve indents "
#~ "inside the docstring."
#~ msgstr ""
#~ "Doküman dizesini kesin ve ``[clinic]`` satırları arasına yapıştırın, "
#~ "düzgün bir şekilde alıntılanmış bir C dizesi haline getiren tüm gereksiz "
#~ "şeyleri kaldırın. İşiniz bittiğinde, 80 karakterden daha geniş bir satır "
#~ "olmadan, sol kenar boşluğuna dayalı olarak yalnızca metne sahip "
#~ "olmalısınız. (Argüman Kliniği, doküman dizesi içindeki girintileri "
#~ "koruyacaktır.)"

#, fuzzy
#~ msgid ""
#~ "If the old docstring had a first line that looked like a function "
#~ "signature, throw that line away; The docstring doesn't need it anymore "
#~ "--- when you use :py:func:`help` on your builtin in the future, the first "
#~ "line will be built automatically based on the function's signature."
#~ msgstr ""
#~ "Eğer eski dokümanda fonksiyon imzasına benzeyen bir ilk satır varsa, o "
#~ "satırı atın.  (Doküman dizesinin artık buna ihtiyacı yoktur - gelecekte "
#~ "yerleşik öğenizde ``help()`` kullandığınızda, ilk satır işlevin imzasına "
#~ "göre otomatik olarak oluşturulacaktır)."

#, fuzzy
#~ msgid ""
#~ "If your docstring doesn't have a \"summary\" line, Argument Clinic will "
#~ "complain, so let's make sure it has one.  The \"summary\" line should be "
#~ "a paragraph consisting of a single 80-column line at the beginning of the "
#~ "docstring. (See :pep:`257` regarding docstring conventions.)"
#~ msgstr ""
#~ "Eğer doküman dizinizde bir \"özet\" satırı yoksa Argüman Kliniği şikayet "
#~ "edecektir.  Bu yüzden bir tane olduğundan emin olalım.  \"Özet\" satırı, "
#~ "doküman dizesinin başında 80 sütunlu tek bir satırdan oluşan bir paragraf "
#~ "olmalıdır."

#, fuzzy
#~ msgid ""
#~ "Our example docstring consists solely of a summary line, so the sample "
#~ "code doesn't have to change for this step."
#~ msgstr ""
#~ "(Örnek doküman dizimiz yalnızca bir özet satırından oluşmaktadır, bu "
#~ "nedenle örnek kodun bu adım için değişmesi gerekmez.)"

#, fuzzy
#~ msgid ""
#~ "Now, above the docstring, enter the name of the function, followed by a "
#~ "blank line.  This should be the Python name of the function, and should "
#~ "be the full dotted path to the function --- it should start with the name "
#~ "of the module, include any sub-modules, and if the function is a method "
#~ "on a class it should include the class name too."
#~ msgstr ""
#~ "Döküman dizisinin üstüne fonksiyonun adını girin ve ardından boş bir "
#~ "satır ekleyin.  Bu, işlevin Python adı olmalı ve işlevin tam noktalı yolu "
#~ "olmalıdır - modülün adıyla başlamalı, tüm alt modülleri içermeli ve işlev "
#~ "bir sınıf üzerindeki bir yöntemse sınıf adını da içermelidir."

#, fuzzy
#~ msgid ""
#~ "If this is the first time that module or class has been used with "
#~ "Argument Clinic in this C file, you must declare the module and/or "
#~ "class.  Proper Argument Clinic hygiene prefers declaring these in a "
#~ "separate block somewhere near the top of the C file, in the same way that "
#~ "include files and statics go at the top. In our sample code we'll just "
#~ "show the two blocks next to each other."
#~ msgstr ""
#~ "Eğer bu modül veya sınıf bu C dosyasında Argüman Kliniği ile ilk kez "
#~ "kullanılıyorsa, modülü ve/veya sınıfı bildirmeniz gerekir.  Uygun Argüman "
#~ "Kliniği hijyeni, bunları C dosyasının üst kısmına yakın bir yerde ayrı "
#~ "bir blokta bildirmeyi tercih eder, aynı şekilde include dosyaları ve "
#~ "statikler de en üstte yer alır. (Örnek kodumuzda sadece iki bloğu yan "
#~ "yana göstereceğiz)."

#~ msgid ""
#~ "The name of the class and module should be the same as the one seen by "
#~ "Python.  Check the name defined in the :c:type:`PyModuleDef` or :c:type:"
#~ "`PyTypeObject` as appropriate."
#~ msgstr ""
#~ "Sınıfın ve modülün adı Python tarafından görülenle aynı olmalıdır. :c:"
#~ "type:`PyModuleDef` veya :c:type:`PyTypeObject` içinde tanımlanan ismi "
#~ "kontrol edin."

#, fuzzy
#~ msgid ""
#~ "When you declare a class, you must also specify two aspects of its type "
#~ "in C: the type declaration you'd use for a pointer to an instance of this "
#~ "class, and a pointer to the :c:type:`!PyTypeObject` for this class::"
#~ msgstr ""
#~ "Bir sınıfı bildirdiğinizde, C'deki türünün iki yönünü de belirtmeniz "
#~ "gerekir: bu sınıfın bir örneğine bir işaretçi için kullanacağınız tür "
#~ "bildirimi ve bu sınıf için :c:type:`PyTypeObject` işaretçisi."

#, fuzzy
#~ msgid ""
#~ "Declare each of the parameters to the function.  Each parameter should "
#~ "get its own line.  All the parameter lines should be indented from the "
#~ "function name and the docstring. The general form of these parameter "
#~ "lines is as follows:"
#~ msgstr ""
#~ "Her bir parametreyi fonksiyona ilan edin.  Her parametre kendi satırını "
#~ "almalıdır.  Tüm parametre satırları fonksiyon adından ve döküman "
#~ "dizisinden girintili olmalıdır."

#~ msgid "If the parameter has a default value, add that after the converter:"
#~ msgstr ""
#~ "Parametrenin varsayılan bir değeri varsa, bunu dönüştürücüden sonra "
#~ "ekleyin:"

#, fuzzy
#~ msgid ""
#~ "Argument Clinic's support for \"default values\" is quite sophisticated; "
#~ "see :ref:`clinic-howto-default-values` for more information."
#~ msgstr ""
#~ "Argüman Kliniğinin \"varsayılan değerler\" desteği oldukça karmaşıktır; "
#~ "daha fazla bilgi için lütfen :ref:`the section below on default values "
#~ "<default_values>` bölümüne bakın."

#, fuzzy
#~ msgid "Next, add a blank line below the parameters."
#~ msgstr "Parametrelerin altına boş bir satır ekleyin."

#, fuzzy
#~ msgid ""
#~ "What's a \"converter\"? It establishes both the type of the variable used "
#~ "in C, and the method to convert the Python value into a C value at "
#~ "runtime. For now you're going to use what's called a \"legacy converter\" "
#~ "--- a convenience syntax intended to make porting old code into Argument "
#~ "Clinic easier."
#~ msgstr ""
#~ "\"Dönüştürücü\" nedir?  Hem C'de kullanılan değişkenin türünü hem de "
#~ "Python değerini çalışma zamanında C değerine dönüştürme yöntemini "
#~ "belirler. Şimdilik \"eski dönüştürücü\" denilen şeyi kullanacaksınız - "
#~ "eski kodu Argüman Kliniği'ne taşımayı kolaylaştırmak için tasarlanmış bir "
#~ "kolaylık dizesi."

#, fuzzy
#~ msgid ""
#~ "For each parameter, copy the \"format unit\" for that parameter from the :"
#~ "c:func:`PyArg_Parse` format argument and specify *that* as its converter, "
#~ "as a quoted string. The \"format unit\" is the formal name for the one-to-"
#~ "three character substring of the *format* parameter that tells the "
#~ "argument parsing function what the type of the variable is and how to "
#~ "convert it. For more on format units please see :ref:`arg-parsing`."
#~ msgstr ""
#~ "Her parametre için, ``PyArg_Parse()`` format argümanından o parametrenin "
#~ "\"format birimini\" kopyalayın ve dönüştürücü olarak *bunu* tırnaklı bir "
#~ "dize olarak belirtin.  (\"format unit\", ``format`` parametresinin bir "
#~ "ila üç karakterlik alt dizesinin resmi adıdır ve argüman ayrıştırma "
#~ "fonksiyonuna değişkenin türünün ne olduğunu ve nasıl dönüştürüleceğini "
#~ "söyler.  Biçim birimleri hakkında daha fazla bilgi için lütfen :ref:`arg-"
#~ "parsing` bölümüne bakın)"

#~ msgid ""
#~ "For multicharacter format units like ``z#``, use the entire two-or-three "
#~ "character string."
#~ msgstr ""
#~ "``z#`` gibi çok karakterli format birimleri için iki veya üç karakterli "
#~ "dizenin tamamını kullanın."

#~ msgid "Sample::"
#~ msgstr "Örnek::"

#, fuzzy
#~ msgid ""
#~ "If your function has ``|`` in the format string, meaning some parameters "
#~ "have default values, you can ignore it. Argument Clinic infers which "
#~ "parameters are optional based on whether or not they have default values."
#~ msgstr ""
#~ "Eğer fonksiyonunuzun biçim dizesinde ``|`` varsa, yani bazı "
#~ "parametrelerin varsayılan değerleri varsa, bunu yok sayabilirsiniz.  "
#~ "Argüman Kliniği, varsayılan değerlere sahip olup olmadıklarına göre hangi "
#~ "parametrelerin isteğe bağlı olduğunu çıkarır."

#~ msgid ""
#~ "If your function has ``$`` in the format string, meaning it takes keyword-"
#~ "only arguments, specify ``*`` on a line by itself before the first "
#~ "keyword-only argument, indented the same as the parameter lines."
#~ msgstr ""
#~ "İşlevinizin biçim dizesinde ``$`` varsa, yani yalnızca anahtar "
#~ "sözcüklerden oluşan bağımsız değişkenler alıyorsa, ``*`` ifadesini "
#~ "yalnızca anahtar sözcüklerden oluşan ilk bağımsız değişkenden önce, "
#~ "parametre satırlarıyla aynı şekilde girintili olarak tek başına bir "
#~ "satırda belirtin."

#, fuzzy
#~ msgid ""
#~ ":py:meth:`!_pickle.Pickler.dump` has neither, so our sample is unchanged."
#~ msgstr ""
#~ "(``_pickle.Pickler.dump`` ikisine de sahip değildir, bu nedenle örneğimiz "
#~ "değişmemiştir.)"

#, fuzzy
#~ msgid ""
#~ "Next, if the existing C function calls :c:func:`PyArg_ParseTuple` (as "
#~ "opposed to :c:func:`PyArg_ParseTupleAndKeywords`), then all its arguments "
#~ "are positional-only."
#~ msgstr ""
#~ "Eğer mevcut C fonksiyonu :c:func:`PyArg_ParseTuple` (:c:func:"
#~ "`PyArg_ParseTupleAndKeywords` yerine) çağrısı yapıyorsa, tüm argümanları "
#~ "sadece konumsaldır."

#, fuzzy
#~ msgid ""
#~ "To mark parameters as positional-only in Argument Clinic, add a ``/`` on "
#~ "a line by itself after the last positional-only parameter, indented the "
#~ "same as the parameter lines."
#~ msgstr ""
#~ "Argüman Kliniğinde tüm parametreleri sadece konumsal olarak işaretlemek "
#~ "için, son parametreden sonra tek başına bir satıra parametre satırlarıyla "
#~ "aynı şekilde girintili bir ``/`` ekleyin."

#, fuzzy
#~ msgid ""
#~ "It can be helpful to write a per-parameter docstring for each parameter. "
#~ "Since per-parameter docstrings are optional, you can skip this step if "
#~ "you prefer."
#~ msgstr ""
#~ "Her parametre için parametre başına bir doküman yazmak faydalıdır. Ancak "
#~ "parametre başına dokümanlar isteğe bağlıdır; isterseniz bu adımı "
#~ "atlayabilirsiniz."

#, fuzzy
#~ msgid ""
#~ "Nevertheless, here's how to add a per-parameter docstring. The first line "
#~ "of the per-parameter docstring must be indented further than the "
#~ "parameter definition. The left margin of this first line establishes the "
#~ "left margin for the whole per-parameter docstring; all the text you write "
#~ "will be outdented by this amount. You can write as much text as you like, "
#~ "across multiple lines if you wish."
#~ msgstr ""
#~ "Parametre başına doküman dizisinin nasıl ekleneceği aşağıda "
#~ "açıklanmıştır.  Parametre başına doküman dizesinin ilk satırı parametre "
#~ "tanımından daha fazla girintili olmalıdır.  Bu ilk satırın sol kenar "
#~ "boşluğu, parametre başına doküman dizesinin tamamı için sol kenar "
#~ "boşluğunu belirler; yazdığınız tüm metin bu miktarda girintili "
#~ "olacaktır.  Dilerseniz birden fazla satıra istediğiniz kadar metin "
#~ "yazabilirsiniz."

#, fuzzy
#~ msgid ""
#~ "Save and close the file, then run ``Tools/clinic/clinic.py`` on it. With "
#~ "luck everything worked---your block now has output, and a :file:`.c.h` "
#~ "file has been generated! Reload the file in your text editor to see the "
#~ "generated code::"
#~ msgstr ""
#~ "Dosyayı kaydedin ve kapatın, ardından ``Tools/clinic/clinic.py`` "
#~ "dosyasını çalıştırın.  Şansınız varsa her şey işe yaradı--- bloğunuzun "
#~ "artık bir çıktısı var ve bir ``.c.h`` dosyası oluşturuldu! Görmek için "
#~ "dosyayı metin düzenleyicinizde yeniden açın::"

#, fuzzy
#~ msgid ""
#~ "Obviously, if Argument Clinic didn't produce any output, it's because it "
#~ "found an error in your input. Keep fixing your errors and retrying until "
#~ "Argument Clinic processes your file without complaint."
#~ msgstr ""
#~ "Açıkçası, Argüman Kliniği herhangi bir çıktı üretmediyse, bunun nedeni "
#~ "girdinizde bir hata bulmasıdır.  Argüman Kliniği dosyanızı şikayet "
#~ "etmeden işleyene kadar hatalarınızı düzeltmeye ve yeniden denemeye devam "
#~ "edin."

#, fuzzy
#~ msgid ""
#~ "For readability, most of the glue code has been generated to a :file:`.c."
#~ "h` file.  You'll need to include that in your original :file:`.c` file, "
#~ "typically right after the clinic module block::"
#~ msgstr ""
#~ "Okunabilirlik için, tutkal kodunun çoğu bir ``.c.h`` dosyasında "
#~ "oluşturulmuştur.  Bunu orijinal ``.c`` dosyanıza eklemeniz gerekir, tipik "
#~ "olarak klinik modül bloğundan hemen sonra::"

#~ msgid ""
#~ "Double-check that the argument-parsing code Argument Clinic generated "
#~ "looks basically the same as the existing code."
#~ msgstr ""
#~ "Argüman Kliniği'nin ürettiği argüman ayrıştırma kodunun temelde mevcut "
#~ "kodla aynı göründüğünü iki kez kontrol edin."

#~ msgid ""
#~ "First, ensure both places use the same argument-parsing function. The "
#~ "existing code must call either :c:func:`PyArg_ParseTuple` or :c:func:"
#~ "`PyArg_ParseTupleAndKeywords`; ensure that the code generated by Argument "
#~ "Clinic calls the *exact* same function."
#~ msgstr ""
#~ "İlk olarak, her iki yerin de aynı argüman ayrıştırma işlevini "
#~ "kullandığından emin olun. Mevcut kod :c:func:`PyArg_ParseTuple` veya :c:"
#~ "func:`PyArg_ParseTupleAndKeywords` fonksiyonlarından birini çağırmalıdır; "
#~ "Argüman Kliniği tarafından oluşturulan kodun *tam olarak* aynı fonksiyonu "
#~ "çağırdığından emin olun."

#, fuzzy
#~ msgid ""
#~ "Second, the format string passed in to :c:func:`!PyArg_ParseTuple` or :c:"
#~ "func:`!PyArg_ParseTupleAndKeywords` should be *exactly* the same as the "
#~ "hand-written one in the existing function, up to the colon or semi-colon."
#~ msgstr ""
#~ "İkinci olarak, :c:func:`PyArg_ParseTuple` veya :c:func:"
#~ "`PyArg_ParseTupleAndKeywords` işlevine aktarılan biçim dizesi, iki nokta "
#~ "üst üste veya noktalı virgülüne kadar mevcut işlevde elle yazılmış olanla "
#~ "*tam olarak* aynı olmalıdır."

#, fuzzy
#~ msgid ""
#~ "Argument Clinic always generates its format strings with a ``:`` followed "
#~ "by the name of the function. If the existing code's format string ends "
#~ "with ``;``, to provide usage help, this change is harmless --- don't "
#~ "worry about it."
#~ msgstr ""
#~ "(Argüman Kliniği, biçim dizelerini her zaman ``:`` ve ardından işlevin "
#~ "adı ile oluşturur.  Mevcut kodun biçim dizesi, kullanım yardımı sağlamak "
#~ "için ``;`` ile bitiyorsa, bu değişiklik zararsızdır - bu konuda "
#~ "endişelenmeyin)"

#, fuzzy
#~ msgid ""
#~ "Third, for parameters whose format units require two arguments, like a "
#~ "length variable, an encoding string, or a pointer to a conversion "
#~ "function, ensure that the second argument is *exactly* the same between "
#~ "the two invocations."
#~ msgstr ""
#~ "Üçüncü olarak, biçim birimleri iki bağımsız değişken gerektiren "
#~ "parametreler için (uzunluk değişkeni veya kodlama dizesi veya dönüştürme "
#~ "işlevine işaretçi gibi), ikinci bağımsız değişkenin iki çağırma arasında "
#~ "*tam olarak* aynı olduğundan emin olun."

#, fuzzy
#~ msgid ""
#~ "Fourth, inside the output portion of the block, you'll find a "
#~ "preprocessor macro defining the appropriate static :c:type:`PyMethodDef` "
#~ "structure for this builtin::"
#~ msgstr ""
#~ "Dördüncü olarak, bloğun çıktı kısmının içinde bu yerleşik: için uygun "
#~ "statik :c:type:`PyMethodDef` yapısını tanımlayan bir önişlemci makrosu "
#~ "bulacaksınız:"

#, fuzzy
#~ msgid ""
#~ "This static structure should be *exactly* the same as the existing "
#~ "static :c:type:`!PyMethodDef` structure for this builtin."
#~ msgstr ""
#~ "Bu statik yapı, bu yerleşik için mevcut statik :c:type:`PyMethodDef` "
#~ "yapısı ile *tam olarak* aynı olmalıdır."

#~ msgid ""
#~ "If any of these items differ in *any way*, adjust your Argument Clinic "
#~ "function specification and rerun ``Tools/clinic/clinic.py`` until they "
#~ "*are* the same."
#~ msgstr ""
#~ "Bu öğelerden herhangi biri *herhangi bir şekilde* farklıysa, Argüman "
#~ "Kliniği işlev belirtiminizi ayarlayın ve *aynı* olana kadar ``Tools/"
#~ "clinic/clinic.py`` dosyasını yeniden çalıştırın."

#~ msgid ""
#~ "Notice that the last line of its output is the declaration of your "
#~ "\"impl\" function.  This is where the builtin's implementation goes. "
#~ "Delete the existing prototype of the function you're modifying, but leave "
#~ "the opening curly brace.  Now delete its argument parsing code and the "
#~ "declarations of all the variables it dumps the arguments into. Notice how "
#~ "the Python arguments are now arguments to this impl function; if the "
#~ "implementation used different names for these variables, fix it."
#~ msgstr ""
#~ "Çıktısının son satırının \"impl\" fonksiyonunuzun bildirimi olduğuna "
#~ "dikkat edin.  Bu, yerleşik uygulamanın gittiği yerdir. Değiştirdiğiniz "
#~ "fonksiyonun mevcut prototipini silin, ancak açılış küme parantezini "
#~ "bırakın.  Şimdi argüman ayrıştırma kodunu ve argümanları içine attığı tüm "
#~ "değişkenlerin bildirimlerini silin. Python argümanlarının artık bu impl "
#~ "fonksiyonunun argümanları olduğuna dikkat edin; eğer uygulama bu "
#~ "değişkenler için farklı isimler kullandıysa, bunu düzeltin."

#, fuzzy
#~ msgid ""
#~ "Let's reiterate, just because it's kind of weird. Your code should now "
#~ "look like this::"
#~ msgstr ""
#~ "Biraz garip olduğu için tekrarlayalım.  Kodunuz şimdi şöyle görünmelidir::"

#, fuzzy
#~ msgid ""
#~ "Argument Clinic generated the checksum line and the function prototype "
#~ "just above it.  You should write the opening and closing curly braces for "
#~ "the function, and the implementation inside."
#~ msgstr ""
#~ "Argüman Kliniği sağlama toplamı satırını ve hemen üstünde fonksiyon "
#~ "prototipini oluşturdu.  Fonksiyonun açılış (ve kapanış) küme "
#~ "parantezlerini ve içindeki uygulamayı yazmalısınız."

#, fuzzy
#~ msgid ""
#~ "Remember the macro with the :c:type:`PyMethodDef` structure for this "
#~ "function? Find the existing :c:type:`!PyMethodDef` structure for this "
#~ "function and replace it with a reference to the macro.  If the builtin is "
#~ "at module scope, this will probably be very near the end of the file; if "
#~ "the builtin is a class method, this will probably be below but relatively "
#~ "near to the implementation."
#~ msgstr ""
#~ "Bu fonksiyon için :c:type:`PyMethodDef` yapısına sahip makroyu hatırlıyor "
#~ "musunuz?  Bu fonksiyon için mevcut :c:type:`PyMethodDef` yapısını bulun "
#~ "ve makroya bir referans ile değiştirin.  (Yerleşik modül kapsamındaysa, "
#~ "bu muhtemelen dosyanın sonuna çok yakın olacaktır; yerleşik bir sınıf "
#~ "yöntemiyse, bu muhtemelen uygulamanın altında ancak nispeten yakınında "
#~ "olacaktır)"

#, fuzzy
#~ msgid ""
#~ "Note that the body of the macro contains a trailing comma; when you "
#~ "replace the existing static :c:type:`!PyMethodDef` structure with the "
#~ "macro, *don't* add a comma to the end."
#~ msgstr ""
#~ "Makronun gövdesinin sonda bir virgül içerdiğine dikkat edin.  Bu nedenle, "
#~ "mevcut statik :c:type:`PyMethodDef` yapısını makro ile değiştirdiğinizde, "
#~ "*sonuna virgül eklemeyin*."

#, fuzzy
#~ msgid ""
#~ "Finally, compile, then run the relevant portions of the regression-test "
#~ "suite. This change should not introduce any new compile-time warnings or "
#~ "errors, and there should be no externally visible change to Python's "
#~ "behavior, except for one difference: :py:func:`inspect.signature` run on "
#~ "your function should now provide a valid signature!"
#~ msgstr ""
#~ "Derleyin, ardından regresyon testi paketinin ilgili bölümlerini "
#~ "çalıştırın. Bu değişiklik herhangi bir yeni derleme zamanı uyarısı veya "
#~ "hatası getirmemeli ve Python'un davranışında dışarıdan görülebilir bir "
#~ "değişiklik olmamalıdır."

#~ msgid ""
#~ "Congratulations, you've ported your first function to work with Argument "
#~ "Clinic!"
#~ msgstr ""
#~ "Tebrikler, ilk fonksiyonunuzu Argüman Kliniği ile çalışmak üzere "
#~ "taşıdınız!"

#, fuzzy
#~ msgid "How to rename C functions and variables generated by Argument Clinic"
#~ msgstr ""
#~ "Argüman Kliniği tarafından oluşturulan C işlevlerini ve değişkenlerini "
#~ "yeniden adlandırma"

#~ msgid ""
#~ "Argument Clinic automatically names the functions it generates for you. "
#~ "Occasionally this may cause a problem, if the generated name collides "
#~ "with the name of an existing C function.  There's an easy solution: "
#~ "override the names used for the C functions.  Just add the keyword "
#~ "``\"as\"`` to your function declaration line, followed by the function "
#~ "name you wish to use. Argument Clinic will use that function name for the "
#~ "base (generated) function, then add ``\"_impl\"`` to the end and use that "
#~ "for the name of the impl function."
#~ msgstr ""
#~ "Argüman Kliniği sizin için ürettiği fonksiyonlara otomatik olarak isim "
#~ "verir. Bazen, oluşturulan ad mevcut bir C işlevinin adıyla çakışırsa bu "
#~ "bir soruna neden olabilir.  Bunun kolay bir çözümü vardır: C "
#~ "fonksiyonları için kullanılan isimleri geçersiz kılın.  Fonksiyon "
#~ "bildirim satırınıza ``\"as\"`` anahtar sözcüğünü ve ardından kullanmak "
#~ "istediğiniz fonksiyon adını eklemeniz yeterlidir. Argument Clinic, temel "
#~ "(oluşturulan) işlev için bu işlev adını kullanacak, ardından sonuna "
#~ "``\"_impl\"`` ekleyecek ve impl işlevinin adı için bunu kullanacaktır."

#, fuzzy
#~ msgid ""
#~ "For example, if we wanted to rename the C function names generated for :"
#~ "py:meth:`pickle.Pickler.dump`, it'd look like this::"
#~ msgstr ""
#~ "Örneğin, ``pickle.Pickler.dump`` için oluşturulan C fonksiyon adlarını "
#~ "yeniden adlandırmak istersek, şöyle görünecektir::"

#, fuzzy
#~ msgid ""
#~ "The base function would now be named :c:func:`!pickler_dumper`, and the "
#~ "impl function would now be named :c:func:`!pickler_dumper_impl`."
#~ msgstr ""
#~ "Temel işlev artık ``pickler_dumper()`` olarak adlandırılacak ve impl "
#~ "işlevi artık ``pickler_dumper_impl()`` olarak adlandırılacaktır."

#~ msgid ""
#~ "Similarly, you may have a problem where you want to give a parameter a "
#~ "specific Python name, but that name may be inconvenient in C.  Argument "
#~ "Clinic allows you to give a parameter different names in Python and in C, "
#~ "using the same ``\"as\"`` syntax::"
#~ msgstr ""
#~ "Benzer şekilde, bir parametreye belirli bir Python adı vermek "
#~ "istediğinizde bir sorunla karşılaşabilirsiniz, ancak bu ad C'de uygun "
#~ "olmayabilir. Argument Clinic, aynı ``\"as\"`` sözdizimini kullanarak bir "
#~ "parametreye Python'da ve C'de farklı adlar vermenize olanak tanır::"

#, fuzzy
#~ msgid ""
#~ "Here, the name used in Python (in the signature and the ``keywords`` "
#~ "array) would be *file*, but the C variable would be named ``file_obj``."
#~ msgstr ""
#~ "Burada, Python'da kullanılan isim (imzada ve ``keywords`` dizisinde) "
#~ "``file`` olacaktır, ancak C değişkeni ``file_obj`` olarak "
#~ "adlandırılacaktır."

#, fuzzy
#~ msgid "You can use this to rename the *self* parameter too!"
#~ msgstr ""
#~ "Bunu ``self`` parametresini yeniden adlandırmak için de kullanabilirsiniz!"

#, fuzzy
#~ msgid "How to convert functions using ``PyArg_UnpackTuple``"
#~ msgstr "PyArg_UnpackTuple kullanarak fonksiyonları dönüştürme"

#, fuzzy
#~ msgid ""
#~ "To convert a function parsing its arguments with :c:func:"
#~ "`PyArg_UnpackTuple`, simply write out all the arguments, specifying each "
#~ "as an ``object``.  You may specify the *type* argument to cast the type "
#~ "as appropriate.  All arguments should be marked positional-only (add a ``/"
#~ "`` on a line by itself after the last argument)."
#~ msgstr ""
#~ "Argümanlarını :c:func:`PyArg_UnpackTuple` ile ayrıştıran bir fonksiyonu "
#~ "dönüştürmek için, her birini bir ``object`` olarak belirterek tüm "
#~ "argümanları yazmanız yeterlidir.  Türü uygun şekilde dökmek için ``type`` "
#~ "argümanını belirtebilirsiniz.  Tüm argümanlar sadece konumsal olarak "
#~ "işaretlenmelidir (son argümandan sonra kendi başına bir satıra ``/`` "
#~ "ekleyin)."

#~ msgid ""
#~ "Currently the generated code will use :c:func:`PyArg_ParseTuple`, but "
#~ "this will change soon."
#~ msgstr ""
#~ "Şu anda oluşturulan kod :c:func:`PyArg_ParseTuple` kullanacaktır, ancak "
#~ "bu yakında değişecektir."

#, fuzzy
#~ msgid "How to use optional groups"
#~ msgstr "İsteğe Bağlı Gruplar"

#~ msgid ""
#~ "Some legacy functions have a tricky approach to parsing their arguments: "
#~ "they count the number of positional arguments, then use a ``switch`` "
#~ "statement to call one of several different :c:func:`PyArg_ParseTuple` "
#~ "calls depending on how many positional arguments there are.  (These "
#~ "functions cannot accept keyword-only arguments.)  This approach was used "
#~ "to simulate optional arguments back before :c:func:"
#~ "`PyArg_ParseTupleAndKeywords` was created."
#~ msgstr ""
#~ "Bazı eski fonksiyonların argümanlarını ayrıştırmak için zor bir yaklaşımı "
#~ "vardır: konumsal argümanların sayısını sayarlar, ardından kaç tane "
#~ "konumsal argüman olduğuna bağlı olarak birkaç farklı :c:func:"
#~ "`PyArg_ParseTuple` çağrısından birini çağırmak için bir ``switch`` deyimi "
#~ "kullanırlar.  (Bu fonksiyonlar sadece anahtar kelime argümanlarını kabul "
#~ "edemez.) Bu yaklaşım :c:func:`PyArg_ParseTupleAndKeywords` oluşturulmadan "
#~ "önce isteğe bağlı argümanları simüle etmek için kullanılıyordu."

#, fuzzy
#~ msgid ""
#~ "While functions using this approach can often be converted to use :c:func:"
#~ "`!PyArg_ParseTupleAndKeywords`, optional arguments, and default values, "
#~ "it's not always possible.  Some of these legacy functions have behaviors :"
#~ "c:func:`!PyArg_ParseTupleAndKeywords` doesn't directly support. The most "
#~ "obvious example is the builtin function :py:func:`range`, which has an "
#~ "optional argument on the *left* side of its required argument! Another "
#~ "example is :py:meth:`curses.window.addch`, which has a group of two "
#~ "arguments that must always be specified together.  (The arguments are "
#~ "called *x* and *y*; if you call the function passing in *x*, you must "
#~ "also pass in *y* — and if you don't pass in *x* you may not pass in *y* "
#~ "either.)"
#~ msgstr ""
#~ "Bu yaklaşımı kullanan fonksiyonlar genellikle :c:func:"
#~ "`PyArg_ParseTupleAndKeywords`, isteğe bağlı argümanlar ve varsayılan "
#~ "değerleri kullanacak şekilde dönüştürülebilse de, bu her zaman mümkün "
#~ "değildir.  Bu eski fonksiyonlardan bazıları :c:func:"
#~ "`PyArg_ParseTupleAndKeywords` fonksiyonunun doğrudan desteklemediği "
#~ "davranışlara sahiptir. En bariz örnek, gerekli argümanının *sol* "
#~ "tarafında isteğe bağlı bir argümana sahip olan yerleşik ``range()`` "
#~ "fonksiyonudur! Diğer bir örnek ise her zaman birlikte belirtilmesi "
#~ "gereken iki argümandan oluşan bir gruba sahip olan ``curses.window."
#~ "addch()`` fonksiyonudur.  (Argümanlar ``x`` ve ``y`` olarak adlandırılır; "
#~ "fonksiyonu ``x`` değerini girerek çağırırsanız, ``y`` değerini de "
#~ "girmeniz gerekir ve ``x`` değerini girmezseniz ``y`` değerini de "
#~ "giremezsiniz)"

#~ msgid ""
#~ "In any case, the goal of Argument Clinic is to support argument parsing "
#~ "for all existing CPython builtins without changing their semantics. "
#~ "Therefore Argument Clinic supports this alternate approach to parsing, "
#~ "using what are called *optional groups*. Optional groups are groups of "
#~ "arguments that must all be passed in together. They can be to the left or "
#~ "the right of the required arguments.  They can *only* be used with "
#~ "positional-only parameters."
#~ msgstr ""
#~ "Her durumda, Argüman Kliniği'nin amacı, anlamlarını değiştirmeden mevcut "
#~ "tüm CPython yerleşik bileşenleri için argüman ayrıştırmayı "
#~ "desteklemektir. Bu nedenle Argüman Kliniği *isteğe bağlı gruplar* olarak "
#~ "adlandırılan bu alternatif ayrıştırma yaklaşımını destekler. İsteğe bağlı "
#~ "gruplar, hepsi birlikte geçirilmesi gereken argüman gruplarıdır. Gerekli "
#~ "argümanların sağında veya solunda olabilirler.  Yalnızca *konumsal* "
#~ "parametrelerle kullanılabilirler."

#~ msgid ""
#~ "Optional groups are *only* intended for use when converting functions "
#~ "that make multiple calls to :c:func:`PyArg_ParseTuple`! Functions that "
#~ "use *any* other approach for parsing arguments should *almost never* be "
#~ "converted to Argument Clinic using optional groups.  Functions using "
#~ "optional groups currently cannot have accurate signatures in Python, "
#~ "because Python just doesn't understand the concept.  Please avoid using "
#~ "optional groups wherever possible."
#~ msgstr ""
#~ "İsteğe bağlı gruplar *sadece* :c:func:`PyArg_ParseTuple`'a birden fazla "
#~ "çağrı yapan fonksiyonları dönüştürürken kullanılmak üzere tasarlanmıştır! "
#~ "Argümanları ayrıştırmak için *herhangi* bir başka yaklaşım kullanan "
#~ "fonksiyonlar *neredeyse hiçbir zaman* isteğe bağlı gruplar kullanılarak "
#~ "Argüman Kliniğine dönüştürülmemelidir.  İsteğe bağlı gruplar kullanan "
#~ "fonksiyonlar şu anda Python'da doğru imzalara sahip olamaz, çünkü Python "
#~ "bu kavramı anlamıyor.  Lütfen mümkün olan her yerde isteğe bağlı grupları "
#~ "kullanmaktan kaçının."

#, fuzzy
#~ msgid ""
#~ "To specify an optional group, add a ``[`` on a line by itself before the "
#~ "parameters you wish to group together, and a ``]`` on a line by itself "
#~ "after these parameters.  As an example, here's how :py:meth:`curses."
#~ "window.addch` uses optional groups to make the first two parameters and "
#~ "the last parameter optional::"
#~ msgstr ""
#~ "İsteğe bağlı bir grup belirtmek için, birlikte gruplamak istediğiniz "
#~ "parametrelerden önce tek başına bir satıra ``[`` ve bu parametrelerden "
#~ "sonra tek başına bir satıra ``]`` ekleyin.  Örnek olarak, ``curses.window."
#~ "addch`` ilk iki parametreyi ve son parametreyi isteğe bağlı yapmak için "
#~ "isteğe bağlı grupları nasıl kullanır::"

#~ msgid "Notes:"
#~ msgstr "Notlar:"

#~ msgid ""
#~ "For every optional group, one additional parameter will be passed into "
#~ "the impl function representing the group.  The parameter will be an int "
#~ "named ``group_{direction}_{number}``, where ``{direction}`` is either "
#~ "``right`` or ``left`` depending on whether the group is before or after "
#~ "the required parameters, and ``{number}`` is a monotonically increasing "
#~ "number (starting at 1) indicating how far away the group is from the "
#~ "required parameters.  When the impl is called, this parameter will be set "
#~ "to zero if this group was unused, and set to non-zero if this group was "
#~ "used. (By used or unused, I mean whether or not the parameters received "
#~ "arguments in this invocation.)"
#~ msgstr ""
#~ "Her isteğe bağlı grup için, grubu temsil eden impl fonksiyonuna bir ek "
#~ "parametre aktarılacaktır.  Parametre ``group_{direction}_{number}`` "
#~ "adında bir int olacaktır; burada ``{direction}`` grubun gerekli "
#~ "parametrelerden önce veya sonra olmasına bağlı olarak ``right`` veya "
#~ "``left`` şeklindedir ve ``{number}`` grubun gerekli parametrelerden ne "
#~ "kadar uzakta olduğunu gösteren monoton olarak artan bir sayıdır (1'den "
#~ "başlayarak).  impl çağrıldığında, bu parametre, bu grup kullanılmamışsa "
#~ "sıfıra, bu grup kullanılmışsa sıfır olmayana ayarlanacaktır. (Kullanılmış "
#~ "veya kullanılmamış derken, parametrelerin bu çağrıda argüman alıp "
#~ "almadığını kastediyorum.)"

#~ msgid ""
#~ "If there are no required arguments, the optional groups will behave as if "
#~ "they're to the right of the required arguments."
#~ msgstr ""
#~ "Gerekli argümanlar yoksa, isteğe bağlı gruplar gerekli argümanların "
#~ "sağındaymış gibi davranacaktır."

#~ msgid ""
#~ "In the case of ambiguity, the argument parsing code favors parameters on "
#~ "the left (before the required parameters)."
#~ msgstr ""
#~ "Belirsizlik durumunda, argüman ayrıştırma kodu soldaki parametreleri "
#~ "(gerekli parametrelerden önce) tercih eder."

#~ msgid "Optional groups can only contain positional-only parameters."
#~ msgstr "İsteğe bağlı gruplar yalnızca konumsal parametreler içerebilir."

#~ msgid ""
#~ "Optional groups are *only* intended for legacy code.  Please do not use "
#~ "optional groups for new code."
#~ msgstr ""
#~ "İsteğe bağlı gruplar *sadece* eski kod için tasarlanmıştır.  Lütfen yeni "
#~ "kod için isteğe bağlı grupları kullanmayın."

#, fuzzy
#~ msgid ""
#~ "How to use real Argument Clinic converters, instead of \"legacy "
#~ "converters\""
#~ msgstr ""
#~ "\"Eski dönüştürücüler\" yerine gerçek Argüman Kliniği dönüştürücülerinin "
#~ "kullanılması"

#~ msgid ""
#~ "To save time, and to minimize how much you need to learn to achieve your "
#~ "first port to Argument Clinic, the walkthrough above tells you to use "
#~ "\"legacy converters\".  \"Legacy converters\" are a convenience, designed "
#~ "explicitly to make porting existing code to Argument Clinic easier.  And "
#~ "to be clear, their use is acceptable when porting code for Python 3.4."
#~ msgstr ""
#~ "Zamandan tasarruf etmek ve Argüman Kliniğine ilk portunuzu "
#~ "gerçekleştirmek için ne kadar çok şey öğrenmeniz gerektiğini en aza "
#~ "indirmek için, yukarıdaki kılavuz size \"eski dönüştürücüleri\" "
#~ "kullanmanızı söyler.  \"Eski dönüştürücüler\", mevcut kodun Argüman "
#~ "Kliniği'ne taşınmasını kolaylaştırmak için tasarlanmış bir kolaylıktır.  "
#~ "Ve açık olmak gerekirse, Python 3.4 için kod taşırken kullanımları kabul "
#~ "edilebilir."

#~ msgid ""
#~ "However, in the long term we probably want all our blocks to use Argument "
#~ "Clinic's real syntax for converters.  Why?  A couple reasons:"
#~ msgstr ""
#~ "Ancak, uzun vadede muhtemelen tüm bloklarımızın Argüman Kliniği'nin "
#~ "dönüştürücüler için gerçek sözdizimini kullanmasını istiyoruz.  Neden "
#~ "mi?  Birkaç nedeni var:"

#~ msgid ""
#~ "The proper converters are far easier to read and clearer in their intent."
#~ msgstr ""
#~ "Uygun dönüştürücülerin okunması çok daha kolay ve amaçları daha nettir."

#~ msgid ""
#~ "There are some format units that are unsupported as \"legacy "
#~ "converters\", because they require arguments, and the legacy converter "
#~ "syntax doesn't support specifying arguments."
#~ msgstr ""
#~ "\"Eski dönüştürücüler\" olarak desteklenmeyen bazı biçim birimleri "
#~ "vardır, çünkü bunlar argüman gerektirir ve eski dönüştürücü sözdizimi "
#~ "argüman belirtmeyi desteklemez."

#~ msgid ""
#~ "In the future we may have a new argument parsing library that isn't "
#~ "restricted to what :c:func:`PyArg_ParseTuple` supports; this flexibility "
#~ "won't be available to parameters using legacy converters."
#~ msgstr ""
#~ "Gelecekte :c:func:`PyArg_ParseTuple`'ın desteklediğiyle sınırlı olmayan "
#~ "yeni bir argüman ayrıştırma kütüphanemiz olabilir; bu esneklik eski "
#~ "dönüştürücüleri kullanan parametreler için mevcut olmayacaktır."

#~ msgid ""
#~ "Therefore, if you don't mind a little extra effort, please use the normal "
#~ "converters instead of legacy converters."
#~ msgstr ""
#~ "Bu nedenle, biraz fazladan çaba harcamaktan çekinmiyorsanız, lütfen eski "
#~ "dönüştürücüler yerine normal dönüştürücüleri kullanın."

#~ msgid ""
#~ "In a nutshell, the syntax for Argument Clinic (non-legacy) converters "
#~ "looks like a Python function call.  However, if there are no explicit "
#~ "arguments to the function (all functions take their default values), you "
#~ "may omit the parentheses.  Thus ``bool`` and ``bool()`` are exactly the "
#~ "same converters."
#~ msgstr ""
#~ "Özetle, Argüman Kliniği (eski olmayan) dönüştürücüler için sözdizimi bir "
#~ "Python işlev çağrısı gibi görünür.  Ancak, fonksiyon için açık bir "
#~ "argüman yoksa (tüm fonksiyonlar varsayılan değerlerini alır), "
#~ "parantezleri atlayabilirsiniz.  Böylece ``bool`` ve ``bool()`` tamamen "
#~ "aynı dönüştürücülerdir."

#~ msgid ""
#~ "All arguments to Argument Clinic converters are keyword-only. All "
#~ "Argument Clinic converters accept the following arguments:"
#~ msgstr ""
#~ "Argüman Kliniği dönüştürücülerinin tüm bağımsız değişkenleri yalnızca "
#~ "anahtar sözcüktür. Tüm Argüman Kliniği dönüştürücüleri aşağıdaki bağımsız "
#~ "değişkenleri kabul eder:"

#, fuzzy
#~ msgid "*c_default*"
#~ msgstr "``c_default``"

#~ msgid ""
#~ "The default value for this parameter when defined in C. Specifically, "
#~ "this will be the initializer for the variable declared in the \"parse "
#~ "function\".  See :ref:`the section on default values <default_values>` "
#~ "for how to use this. Specified as a string."
#~ msgstr ""
#~ "C'de tanımlandığında bu parametre için varsayılan değer. Özellikle, bu "
#~ "\"parse fonksiyonu\" içinde bildirilen değişken için başlatıcı "
#~ "olacaktır.  Bunun nasıl kullanılacağını öğrenmek için :ref:`varsayılan "
#~ "değerler <default_values>` bölümüne bakınız. Bir dize olarak belirtilir."

#, fuzzy
#~ msgid "*annotation*"
#~ msgstr "``annotation``"

#~ msgid ""
#~ "The annotation value for this parameter.  Not currently supported, "
#~ "because :pep:`8` mandates that the Python library may not use annotations."
#~ msgstr ""
#~ "Bu parametre için ek açıklama değeri.  Şu anda desteklenmemektedir, "
#~ "çünkü :pep:`8` Python kütüphanesinin ek açıklamaları kullanamayacağını "
#~ "belirtmektedir."

#~ msgid ""
#~ "In addition, some converters accept additional arguments.  Here is a list "
#~ "of these arguments, along with their meanings:"
#~ msgstr ""
#~ "Buna ek olarak, bazı dönüştürücüler ek bağımsız değişkenler kabul eder.  "
#~ "İşte anlamlarıyla birlikte bu bağımsız değişkenlerin bir listesi:"

#, fuzzy
#~ msgid "*accept*"
#~ msgstr "``accept``"

#~ msgid ""
#~ "A set of Python types (and possibly pseudo-types); this restricts the "
#~ "allowable Python argument to values of these types. (This is not a "
#~ "general-purpose facility; as a rule it only supports specific lists of "
#~ "types as shown in the legacy converter table.)"
#~ msgstr ""
#~ "Bir Python türleri (ve muhtemelen sözde türler) kümesi; bu, izin verilen "
#~ "Python argümanını bu türlerin değerleriyle sınırlar. (Bu genel amaçlı bir "
#~ "olanak değildir; kural olarak yalnızca eski dönüştürücü tablosunda "
#~ "gösterilen belirli tür listelerini destekler)."

#~ msgid "To accept ``None``, add ``NoneType`` to this set."
#~ msgstr "``None`` kabul etmek için bu kümeye ``NoneType`` ekleyin."

#, fuzzy
#~ msgid "*bitwise*"
#~ msgstr "``bitwise``"

#~ msgid ""
#~ "Only supported for unsigned integers.  The native integer value of this "
#~ "Python argument will be written to the parameter without any range "
#~ "checking, even for negative values."
#~ msgstr ""
#~ "Yalnızca işaretsiz tamsayılar için desteklenir.  Bu Python argümanının "
#~ "doğal tamsayı değeri, negatif değerler için bile herhangi bir aralık "
#~ "kontrolü yapılmadan parametreye yazılacaktır."

#, fuzzy
#~ msgid "*converter*"
#~ msgstr "``converter``"

#~ msgid ""
#~ "Only supported by the ``object`` converter.  Specifies the name of a :ref:"
#~ "`C \"converter function\" <o_ampersand>` to use to convert this object to "
#~ "a native type."
#~ msgstr ""
#~ "Sadece ``object`` dönüştürücü tarafından desteklenir.  Bu nesneyi yerel "
#~ "bir türe dönüştürmek için kullanılacak :ref:`C \"converter function\" "
#~ "<o_ampersand>` adını belirtir."

#, fuzzy
#~ msgid "*encoding*"
#~ msgstr "``encoding``"

#~ msgid ""
#~ "Only supported for strings.  Specifies the encoding to use when "
#~ "converting this string from a Python str (Unicode) value into a C ``char "
#~ "*`` value."
#~ msgstr ""
#~ "Yalnızca dizeler için desteklenir.  Bu dizeyi bir Python str (Unicode) "
#~ "değerinden bir C ``char *`` değerine dönüştürürken kullanılacak kodlamayı "
#~ "belirtir."

#, fuzzy
#~ msgid "*subclass_of*"
#~ msgstr "``subclass_of``"

#~ msgid ""
#~ "Only supported for the ``object`` converter.  Requires that the Python "
#~ "value be a subclass of a Python type, as expressed in C."
#~ msgstr ""
#~ "Yalnızca ``object`` dönüştürücü için desteklenir.  Python değerinin C'de "
#~ "ifade edildiği gibi bir Python türünün alt sınıfı olmasını gerektirir."

#~ msgid ""
#~ "Only supported for the ``object`` and ``self`` converters.  Specifies the "
#~ "C type that will be used to declare the variable.  Default value is "
#~ "``\"PyObject *\"``."
#~ msgstr ""
#~ "Sadece ``object`` ve ``self`` dönüştürücüleri için desteklenir.  "
#~ "Değişkeni bildirmek için kullanılacak C türünü belirtir.  Varsayılan "
#~ "değer ``\"PyObject *\"`` şeklindedir."

#, fuzzy
#~ msgid "*zeroes*"
#~ msgstr "``zeroes``"

#~ msgid ""
#~ "Only supported for strings.  If true, embedded NUL bytes (``'\\\\0'``) "
#~ "are permitted inside the value.  The length of the string will be passed "
#~ "in to the impl function, just after the string parameter, as a parameter "
#~ "named ``<parameter_name>_length``."
#~ msgstr ""
#~ "Yalnızca dizeler için desteklenir.  Eğer true ise, değerin içinde gömülü "
#~ "NUL baytlarına (``'\\\\0'``) izin verilir.  Dizenin uzunluğu impl "
#~ "fonksiyonuna, dize parametresinden hemen sonra, "
#~ "``<parameter_name>_length`` adlı bir parametre olarak aktarılır."

#, fuzzy
#~ msgid ""
#~ "Please note, not every possible combination of arguments will work. "
#~ "Usually these arguments are implemented by specific :c:func:"
#~ "`PyArg_ParseTuple` *format units*, with specific behavior.  For example, "
#~ "currently you cannot call ``unsigned_short`` without also specifying "
#~ "``bitwise=True``. Although it's perfectly reasonable to think this would "
#~ "work, these semantics don't map to any existing format unit.  So Argument "
#~ "Clinic doesn't support it.  (Or, at least, not yet.)"
#~ msgstr ""
#~ "Lütfen her olası argüman kombinasyonunun çalışmayacağını unutmayın. "
#~ "Genellikle bu argümanlar belirli davranışlara sahip belirli "
#~ "``PyArg_ParseTuple`` *format birimleri* tarafından uygulanır.  Örneğin, "
#~ "şu anda ``bitwise=True`` belirtmeden ``unsigned_short`` çağıramazsınız. "
#~ "Bunun işe yarayacağını düşünmek tamamen mantıklı olsa da, bu anlamlar "
#~ "mevcut herhangi bir biçim birimiyle eşleşmez.  Bu yüzden Argüman Kliniği "
#~ "bunu desteklemez.  (Ya da, en azından, henüz değil.)"

#~ msgid ""
#~ "Below is a table showing the mapping of legacy converters into real "
#~ "Argument Clinic converters.  On the left is the legacy converter, on the "
#~ "right is the text you'd replace it with."
#~ msgstr ""
#~ "Aşağıda, eski dönüştürücülerin gerçek Argüman Kliniği dönüştürücülerine "
#~ "eşlenmesini gösteren bir tablo bulunmaktadır.  Solda eski dönüştürücü, "
#~ "sağda ise onu değiştireceğiniz metin yer almaktadır."

#~ msgid "``'B'``"
#~ msgstr "``'B'``"

#~ msgid "``unsigned_char(bitwise=True)``"
#~ msgstr "``unsigned_char(bitwise=True)``"

#~ msgid "``'b'``"
#~ msgstr "``'b'``"

#~ msgid "``unsigned_char``"
#~ msgstr "``unsigned_char``"

#~ msgid "``'c'``"
#~ msgstr "``'c'``"

#~ msgid "``char``"
#~ msgstr "``char``"

#~ msgid "``'C'``"
#~ msgstr "``'C'``"

#~ msgid "``int(accept={str})``"
#~ msgstr "``int(accept={str})``"

#~ msgid "``'d'``"
#~ msgstr "``'d'``"

#~ msgid "``double``"
#~ msgstr "``double``"

#~ msgid "``'D'``"
#~ msgstr "``'D'``"

#~ msgid "``Py_complex``"
#~ msgstr "``Py_complex``"

#~ msgid "``'es'``"
#~ msgstr "``'es'``"

#~ msgid "``str(encoding='name_of_encoding')``"
#~ msgstr "``str(encoding='name_of_encoding')``"

#~ msgid "``'es#'``"
#~ msgstr "``'es#'``"

#~ msgid "``str(encoding='name_of_encoding', zeroes=True)``"
#~ msgstr "``str(encoding='name_of_encoding', zeroes=True)``"

#~ msgid "``'et'``"
#~ msgstr "``'et'``"

#~ msgid "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"
#~ msgstr ""
#~ "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"

#~ msgid "``'et#'``"
#~ msgstr "``'et#'``"

#~ msgid ""
#~ "``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
#~ "zeroes=True)``"
#~ msgstr ""
#~ "``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
#~ "zeroes=True)``"

#~ msgid "``'f'``"
#~ msgstr "``'f'``"

#~ msgid "``float``"
#~ msgstr "``float``"

#~ msgid "``'h'``"
#~ msgstr "``'h'``"

#~ msgid "``short``"
#~ msgstr "``short``"

#~ msgid "``'H'``"
#~ msgstr "``'H'``"

#~ msgid "``unsigned_short(bitwise=True)``"
#~ msgstr "``unsigned_short(bitwise=True)``"

#~ msgid "``'i'``"
#~ msgstr "``'i'``"

#~ msgid "``int``"
#~ msgstr "``int``"

#~ msgid "``'I'``"
#~ msgstr "``'I'``"

#~ msgid "``unsigned_int(bitwise=True)``"
#~ msgstr "``unsigned_int(bitwise=True)``"

#~ msgid "``'k'``"
#~ msgstr "``'k'``"

#~ msgid "``unsigned_long(bitwise=True)``"
#~ msgstr "``unsigned_long(bitwise=True)``"

#~ msgid "``'K'``"
#~ msgstr "``'K'``"

#~ msgid "``unsigned_long_long(bitwise=True)``"
#~ msgstr "``unsigned_long_long(bitwise=True)``"

#~ msgid "``'l'``"
#~ msgstr "``'l'``"

#~ msgid "``long``"
#~ msgstr "``long``"

#~ msgid "``'L'``"
#~ msgstr "``'L'``"

#~ msgid "``long long``"
#~ msgstr "``long long``"

#~ msgid "``'n'``"
#~ msgstr "``'n'``"

#~ msgid "``Py_ssize_t``"
#~ msgstr "``Py_ssize_t``"

#~ msgid "``'O'``"
#~ msgstr "``'O'``"

#~ msgid "``object``"
#~ msgstr "``object``"

#~ msgid "``'O!'``"
#~ msgstr "``'O!'``"

#~ msgid "``object(subclass_of='&PySomething_Type')``"
#~ msgstr "``object(subclass_of='&PySomething_Type')``"

#~ msgid "``'O&'``"
#~ msgstr "``'O&'``"

#~ msgid "``object(converter='name_of_c_function')``"
#~ msgstr "``object(converter='name_of_c_function')``"

#~ msgid "``'p'``"
#~ msgstr "``'p'``"

#~ msgid "``bool``"
#~ msgstr "``bool``"

#~ msgid "``'S'``"
#~ msgstr "``'S'``"

#~ msgid "``PyBytesObject``"
#~ msgstr "``PyBytesObject``"

#~ msgid "``'s'``"
#~ msgstr "``'s'``"

#~ msgid "``str``"
#~ msgstr "``str``"

#~ msgid "``'s#'``"
#~ msgstr "``'s#'``"

#~ msgid "``str(zeroes=True)``"
#~ msgstr "``str(zeroes=True)``"

#~ msgid "``'s*'``"
#~ msgstr "``'s*'``"

#~ msgid "``Py_buffer(accept={buffer, str})``"
#~ msgstr "``Py_buffer(accept={buffer, str})``"

#~ msgid "``'U'``"
#~ msgstr "``'U'``"

#~ msgid "``unicode``"
#~ msgstr "``unicode``"

#~ msgid "``'u'``"
#~ msgstr "``'u'``"

#, fuzzy
#~ msgid "``wchar_t``"
#~ msgstr "``char``"

#~ msgid "``'u#'``"
#~ msgstr "``'u#'``"

#, fuzzy
#~ msgid "``wchar_t(zeroes=True)``"
#~ msgstr "``str(zeroes=True)``"

#~ msgid "``'w*'``"
#~ msgstr "``'w*'``"

#~ msgid "``Py_buffer(accept={rwbuffer})``"
#~ msgstr "``Py_buffer(accept={rwbuffer})``"

#~ msgid "``'Y'``"
#~ msgstr "``'Y'``"

#~ msgid "``PyByteArrayObject``"
#~ msgstr "``PyByteArrayObject``"

#~ msgid "``'y'``"
#~ msgstr "``'y'``"

#~ msgid "``str(accept={bytes})``"
#~ msgstr "``str(accept={bytes})``"

#~ msgid "``'y#'``"
#~ msgstr "``'y#'``"

#~ msgid "``str(accept={robuffer}, zeroes=True)``"
#~ msgstr "``str(accept={robuffer}, zeroes=True)``"

#~ msgid "``'y*'``"
#~ msgstr "``'y*'``"

#~ msgid "``Py_buffer``"
#~ msgstr "``Py_buffer``"

#~ msgid "``'Z'``"
#~ msgstr "``'Z'``"

#, fuzzy
#~ msgid "``wchar_t(accept={str, NoneType})``"
#~ msgstr "``str(accept={str, NoneType})``"

#~ msgid "``'Z#'``"
#~ msgstr "``'Z#'``"

#, fuzzy
#~ msgid "``wchar_t(accept={str, NoneType}, zeroes=True)``"
#~ msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#~ msgid "``'z'``"
#~ msgstr "``'z'``"

#~ msgid "``str(accept={str, NoneType})``"
#~ msgstr "``str(accept={str, NoneType})``"

#~ msgid "``'z#'``"
#~ msgstr "``'z#'``"

#~ msgid "``str(accept={str, NoneType}, zeroes=True)``"
#~ msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#~ msgid "``'z*'``"
#~ msgstr "``'z*'``"

#~ msgid "``Py_buffer(accept={buffer, str, NoneType})``"
#~ msgstr "``Py_buffer(accept={buffer, str, NoneType})``"

#~ msgid ""
#~ "As an example, here's our sample ``pickle.Pickler.dump`` using the proper "
#~ "converter::"
#~ msgstr ""
#~ "Örnek olarak, uygun dönüştürücüyü kullanan ``pickle.Pickler.dump`` "
#~ "örneğimiz::"

#~ msgid ""
#~ "One advantage of real converters is that they're more flexible than "
#~ "legacy converters.  For example, the ``unsigned_int`` converter (and all "
#~ "the ``unsigned_`` converters) can be specified without ``bitwise=True``.  "
#~ "Their default behavior performs range checking on the value, and they "
#~ "won't accept negative numbers.  You just can't do that with a legacy "
#~ "converter!"
#~ msgstr ""
#~ "Gerçek dönüştürücülerin bir avantajı, eski dönüştürücülere göre daha "
#~ "esnek olmalarıdır.  Örneğin, ``unsigned_int`` dönüştürücüsü (ve tüm "
#~ "``unsigned_`` dönüştürücüleri) ``bitwise=True`` olmadan belirtilebilir.  "
#~ "Varsayılan davranışları değer üzerinde aralık denetimi yapar ve negatif "
#~ "sayıları kabul etmezler.  Bunu eski bir dönüştürücü ile yapamazsınız!"

#~ msgid ""
#~ "Argument Clinic will show you all the converters it has available.  For "
#~ "each converter it'll show you all the parameters it accepts, along with "
#~ "the default value for each parameter. Just run ``Tools/clinic/clinic.py --"
#~ "converters`` to see the full list."
#~ msgstr ""
#~ "Argüman Kliniği size mevcut tüm dönüştürücüleri gösterecektir.  Her "
#~ "dönüştürücü için, kabul ettiği tüm parametreleri ve her parametre için "
#~ "varsayılan değeri gösterecektir. Tam listeyi görmek için ``Tools/clinic/"
#~ "clinic.py --converters`` komutunu çalıştırmanız yeterlidir."

#~ msgid ""
#~ "When using the ``Py_buffer`` converter (or the ``'s*'``, ``'w*'``, "
#~ "``'*y'``, or ``'z*'`` legacy converters), you *must* not call :c:func:"
#~ "`PyBuffer_Release` on the provided buffer. Argument Clinic generates code "
#~ "that does it for you (in the parsing function)."
#~ msgstr ""
#~ "``Py_buffer`` dönüştürücüsünü (veya ``'s*'``, ``'w*'``, ``'*y'`` veya "
#~ "``'z*'`` eski dönüştürücülerini) kullanırken, sağlanan tampon üzerinde :c:"
#~ "func:`PyBuffer_Release` çağrısı yapmamanız gerekir. Argument Clinic bunu "
#~ "sizin için yapan kodu üretir (ayrıştırma işlevinde)."

#, fuzzy
#~ msgid "How to use advanced converters"
#~ msgstr "Gelişmiş dönüştürücüler"

#~ msgid ""
#~ "Remember those format units you skipped for your first time because they "
#~ "were advanced?  Here's how to handle those too."
#~ msgstr ""
#~ "İlk seferinizde ileri düzey oldukları için atladığınız format ünitelerini "
#~ "hatırlıyor musunuz?  İşte onları da nasıl halledeceğiniz."

#, fuzzy
#~ msgid ""
#~ "The trick is, all those format units take arguments—either conversion "
#~ "functions, or types, or strings specifying an encoding. (But \"legacy "
#~ "converters\" don't support arguments.  That's why we skipped them for "
#~ "your first function.)  The argument you specified to the format unit is "
#~ "now an argument to the converter; this argument is either *converter* "
#~ "(for ``O&``), *subclass_of* (for ``O!``), or *encoding* (for all the "
#~ "format units that start with ``e``)."
#~ msgstr ""
#~ "İşin püf noktası, tüm bu format birimlerinin argüman almasıdır - ya "
#~ "dönüştürme fonksiyonları, ya tipler ya da kodlama belirten dizeler. "
#~ "(Ancak \"eski dönüştürücüler\" argümanları desteklemez.  Bu yüzden ilk "
#~ "fonksiyonunuz için onları atladık).  Biçim birimine belirttiğiniz argüman "
#~ "artık dönüştürücünün bir argümanıdır; bu argüman ya ``converter`` (``O&`` "
#~ "için), ``subclass_of`` (``O!`` için) ya da ``encoding`` (``e`` ile "
#~ "başlayan tüm biçim birimleri için) şeklindedir."

#, fuzzy
#~ msgid ""
#~ "When using *subclass_of*, you may also want to use the other custom "
#~ "argument for ``object()``: *type*, which lets you set the type actually "
#~ "used for the parameter.  For example, if you want to ensure that the "
#~ "object is a subclass of :c:var:`PyUnicode_Type`, you probably want to use "
#~ "the converter ``object(type='PyUnicodeObject *', "
#~ "subclass_of='&PyUnicode_Type')``."
#~ msgstr ""
#~ "``subclass_of`` kullanırken, ``object()`` için diğer özel bağımsız "
#~ "değişkeni de kullanmak isteyebilirsiniz: ``type``, parametre için "
#~ "gerçekte kullanılan türü ayarlamanızı sağlar.  Örneğin, nesnenin "
#~ "``PyUnicode_Type`` türünün bir alt sınıfı olduğundan emin olmak "
#~ "istiyorsanız, muhtemelen ``object(type='PyUnicodeObject *', "
#~ "subclass_of='&PyUnicode_Type')`` dönüştürücüsünü kullanmak istersiniz."

#, fuzzy
#~ msgid ""
#~ "One possible problem with using Argument Clinic: it takes away some "
#~ "possible flexibility for the format units starting with ``e``.  When "
#~ "writing a :c:func:`!PyArg_Parse*` call by hand, you could theoretically "
#~ "decide at runtime what encoding string to pass to that call.   But now "
#~ "this string must be hard-coded at Argument-Clinic-preprocessing-time.  "
#~ "This limitation is deliberate; it made supporting this format unit much "
#~ "easier, and may allow for future optimizations. This restriction doesn't "
#~ "seem unreasonable; CPython itself always passes in static hard-coded "
#~ "encoding strings for parameters whose format units start with ``e``."
#~ msgstr ""
#~ "Argüman Kliniği kullanımıyla ilgili olası bir sorun: ``e`` ile başlayan "
#~ "biçim birimleri için bazı olası esneklikleri ortadan kaldırır.  Elle bir "
#~ "``PyArg_Parse`` çağrısı yazarken, teorik olarak :c:func:"
#~ "`PyArg_ParseTuple`'a hangi kodlama dizgesini aktaracağınıza çalışma "
#~ "zamanında karar verebilirsiniz.   Ancak şimdi bu dizge Argüman Kliniği-"
#~ "önişleme zamanında sabit kodlanmalıdır.  Bu sınırlama kasıtlıdır; bu "
#~ "format birimini desteklemeyi çok daha kolay hale getirdi ve gelecekteki "
#~ "optimizasyonlara izin verebilir. Bu kısıtlama mantıksız görünmüyor; "
#~ "CPython'un kendisi, biçim birimleri ``e`` ile başlayan parametreler için "
#~ "her zaman statik sabit kodlu kodlama dizeleri geçirir."

#~ msgid ""
#~ "Default values for parameters can be any of a number of values. At their "
#~ "simplest, they can be string, int, or float literals:"
#~ msgstr ""
#~ "Parametreler için varsayılan değerler bir dizi değerden herhangi biri "
#~ "olabilir. En basit haliyle string, int veya float değişmezleri "
#~ "olabilirler:"

#~ msgid "They can also use any of Python's built-in constants:"
#~ msgstr ""
#~ "Python'un yerleşik sabitlerinden herhangi birini de kullanabilirler:"

#~ msgid ""
#~ "There's also special support for a default value of ``NULL``, and for "
#~ "simple expressions, documented in the following sections."
#~ msgstr ""
#~ "Ayrıca ``NULL`` varsayılan değeri ve aşağıdaki bölümlerde belgelenen "
#~ "basit ifadeler için özel bir destek de vardır."

#~ msgid "The ``NULL`` default value"
#~ msgstr "Varsayılan değer ``NULL``"

#~ msgid ""
#~ "For string and object parameters, you can set them to ``None`` to "
#~ "indicate that there's no default.  However, that means the C variable "
#~ "will be initialized to ``Py_None``.  For convenience's sakes, there's a "
#~ "special value called ``NULL`` for just this reason: from Python's "
#~ "perspective it behaves like a default value of ``None``, but the C "
#~ "variable is initialized with ``NULL``."
#~ msgstr ""
#~ "Dize ve nesne parametreleri için, varsayılan olmadığını belirtmek için "
#~ "bunları ``None`` olarak ayarlayabilirsiniz.  Ancak bu, C değişkeninin "
#~ "``Py_None`` olarak başlatılacağı anlamına gelir.  Kolaylık olması "
#~ "açısından, sadece bu nedenle ``NULL`` adında özel bir değer vardır: "
#~ "Python'un bakış açısından varsayılan değer ``None`` gibi davranır, ancak "
#~ "C değişkeni ``NULL`` ile başlatılır."

#~ msgid "Symbolic default values"
#~ msgstr "Sembolik varsayılan değerler"

#~ msgid ""
#~ "The default value you provide for a parameter can't be any arbitrary "
#~ "expression.  Currently the following are explicitly supported:"
#~ msgstr ""
#~ "Bir parametre için sağladığınız varsayılan değer rastgele bir ifade "
#~ "olamaz.  Şu anda aşağıdakiler açıkça desteklenmektedir:"

#~ msgid "Numeric constants (integer and float)"
#~ msgstr "Sayısal sabitler (integer ve float)"

#~ msgid "String constants"
#~ msgstr "Dize sabitleri"

#~ msgid "``True``, ``False``, and ``None``"
#~ msgstr "``True``, ``False`` ve ``None``"

#, fuzzy
#~ msgid ""
#~ "Simple symbolic constants like :py:data:`sys.maxsize`, which must start "
#~ "with the name of the module"
#~ msgstr ""
#~ "Modülün adıyla başlaması gereken ``sys.maxsize`` gibi basit sembolik "
#~ "sabitler"

#~ msgid ""
#~ "(In the future, this may need to get even more elaborate, to allow full "
#~ "expressions like ``CONSTANT - 1``.)"
#~ msgstr ""
#~ "(Gelecekte, ``CONSTANT - 1`` gibi tam ifadelere izin vermek için bunun "
#~ "daha da ayrıntılı hale getirilmesi gerekebilir.)"

#, fuzzy
#~ msgid "Expressions as default values"
#~ msgstr "Varsayılan değerler olarak belirtilen ifadeler"

#~ msgid ""
#~ "The default value for a parameter can be more than just a literal value. "
#~ "It can be an entire expression, using math operators and looking up "
#~ "attributes on objects.  However, this support isn't exactly simple, "
#~ "because of some non-obvious semantics."
#~ msgstr ""
#~ "Bir parametre için varsayılan değer, gerçek bir değerden daha fazlası "
#~ "olabilir. Matematik operatörlerini kullanan ve nesnelerdeki öznitelikleri "
#~ "arayan bütün bir ifade olabilir.  Ancak bu destek, bazı açık olmayan "
#~ "anlamlar nedeniyle tam olarak basit değildir."

#~ msgid "Consider the following example:"
#~ msgstr "Aşağıdaki örneği ele alalım:"

#, fuzzy
#~ msgid ""
#~ ":py:data:`sys.maxsize` can have different values on different platforms.  "
#~ "Therefore Argument Clinic can't simply evaluate that expression locally "
#~ "and hard-code it in C.  So it stores the default in such a way that it "
#~ "will get evaluated at runtime, when the user asks for the function's "
#~ "signature."
#~ msgstr ""
#~ "``sys.maxsize`` farklı platformlarda farklı değerlere sahip olabilir.  Bu "
#~ "nedenle Argument Clinic bu ifadeyi yerel olarak değerlendiremez ve C'de "
#~ "sabit kodlayamaz. Bu nedenle varsayılanı, kullanıcı işlevin imzasını "
#~ "istediğinde çalışma zamanında değerlendirilecek şekilde saklar."

#, fuzzy
#~ msgid ""
#~ "What namespace is available when the expression is evaluated?  It's "
#~ "evaluated in the context of the module the builtin came from.  So, if "
#~ "your module has an attribute called :py:attr:`!max_widgets`, you may "
#~ "simply use it:"
#~ msgstr ""
#~ "İfade değerlendirildiğinde hangi ad alanı kullanılabilir?  Yerleşik "
#~ "öğenin geldiği modül bağlamında değerlendirilir.  Dolayısıyla, "
#~ "modülünüzün \"``max_widgets``\" adlı bir niteliği varsa, bunu "
#~ "kullanabilirsiniz:"

#, fuzzy
#~ msgid ""
#~ "If the symbol isn't found in the current module, it fails over to looking "
#~ "in :py:data:`sys.modules`.  That's how it can find :py:data:`sys.maxsize` "
#~ "for example. (Since you don't know in advance what modules the user will "
#~ "load into their interpreter, it's best to restrict yourself to modules "
#~ "that are preloaded by Python itself.)"
#~ msgstr ""
#~ "Eğer sembol mevcut modülde bulunamazsa, ``sys.modules`` içinde aramaya "
#~ "devam eder.  Örneğin ``sys.maxsize`` bu şekilde bulunabilir.  "
#~ "(Kullanıcının yorumlayıcısına hangi modülleri yükleyeceğini önceden "
#~ "bilemeyeceğiniz için, kendinizi Python'un kendisi tarafından önceden "
#~ "yüklenmiş modüllerle sınırlamak en iyisidir)."

#, fuzzy
#~ msgid ""
#~ "Evaluating default values only at runtime means Argument Clinic can't "
#~ "compute the correct equivalent C default value.  So you need to tell it "
#~ "explicitly. When you use an expression, you must also specify the "
#~ "equivalent expression in C, using the *c_default* parameter to the "
#~ "converter:"
#~ msgstr ""
#~ "Varsayılan değerlerin yalnızca çalışma zamanında değerlendirilmesi, "
#~ "Argüman Kliniği'nin doğru eşdeğer C varsayılan değerini hesaplayamayacağı "
#~ "anlamına gelir.  Bu yüzden ona açıkça söylemeniz gerekir. Bir ifade "
#~ "kullandığınızda, dönüştürücüye ``c_default`` parametresini kullanarak "
#~ "C'deki eşdeğer ifadeyi de belirtmeniz gerekir:"

#~ msgid ""
#~ "Another complication: Argument Clinic can't know in advance whether or "
#~ "not the expression you supply is valid.  It parses it to make sure it "
#~ "looks legal, but it can't *actually* know.  You must be very careful when "
#~ "using expressions to specify values that are guaranteed to be valid at "
#~ "runtime!"
#~ msgstr ""
#~ "Başka bir komplikasyon: Argüman Kliniği, sağladığınız ifadenin geçerli "
#~ "olup olmadığını önceden bilemez.  Yasal göründüğünden emin olmak için "
#~ "ayrıştırır, ancak *gerçekten* bilemez.  Çalışma zamanında geçerli olacağı "
#~ "garanti edilen değerleri belirtmek için ifadeleri kullanırken çok "
#~ "dikkatli olmalısınız!"

#~ msgid ""
#~ "Finally, because expressions must be representable as static C values, "
#~ "there are many restrictions on legal expressions.  Here's a list of "
#~ "Python features you're not permitted to use:"
#~ msgstr ""
#~ "Son olarak, ifadelerin statik C değerleri olarak gösterilebilir olması "
#~ "gerektiğinden, yasal ifadeler üzerinde birçok kısıtlama vardır.  İşte "
#~ "kullanmanıza izin verilmeyen Python özelliklerinin bir listesi:"

#~ msgid "Function calls."
#~ msgstr "Fonksiyon çağrıları."

#~ msgid "Inline if statements (``3 if foo else 5``)."
#~ msgstr "Satır içi if ifadeleri (``3 if foo else 5``)."

#~ msgid "Automatic sequence unpacking (``*[1, 2, 3]``)."
#~ msgstr "Otomatik dizi açma (``*[1, 2, 3]``)."

#~ msgid "List/set/dict comprehensions and generator expressions."
#~ msgstr "Liste/set/dict kavramaları ve üretici ifadeleri."

#~ msgid "Tuple/list/set/dict literals."
#~ msgstr "Tuple/list/set/dict değişmezleri."

#, fuzzy
#~ msgid "How to use return converters"
#~ msgstr "dönüş dönüştürücüsü."

#, fuzzy
#~ msgid ""
#~ "By default, the impl function Argument Clinic generates for you returns :"
#~ "c:type:`PyObject * <PyObject>`. But your C function often computes some C "
#~ "type, then converts it into the :c:type:`!PyObject *` at the last "
#~ "moment.  Argument Clinic handles converting your inputs from Python types "
#~ "into native C types—why not have it convert your return value from a "
#~ "native C type into a Python type too?"
#~ msgstr ""
#~ "Argüman Kliniği'nin sizin için oluşturduğu impl fonksiyonu varsayılan "
#~ "olarak ``PyObject *`` döndürür. Ancak C fonksiyonunuz genellikle bir C "
#~ "tipini hesaplar, sonra son anda onu ``PyObject *``'e dönüştürür.  Argüman "
#~ "Kliniği girdilerinizi Python türlerinden yerel C türlerine dönüştürür - "
#~ "neden dönüş değerinizi de yerel bir C türünden bir Python türüne "
#~ "dönüştürmesin?"

#, fuzzy
#~ msgid ""
#~ "That's what a \"return converter\" does.  It changes your impl function "
#~ "to return some C type, then adds code to the generated (non-impl) "
#~ "function to handle converting that value into the appropriate :c:type:`!"
#~ "PyObject *`."
#~ msgstr ""
#~ "\"Dönüş dönüştürücüsü\" de bunu yapar.  Bir C tipi döndürmek için impl "
#~ "fonksiyonunuzu değiştirir, ardından bu değeri uygun ``PyObject *``'e "
#~ "dönüştürmek için oluşturulan (impl olmayan) fonksiyona kod ekler."

#, fuzzy
#~ msgid ""
#~ "The syntax for return converters is similar to that of parameter "
#~ "converters. You specify the return converter like it was a return "
#~ "annotation on the function itself, using ``->`` notation."
#~ msgstr ""
#~ "Dönüş dönüştürücüleri için sözdizimi parametre dönüştürücülerine benzer. "
#~ "Dönüş dönüştürücüsünü fonksiyonun kendisindeki bir dönüş ek açıklaması "
#~ "gibi belirtirsiniz.  Dönüş dönüştürücüleri parametre dönüştürücüleriyle "
#~ "aynı şekilde davranır; argüman alırlar, argümanların tümü yalnızca "
#~ "anahtar sözcüktür ve varsayılan argümanlardan herhangi birini "
#~ "değiştirmiyorsanız parantezleri atlayabilirsiniz."

#, fuzzy
#~ msgid "For example:"
#~ msgstr "Örnek::"

#, fuzzy
#~ msgid ""
#~ "Return converters behave much the same as parameter converters; they take "
#~ "arguments, the arguments are all keyword-only, and if you're not changing "
#~ "any of the default arguments you can omit the parentheses."
#~ msgstr ""
#~ "Dönüş dönüştürücüleri için sözdizimi parametre dönüştürücülerine benzer. "
#~ "Dönüş dönüştürücüsünü fonksiyonun kendisindeki bir dönüş ek açıklaması "
#~ "gibi belirtirsiniz.  Dönüş dönüştürücüleri parametre dönüştürücüleriyle "
#~ "aynı şekilde davranır; argüman alırlar, argümanların tümü yalnızca "
#~ "anahtar sözcüktür ve varsayılan argümanlardan herhangi birini "
#~ "değiştirmiyorsanız parantezleri atlayabilirsiniz."

#~ msgid ""
#~ "(If you use both ``\"as\"`` *and* a return converter for your function, "
#~ "the ``\"as\"`` should come before the return converter.)"
#~ msgstr ""
#~ "(Fonksiyonunuz için hem ``\"as\"`` * hem de * return dönüştürücü "
#~ "kullanıyorsanız, ``\"as\"`` return dönüştürücüden önce gelmelidir.)"

#, fuzzy
#~ msgid ""
#~ "There's one additional complication when using return converters: how do "
#~ "you indicate an error has occurred?  Normally, a function returns a valid "
#~ "(non-``NULL``) pointer for success, and ``NULL`` for failure.  But if you "
#~ "use an integer return converter, all integers are valid.  How can "
#~ "Argument Clinic detect an error?  Its solution: each return converter "
#~ "implicitly looks for a special value that indicates an error.  If you "
#~ "return that value, and an error has been set (c:func:`PyErr_Occurred` "
#~ "returns a true value), then the generated code will propagate the error.  "
#~ "Otherwise it will encode the value you return like normal."
#~ msgstr ""
#~ "Geri dönüş dönüştürücülerini kullanırken ek bir karmaşıklık vardır: bir "
#~ "hata oluştuğunu nasıl belirtirsiniz?  Normalde, bir fonksiyon başarı için "
#~ "geçerli (``NULL`` olmayan) bir işaretçi döndürür ve başarısızlık için "
#~ "``NULL`` döndürür.  Ancak bir tamsayı dönüş dönüştürücüsü kullanırsanız, "
#~ "tüm tamsayılar geçerlidir.  Argüman Kliniği bir hatayı nasıl tespit "
#~ "edebilir?  Çözümü: her geri dönüş dönüştürücüsü örtük olarak bir hatayı "
#~ "gösteren özel bir değer arar.  Bu değeri döndürürseniz ve bir hata "
#~ "ayarlanmışsa (``PyErr_Occurred()`` doğru bir değer döndürür), oluşturulan "
#~ "kod hatayı yayacaktır.  Aksi takdirde, döndürdüğünüz değeri normal "
#~ "şekilde kodlayacaktır."

#~ msgid "Currently Argument Clinic supports only a few return converters:"
#~ msgstr ""
#~ "Şu anda Argüman Kliniği yalnızca birkaç dönüş dönüştürücüsünü "
#~ "desteklemektedir:"

#~ msgid ""
#~ "To see all the return converters Argument Clinic supports, along with "
#~ "their parameters (if any), just run ``Tools/clinic/clinic.py --"
#~ "converters`` for the full list."
#~ msgstr ""
#~ "Argüman Kliniği'nin desteklediği tüm dönüş dönüştürücülerini "
#~ "parametreleriyle (varsa) birlikte görmek için, tam liste için ``Tools/"
#~ "clinic/clinic.py --converters`` komutunu çalıştırmanız yeterlidir."

#, fuzzy
#~ msgid "How to clone existing functions"
#~ msgstr "Mevcut fonksiyonları klonlama"

#~ msgid ""
#~ "If you have a number of functions that look similar, you may be able to "
#~ "use Clinic's \"clone\" feature.  When you clone an existing function, you "
#~ "reuse:"
#~ msgstr ""
#~ "Birbirine benzeyen çok sayıda fonksiyonunuz varsa, Kliniğin \"clone\" "
#~ "özelliğini kullanabilirsiniz.  Mevcut bir işlevi klonladığınızda, yeniden "
#~ "kullanırsınız:"

#~ msgid "its parameters, including"
#~ msgstr "parametreleri, dahil olmak üzere"

#~ msgid "their names,"
#~ msgstr "isimleri,"

#~ msgid "their converters, with all parameters,"
#~ msgstr "dönüştürücüleri, tüm parametrelerle birlikte,"

#~ msgid "their default values,"
#~ msgstr "varsayılan değerleri,"

#~ msgid "their per-parameter docstrings,"
#~ msgstr "parametre başına dokümanları,"

#~ msgid ""
#~ "their *kind* (whether they're positional only, positional or keyword, or "
#~ "keyword only), and"
#~ msgstr ""
#~ "türleri* (yalnızca konumsal, konumsal veya anahtar sözcük ya da yalnızca "
#~ "anahtar sözcük olup olmadıkları) ve"

#~ msgid "its return converter."
#~ msgstr "dönüş dönüştürücüsü."

#~ msgid ""
#~ "The only thing not copied from the original function is its docstring; "
#~ "the syntax allows you to specify a new docstring."
#~ msgstr ""
#~ "Orijinal fonksiyondan kopyalanmayan tek şey onun docstring'idir; "
#~ "sözdizimi yeni bir docstring belirtmenize izin verir."

#~ msgid "Here's the syntax for cloning a function::"
#~ msgstr "Bir fonksiyonu klonlamak için sözdizimi şöyledir::"

#~ msgid ""
#~ "(The functions can be in different modules or classes.  I wrote ``module."
#~ "class`` in the sample just to illustrate that you must use the full path "
#~ "to *both* functions.)"
#~ msgstr ""
#~ "(Fonksiyonlar farklı modüllerde veya sınıflarda olabilir.  Örnekte "
#~ "``module.class`` yazdım, sadece *her iki* fonksiyon için de tam yolu "
#~ "kullanmanız gerektiğini göstermek için.)"

#~ msgid ""
#~ "Sorry, there's no syntax for partially cloning a function, or cloning a "
#~ "function then modifying it.  Cloning is an all-or nothing proposition."
#~ msgstr ""
#~ "Üzgünüz, bir fonksiyonu kısmen klonlamak veya bir fonksiyonu klonladıktan "
#~ "sonra değiştirmek için bir sözdizimi yoktur.  Klonlama bir ya hep ya hiç "
#~ "önermesidir."

#~ msgid ""
#~ "Also, the function you are cloning from must have been previously defined "
#~ "in the current file."
#~ msgstr ""
#~ "Ayrıca, klonladığınız fonksiyonun mevcut dosyada daha önce tanımlanmış "
#~ "olması gerekir."

#, fuzzy
#~ msgid "How to call Python code"
#~ msgstr "Python kodunu çağırma"

#~ msgid ""
#~ "The rest of the advanced topics require you to write Python code which "
#~ "lives inside your C file and modifies Argument Clinic's runtime state.  "
#~ "This is simple: you simply define a Python block."
#~ msgstr ""
#~ "İleri düzey konuların geri kalanı, C dosyanızın içinde yaşayan ve Argüman "
#~ "Kliniği'nin çalışma zamanı durumunu değiştiren Python kodu yazmanızı "
#~ "gerektirir.  Bu basittir: sadece bir Python bloğu tanımlarsınız."

#~ msgid ""
#~ "A Python block uses different delimiter lines than an Argument Clinic "
#~ "function block.  It looks like this::"
#~ msgstr ""
#~ "Bir Python bloğu, Argüman Kliniği işlev bloğundan farklı sınırlayıcı "
#~ "satırlar kullanır.  Şöyle görünür::"

#~ msgid ""
#~ "All the code inside the Python block is executed at the time it's "
#~ "parsed.  All text written to stdout inside the block is redirected into "
#~ "the \"output\" after the block."
#~ msgstr ""
#~ "Python bloğunun içindeki tüm kod ayrıştırıldığı anda çalıştırılır.  Blok "
#~ "içinde stdout'a yazılan tüm metin, bloktan sonra \"çıktı \"ya "
#~ "yönlendirilir."

#~ msgid ""
#~ "As an example, here's a Python block that adds a static integer variable "
#~ "to the C code::"
#~ msgstr ""
#~ "Örnek olarak, işte C koduna statik bir tamsayı değişkeni ekleyen bir "
#~ "Python bloğu::"

#, fuzzy
#~ msgid "How to use the \"self converter\""
#~ msgstr "\"Kendi kendine dönüştürücü\" kullanma"

#, fuzzy
#~ msgid ""
#~ "Argument Clinic automatically adds a \"self\" parameter for you using a "
#~ "default converter.  It automatically sets the ``type`` of this parameter "
#~ "to the \"pointer to an instance\" you specified when you declared the "
#~ "type.  However, you can override Argument Clinic's converter and specify "
#~ "one yourself. Just add your own *self* parameter as the first parameter "
#~ "in a block, and ensure that its converter is an instance of :class:`!"
#~ "self_converter` or a subclass thereof."
#~ msgstr ""
#~ "Argüman Kliniği, varsayılan bir dönüştürücü kullanarak sizin için "
#~ "otomatik olarak bir \"self\" parametresi ekler.  Bu parametrenin ``type`` "
#~ "değerini otomatik olarak, türü bildirirken belirttiğiniz \"bir örneğe "
#~ "işaretçi\" olarak ayarlar.  Ancak, Argüman Kliniği'nin dönüştürücüsünü "
#~ "geçersiz kılabilir ve kendiniz bir dönüştürücü belirleyebilirsiniz. "
#~ "Sadece kendi ``self`` parametrenizi bir bloktaki ilk parametre olarak "
#~ "ekleyin ve dönüştürücüsünün ``self_converter`` veya onun bir alt "
#~ "sınıfının bir örneği olduğundan emin olun."

#~ msgid ""
#~ "What's the point?  This lets you override the type of ``self``, or give "
#~ "it a different default name."
#~ msgstr ""
#~ "Ne anlamı var?  Bu, ``self`` türünü geçersiz kılmanıza veya ona farklı "
#~ "bir varsayılan ad vermenize olanak tanır."

#, fuzzy
#~ msgid ""
#~ "How do you specify the custom type you want to cast ``self`` to? If you "
#~ "only have one or two functions with the same type for ``self``, you can "
#~ "directly use Argument Clinic's existing ``self`` converter, passing in "
#~ "the type you want to use as the *type* parameter::"
#~ msgstr ""
#~ "``self`` için döküm yapmak istediğiniz özel türü nasıl belirlersiniz? "
#~ "Eğer ``self`` için aynı tipe sahip sadece bir veya iki fonksiyonunuz "
#~ "varsa, kullanmak istediğiniz tipi ``type`` parametresi olarak girerek "
#~ "Argüman Kliniğinin mevcut ``self`` dönüştürücüsünü doğrudan "
#~ "kullanabilirsiniz::"

#, fuzzy
#~ msgid ""
#~ "On the other hand, if you have a lot of functions that will use the same "
#~ "type for ``self``, it's best to create your own converter, subclassing :"
#~ "class:`!self_converter` but overwriting the :py:attr:`!type` member::"
#~ msgstr ""
#~ "Öte yandan, ``self`` için aynı türü kullanacak çok sayıda işleviniz "
#~ "varsa, en iyisi ``self_converter`` alt sınıfını kullanarak, ancak "
#~ "``type`` üyesinin üzerine yazarak kendi dönüştürücünüzü oluşturmaktır::"

#, fuzzy
#~ msgid "How to use the \"defining class\" converter"
#~ msgstr "\"Sınıf tanımlama\" dönüştürücüsü kullanma"

#~ msgid ""
#~ "Argument Clinic facilitates gaining access to the defining class of a "
#~ "method. This is useful for :ref:`heap type <heap-types>` methods that "
#~ "need to fetch module level state.  Use :c:func:`PyType_FromModuleAndSpec` "
#~ "to associate a new heap type with a module.  You can now use :c:func:"
#~ "`PyType_GetModuleState` on the defining class to fetch the module state, "
#~ "for example from a module method."
#~ msgstr ""
#~ "Argüman Kliniği, bir metodun tanımlayıcı sınıfına erişim sağlamayı "
#~ "kolaylaştırır. Bu, modül düzeyinde durum getirmesi gereken :ref:`heap "
#~ "type <heap-types>` yöntemleri için kullanışlıdır.  Yeni bir heap tipini "
#~ "bir modül ile ilişkilendirmek için :c:func:`PyType_FromModuleAndSpec` "
#~ "kullanın.  Artık modül durumunu, örneğin bir modül yönteminden almak için "
#~ "tanımlayıcı sınıf üzerinde :c:func:`PyType_GetModuleState` "
#~ "kullanabilirsiniz."

#, fuzzy
#~ msgid ""
#~ "Example from :source:`Modules/zlibmodule.c`. First, ``defining_class`` is "
#~ "added to the clinic input::"
#~ msgstr ""
#~ "``Modules/zlibmodule.c`` den örnek.  İlk olarak, ``defining_class`` "
#~ "klinik girdisine eklenir::"

#~ msgid ""
#~ "After running the Argument Clinic tool, the following function signature "
#~ "is generated::"
#~ msgstr ""
#~ "Argüman Kliniği aracını çalıştırdıktan sonra aşağıdaki fonksiyon imzası "
#~ "oluşturulur::"

#~ msgid ""
#~ "The following code can now use ``PyType_GetModuleState(cls)`` to fetch "
#~ "the module state::"
#~ msgstr ""
#~ "Aşağıdaki kod artık modül durumunu almak için "
#~ "``PyType_GetModuleState(cls)`` kullanabilir::"

#, fuzzy
#~ msgid ""
#~ "Each method may only have one argument using this converter, and it must "
#~ "appear after ``self``, or, if ``self`` is not used, as the first "
#~ "argument.  The argument will be of type ``PyTypeObject *``.  The argument "
#~ "will not appear in the :py:attr:`!__text_signature__`."
#~ msgstr ""
#~ "Bu dönüştürücüyü kullanan her yöntemin yalnızca bir argümanı olabilir ve "
#~ "bu argüman ``self`` öğesinden sonra veya ``self`` öğesi kullanılmamışsa "
#~ "ilk argüman olarak görünmelidir.  Argüman ``PyTypeObject *`` tipinde "
#~ "olacaktır.  Argüman ``__text_signature__`` içinde görünmeyecektir."

#, fuzzy
#~ msgid ""
#~ "The ``defining_class`` converter is not compatible with :py:meth:`!"
#~ "__init__` and :py:meth:`!__new__` methods, which cannot use the :c:macro:"
#~ "`METH_METHOD` convention."
#~ msgstr ""
#~ "``defining_class`` dönüştürücüsü, ``METH_METHOD`` kuralını kullanamayan "
#~ "``__init__`` ve ``__new__`` yöntemleriyle uyumlu değildir."

#, fuzzy
#~ msgid ""
#~ "It is not possible to use ``defining_class`` with slot methods.  In order "
#~ "to fetch the module state from such methods, use :c:func:"
#~ "`PyType_GetModuleByDef` to look up the module and then :c:func:"
#~ "`PyModule_GetState` to fetch the module state.  Example from the "
#~ "``setattro`` slot method in :source:`Modules/_threadmodule.c`::"
#~ msgstr ""
#~ "Slot metotları ile ``defining_class`` kullanmak mümkün değildir.  Bu tür "
#~ "yöntemlerden modül durumunu almak için, modülü aramak için :c:func:"
#~ "`PyType_GetModuleByDef` ve ardından modül durumunu almak için :c:func:"
#~ "`PyModule_GetState` kullanın. ``Modules/_threadmodule.c`` içindeki "
#~ "``setattro`` slot yönteminden örnek::"

#~ msgid "See also :pep:`573`."
#~ msgstr "Bkz: :pep:`573`."

#, fuzzy
#~ msgid "How to write a custom converter"
#~ msgstr "Özel bir dönüştürücü yazma"

#, fuzzy
#~ msgid ""
#~ "A converter is a Python class that inherits from :py:class:`CConverter`. "
#~ "The main purpose of a custom converter, is for parameters parsed with the "
#~ "``O&`` format unit --- parsing such a parameter means calling a :c:func:"
#~ "`PyArg_ParseTuple` \"converter function\"."
#~ msgstr ""
#~ "Önceki bölümde ima ettiğimiz gibi... kendi dönüştürücülerinizi "
#~ "yazabilirsiniz! Bir dönüştürücü basitçe ``CConverter``'dan miras alan bir "
#~ "Python sınıfıdır. Özel bir dönüştürücünün ana amacı, ``O&`` biçimini "
#~ "kullanan bir parametreniz varsa, bu parametreyi birim ayrıştırmak, bir :c:"
#~ "func:`PyArg_ParseTuple` \"dönüştürücü işlevi\" çağırmak anlamına gelir."

#, fuzzy
#~ msgid ""
#~ "Your converter class should be named :samp:`{ConverterName}_converter`. "
#~ "By following this convention, your converter class will be automatically "
#~ "registered with Argument Clinic, with its *converter name* being the name "
#~ "of your converter class with the ``_converter`` suffix stripped off."
#~ msgstr ""
#~ "Dönüştürücü sınıfınızın adı ``*something*_converter`` olmalıdır. İsim bu "
#~ "kurala uygunsa, dönüştürücü sınıfınız Argüman Kliniği'ne otomatik olarak "
#~ "kaydedilecektir; adı, ``_converter`` son eki çıkarılmış sınıfınızın adı "
#~ "olacaktır.  (Bu bir meta sınıf ile gerçekleştirilir.)"

#, fuzzy
#~ msgid ""
#~ "Instead of subclassing :py:meth:`!CConverter.__init__`, write a :py:meth:"
#~ "`!converter_init` method. :py:meth:`!converter_init` always accepts a "
#~ "*self* parameter. After *self*, all additional parameters **must** be "
#~ "keyword-only. Any arguments passed to the converter in Argument Clinic "
#~ "will be passed along to your :py:meth:`!converter_init` method. See :py:"
#~ "class:`CConverter` for a list of members you may wish to specify in your "
#~ "subclass."
#~ msgstr ""
#~ "``CConverter.__init__`` alt sınıfını kullanmamalısınız.  Bunun yerine, "
#~ "bir ``converter_init()`` fonksiyonu yazmalısınız.  ``converter_init()`` "
#~ "her zaman bir ``self`` parametresi kabul eder; bundan sonra, tüm ek "
#~ "parametreler *mutlaka* yalnızca anahtar kelime olmalıdır.  Argüman "
#~ "Kliniği`nde dönüştürücüye aktarılan tüm argümanlar ``converter_init()`` "
#~ "fonksiyonunuza aktarılacaktır."

#, fuzzy
#~ msgid ""
#~ "Here's the simplest example of a custom converter, from :source:`Modules/"
#~ "zlibmodule.c`::"
#~ msgstr ""
#~ "İşte ``Modules/zlibmodule.c`` adresinden özel bir dönüştürücünün en basit "
#~ "örneği::"

#, fuzzy
#~ msgid ""
#~ "This block adds a converter named ``ssize_t`` to Argument Clinic. "
#~ "Parameters declared as ``ssize_t`` will be declared with type :c:type:"
#~ "`Py_ssize_t`, and will be parsed by the ``'O&'`` format unit, which will "
#~ "call the :c:func:`!ssize_t_converter` converter C function. ``ssize_t`` "
#~ "variables automatically support default values."
#~ msgstr ""
#~ "Bu blok Argüman Kliniğine ``ssize_t`` adında bir dönüştürücü ekler.  "
#~ "``ssize_t`` olarak bildirilen parametreler :c:type:`Py_ssize_t` türünde "
#~ "bildirilecek ve ``'O&'`` biçim birimi tarafından ayrıştırılacak ve "
#~ "``ssize_t_converter`` dönüştürücü işlevini çağıracaktır.  ``ssize_t`` "
#~ "değişkenleri otomatik olarak varsayılan değerleri destekler."

#~ msgid ""
#~ "More sophisticated custom converters can insert custom C code to handle "
#~ "initialization and cleanup. You can see more examples of custom "
#~ "converters in the CPython source tree; grep the C files for the string "
#~ "``CConverter``."
#~ msgstr ""
#~ "Daha sofistike özel dönüştürücüler, başlatma ve temizleme işlemlerini "
#~ "gerçekleştirmek için özel C kodu ekleyebilir. CPython kaynak ağacında "
#~ "daha fazla özel dönüştürücü örneği görebilirsiniz; ``CConverter`` dizesi "
#~ "için C dosyalarını grepleyin."

#, fuzzy
#~ msgid "How to write a custom return converter"
#~ msgstr "Özel bir dönüş dönüştürücü yazma"

#~ msgid ""
#~ "Writing a custom return converter is much like writing a custom "
#~ "converter.  Except it's somewhat simpler, because return converters are "
#~ "themselves much simpler."
#~ msgstr ""
#~ "Özel bir return dönüştürücü yazmak, özel bir dönüştürücü yazmaya çok "
#~ "benzer.  Biraz basit olması dışında, çünkü geri dönüş dönüştürücülerinin "
#~ "kendileri çok daha basittir."

#, fuzzy
#~ msgid ""
#~ "Return converters must subclass :py:class:`!CReturnConverter`. There are "
#~ "no examples yet of custom return converters, because they are not widely "
#~ "used yet.  If you wish to write your own return converter, please read :"
#~ "source:`Tools/clinic/clinic.py`, specifically the implementation of :py:"
#~ "class:`!CReturnConverter` and all its subclasses."
#~ msgstr ""
#~ "Dönüş dönüştürücüleri ``CReturnConverter`` alt sınıfına sahip olmalıdır. "
#~ "Henüz yaygın olarak kullanılmadıkları için özel dönüş dönüştürücüleri "
#~ "için henüz bir örnek yoktur.  Kendi dönüş dönüştürücünüzü yazmak "
#~ "istiyorsanız, lütfen ``Tools/clinic/clinic.py`` dosyasını, özellikle "
#~ "``CReturnConverter`` ve tüm alt sınıflarının uygulamasını okuyun."

#, fuzzy
#~ msgid ""
#~ "To convert a function using :c:macro:`METH_O`, make sure the function's "
#~ "single argument is using the ``object`` converter, and mark the arguments "
#~ "as positional-only::"
#~ msgstr ""
#~ "Bir fonksiyonu ``METH_O`` kullanarak dönüştürmek için, fonksiyonun tek "
#~ "argümanının ``object`` dönüştürücüsünü kullandığından emin olun ve "
#~ "argümanları sadece pozisyonel olarak işaretleyin::"

#, fuzzy
#~ msgid ""
#~ "To convert a function using :c:macro:`METH_NOARGS`, just don't specify "
#~ "any arguments."
#~ msgstr ""
#~ "Bir fonksiyonu ``METH_NOARGS`` kullanarak dönüştürmek için herhangi bir "
#~ "argüman belirtmemeniz yeterlidir."

#, fuzzy
#~ msgid ""
#~ "You can still use a self converter, a return converter, and specify a "
#~ "*type* argument to the object converter for :c:macro:`METH_O`."
#~ msgstr ""
#~ "Yine de bir self dönüştürücü, bir return dönüştürücü kullanabilir ve "
#~ "``METH_O`` için nesne dönüştürücüye bir ``type`` argümanı "
#~ "belirtebilirsiniz."

#, fuzzy
#~ msgid "How to convert ``tp_new`` and ``tp_init`` functions"
#~ msgstr "tp_new ve tp_init fonksiyonları"

#, fuzzy
#~ msgid ""
#~ "You can convert :c:member:`~PyTypeObject.tp_new` and :c:member:"
#~ "`~PyTypeObject.tp_init` functions. Just name them ``__new__`` or "
#~ "``__init__`` as appropriate.  Notes:"
#~ msgstr ""
#~ "``tp_new`` ve ``tp_init`` fonksiyonlarını dönüştürebilirsiniz.  Bunları "
#~ "uygun şekilde ``__new__`` veya ``__init__`` olarak adlandırmanız "
#~ "yeterlidir.  Notlar:"

#~ msgid ""
#~ "The function name generated for ``__new__`` doesn't end in ``__new__`` "
#~ "like it would by default.  It's just the name of the class, converted "
#~ "into a valid C identifier."
#~ msgstr ""
#~ "``__new__`` için oluşturulan işlev adı, varsayılan olarak olduğu gibi "
#~ "``__new__`` ile bitmez.  Bu sadece geçerli bir C tanımlayıcısına "
#~ "dönüştürülmüş sınıf adıdır."

#, fuzzy
#~ msgid ""
#~ "No :c:type:`PyMethodDef` ``#define`` is generated for these functions."
#~ msgstr "Bu fonksiyonlar için ``PyMethodDef`` ``#define`` oluşturulmaz."

#~ msgid "``__init__`` functions return ``int``, not ``PyObject *``."
#~ msgstr "``__init__`` fonksiyonları ``PyObject *`` değil ``int`` döndürür."

#~ msgid "Use the docstring as the class docstring."
#~ msgstr "Doküman dizesini sınıf doküman dizesi olarak kullanın."

#~ msgid ""
#~ "Although ``__new__`` and ``__init__`` functions must always accept both "
#~ "the ``args`` and ``kwargs`` objects, when converting you may specify any "
#~ "signature for these functions that you like. (If your function doesn't "
#~ "support keywords, the parsing function generated will throw an exception "
#~ "if it receives any.)"
#~ msgstr ""
#~ "Her ne kadar ``__new__`` ve ``__init__`` fonksiyonları her zaman hem "
#~ "``args`` hem de ``kwargs`` nesnelerini kabul etmek zorunda olsa da, "
#~ "dönüştürme yaparken bu fonksiyonlar için istediğiniz imzayı "
#~ "belirtebilirsiniz. (İşleviniz anahtar sözcükleri desteklemiyorsa, "
#~ "oluşturulan ayrıştırma işlevi herhangi bir anahtar sözcük alırsa bir "
#~ "istisna atacaktır)."

#, fuzzy
#~ msgid "How to change and redirect Clinic's output"
#~ msgstr "Kliniğin çıktısını değiştirme ve yönlendirme"

#~ msgid ""
#~ "It can be inconvenient to have Clinic's output interspersed with your "
#~ "conventional hand-edited C code.  Luckily, Clinic is configurable: you "
#~ "can buffer up its output for printing later (or earlier!), or write its "
#~ "output to a separate file.  You can also add a prefix or suffix to every "
#~ "line of Clinic's generated output."
#~ msgstr ""
#~ "Kliniğin çıktısının geleneksel elle düzenlenmiş C kodunuzun arasına "
#~ "serpiştirilmesi rahatsız edici olabilir.  Neyse ki, Klinik "
#~ "yapılandırılabilir: çıktısını daha sonra (veya daha önce!) yazdırmak için "
#~ "tamponlayabilir veya çıktısını ayrı bir dosyaya yazabilirsiniz.  Ayrıca "
#~ "Kliniğin ürettiği çıktının her satırına bir önek veya sonek "
#~ "ekleyebilirsiniz."

#~ msgid ""
#~ "While changing Clinic's output in this manner can be a boon to "
#~ "readability, it may result in Clinic code using types before they are "
#~ "defined, or your code attempting to use Clinic-generated code before it "
#~ "is defined. These problems can be easily solved by rearranging the "
#~ "declarations in your file, or moving where Clinic's generated code goes.  "
#~ "(This is why the default behavior of Clinic is to output everything into "
#~ "the current block; while many people consider this hampers readability, "
#~ "it will never require rearranging your code to fix definition-before-use "
#~ "problems.)"
#~ msgstr ""
#~ "Kliniğin çıktısını bu şekilde değiştirmek okunabilirlik için bir nimet "
#~ "olsa da, Klinik kodunun tanımlanmadan önce türleri kullanmasına veya "
#~ "kodunuzun tanımlanmadan önce Klinik tarafından oluşturulan kodu "
#~ "kullanmaya çalışmasına neden olabilir. Bu sorunlar, dosyanızdaki "
#~ "bildirimleri yeniden düzenleyerek veya Kliniğin ürettiği kodun yerini "
#~ "değiştirerek kolayca çözülebilir.  (Bu nedenle Kliniğin varsayılan "
#~ "davranışı her şeyi geçerli bloğa çıktı olarak vermektir; birçok kişi "
#~ "bunun okunabilirliği engellediğini düşünse de, kullanımdan önce tanımlama "
#~ "sorunlarını düzeltmek için kodunuzu yeniden düzenlemenizi asla "
#~ "gerektirmez)."

#~ msgid "Let's start with defining some terminology:"
#~ msgstr "Bazı terminolojileri tanımlamakla başlayalım:"

#~ msgid "*field*"
#~ msgstr "*field*"

#, fuzzy
#~ msgid ""
#~ "A field, in this context, is a subsection of Clinic's output. For "
#~ "example, the ``#define`` for the :c:type:`PyMethodDef` structure is a "
#~ "field, called ``methoddef_define``.  Clinic has seven different fields it "
#~ "can output per function definition:"
#~ msgstr ""
#~ "Bu bağlamda bir alan, Kliniğin çıktısının bir alt bölümüdür. Örneğin, "
#~ "``PyMethodDef`` yapısı için ``#define`` , ``methoddef_define`` olarak "
#~ "adlandırılan bir alandır.  Kliniğin fonksiyon tanımı başına çıktı "
#~ "verebileceği yedi farklı alan vardır:"

#~ msgid ""
#~ "All the names are of the form ``\"<a>_<b>\"``, where ``\"<a>\"`` is the "
#~ "semantic object represented (the parsing function, the impl function, the "
#~ "docstring, or the methoddef structure) and ``\"<b>\"`` represents what "
#~ "kind of statement the field is.  Field names that end in "
#~ "``\"_prototype\"`` represent forward declarations of that thing, without "
#~ "the actual body/data of the thing; field names that end in "
#~ "``\"_definition\"`` represent the actual definition of the thing, with "
#~ "the body/data of the thing.  (``\"methoddef\"`` is special, it's the only "
#~ "one that ends with ``\"_define\"``, representing that it's a preprocessor "
#~ "#define.)"
#~ msgstr ""
#~ "Tüm adlar ``\"<a>_<b>\"`` biçimindedir, burada ``\"<a>\"`` temsil edilen "
#~ "semantik nesnedir (ayrıştırma işlevi, impl işlevi, docstring veya "
#~ "methoddef yapısı) ve ``\"<b>\"`` alanın ne tür bir ifade olduğunu temsil "
#~ "eder. ``\"_prototype\"`` ile biten alan adları, o şeyin gerçek gövdesi/"
#~ "verileri olmadan ileriye dönük bildirimlerini temsil eder; "
#~ "``\"_definition\"`` ile biten alan adları, o şeyin gövdesi/verileri ile "
#~ "birlikte o şeyin gerçek tanımını temsil eder. (``\"methoddef\"`` özeldir, "
#~ "``\"_define\"`` ile biten tek metottur, #define önişlemcisi olduğunu "
#~ "gösterir.)"

#~ msgid "*destination*"
#~ msgstr "*destination*"

#~ msgid ""
#~ "A destination is a place Clinic can write output to.  There are five "
#~ "built-in destinations:"
#~ msgstr ""
#~ "Hedef, Kliniğin çıktı yazabileceği bir yerdir.  Beş adet yerleşik hedef "
#~ "vardır:"

#~ msgid "``block``"
#~ msgstr "``block````block``"

#~ msgid ""
#~ "The default destination: printed in the output section of the current "
#~ "Clinic block."
#~ msgstr ""
#~ "Varsayılan hedef: geçerli Klinik bloğunun çıktı bölümünde yazdırılır."

#~ msgid "``buffer``"
#~ msgstr "``buffer``"

#~ msgid ""
#~ "A text buffer where you can save text for later.  Text sent here is "
#~ "appended to the end of any existing text.  It's an error to have any text "
#~ "left in the buffer when Clinic finishes processing a file."
#~ msgstr ""
#~ "Metni daha sonra kullanmak üzere kaydedebileceğiniz bir metin "
#~ "arabelleği.  Buraya gönderilen metin, mevcut metnin sonuna eklenir.  "
#~ "Klinik bir dosyayı işlemeyi bitirdiğinde tamponda herhangi bir metin "
#~ "kalması bir hatadır."

#~ msgid "``file``"
#~ msgstr "``file``"

#, fuzzy
#~ msgid ""
#~ "A separate \"clinic file\" that will be created automatically by Clinic. "
#~ "The filename chosen for the file is ``{basename}.clinic{extension}``, "
#~ "where ``basename`` and ``extension`` were assigned the output from ``os."
#~ "path.splitext()`` run on the current file.  (Example: the ``file`` "
#~ "destination for :file:`_pickle.c` would be written to :file:`_pickle."
#~ "clinic.c`.)"
#~ msgstr ""
#~ "Klinik tarafından otomatik olarak oluşturulacak ayrı bir \"klinik "
#~ "dosyası\". Dosya için seçilen dosya adı ``{basename}.clinic{extension}`` "
#~ "şeklindedir, burada ``basename`` ve ``extension`` mevcut dosya üzerinde "
#~ "çalıştırılan ``os.path.splitext()`` çıktısına atanmıştır.  (Örnek: "
#~ "``_pickle.c`` için ``dosya`` hedefi ``_pickle.clinic.c`` olarak "
#~ "yazılacaktır)."

#~ msgid ""
#~ "**Important: When using a** ``file`` **destination, you** *must check in* "
#~ "**the generated file!**"
#~ msgstr ""
#~ "**Önemli: Bir ** ``dosya`` **hedefi kullanırken, **oluşturulan dosyayı** "
#~ "**mutlaka** kontrol etmelisiniz!"

#~ msgid "``two-pass``"
#~ msgstr "``two-pass``"

#~ msgid ""
#~ "A buffer like ``buffer``.  However, a two-pass buffer can only be dumped "
#~ "once, and it prints out all text sent to it during all processing, even "
#~ "from Clinic blocks *after* the dumping point."
#~ msgstr ""
#~ "Arabellek ``buffer`` gibi bir arabellektir.  Bununla birlikte, iki "
#~ "geçişli bir tampon yalnızca bir kez boşaltılabilir ve boşaltma "
#~ "noktasından *sonraki* Klinik bloklardan bile tüm işlem sırasında "
#~ "kendisine gönderilen tüm metni yazdırır."

#~ msgid "``suppress``"
#~ msgstr "``suppress``"

#~ msgid "The text is suppressed—thrown away."
#~ msgstr "Metin bastırılmış, bir kenara atılmıştır."

#~ msgid ""
#~ "Clinic defines five new directives that let you reconfigure its output."
#~ msgstr ""
#~ "Klinik, çıktısını yeniden yapılandırmanıza olanak tanıyan beş yeni "
#~ "yönerge tanımlar."

#~ msgid "The first new directive is ``dump``:"
#~ msgstr "İlk yeni yönerge ``dump``:"

#~ msgid ""
#~ "This dumps the current contents of the named destination into the output "
#~ "of the current block, and empties it.  This only works with ``buffer`` "
#~ "and ``two-pass`` destinations."
#~ msgstr ""
#~ "Bu, adlandırılmış hedefin mevcut içeriğini geçerli bloğun çıktısına döker "
#~ "ve boşaltır.  Bu sadece ``buffer`` ve ``two-pass`` hedefleri ile çalışır."

#~ msgid ""
#~ "The second new directive is ``output``.  The most basic form of "
#~ "``output`` is like this:"
#~ msgstr ""
#~ "İkinci yeni yönerge ise ``output``.  En temel ``output`` biçimi şöyledir:"

#~ msgid ""
#~ "This tells Clinic to output *field* to *destination*.  ``output`` also "
#~ "supports a special meta-destination, called ``everything``, which tells "
#~ "Clinic to output *all* fields to that *destination*."
#~ msgstr ""
#~ "Bu, Kliniğe *alan* çıktısını *hedefe* vermesini söyler.  ``output`` "
#~ "ayrıca ``everything`` adı verilen ve Kliniğe *tüm* alanların çıktısını bu "
#~ "*hedefe* vermesini söyleyen özel bir meta hedefi de destekler."

#~ msgid "``output`` has a number of other functions:"
#~ msgstr "``output`` bir dizi başka işleve sahiptir:"

#~ msgid ""
#~ "``output push`` and ``output pop`` allow you to push and pop "
#~ "configurations on an internal configuration stack, so that you can "
#~ "temporarily modify the output configuration, then easily restore the "
#~ "previous configuration.  Simply push before your change to save the "
#~ "current configuration, then pop when you wish to restore the previous "
#~ "configuration."
#~ msgstr ""
#~ "``output push`` ve ``output pop`` dahili bir yapılandırma yığınında "
#~ "yapılandırmaları itmenize ve açmanıza izin verir, böylece çıkış "
#~ "yapılandırmasını geçici olarak değiştirebilir ve ardından önceki "
#~ "yapılandırmayı kolayca geri yükleyebilirsiniz.  Geçerli yapılandırmayı "
#~ "kaydetmek için değişikliğinizden önce push yapmanız, ardından önceki "
#~ "yapılandırmayı geri yüklemek istediğinizde pop yapmanız yeterlidir."

#~ msgid ""
#~ "``output preset`` sets Clinic's output to one of several built-in preset "
#~ "configurations, as follows:"
#~ msgstr ""
#~ "``output preset`` Kliniğin çıkışını aşağıdaki gibi çeşitli yerleşik ön "
#~ "ayar yapılandırmalarından birine ayarlar:"

#~ msgid ""
#~ "Clinic's original starting configuration.  Writes everything immediately "
#~ "after the input block."
#~ msgstr ""
#~ "Kliniğin orijinal başlangıç yapılandırması.  Giriş bloğundan hemen sonra "
#~ "her şeyi yazar."

#~ msgid ""
#~ "Suppress the ``parser_prototype`` and ``docstring_prototype``, write "
#~ "everything else to ``block``."
#~ msgstr ""
#~ "Suppress the ``parser_prototype`` and ``docstring_prototype``, write "
#~ "everything else to ``block``."

#~ msgid ""
#~ "Designed to write everything to the \"clinic file\" that it can. You then "
#~ "``#include`` this file near the top of your file. You may need to "
#~ "rearrange your file to make this work, though usually this just means "
#~ "creating forward declarations for various ``typedef`` and "
#~ "``PyTypeObject`` definitions."
#~ msgstr ""
#~ "Yapabildiği her şeyi \"klinik dosyasına\" yazmak için tasarlanmıştır. "
#~ "Daha sonra bu dosyayı dosyanızın en üstüne yakın bir yere ``#include`` "
#~ "edersiniz. Bunun çalışması için dosyanızı yeniden düzenlemeniz "
#~ "gerekebilir, ancak genellikle bu sadece çeşitli ``typedef`` ve "
#~ "``PyTypeObject`` tanımları için ileri bildirimler oluşturmak anlamına "
#~ "gelir."

#~ msgid ""
#~ "Suppress the ``parser_prototype`` and ``docstring_prototype``, write the "
#~ "``impl_definition`` to ``block``, and write everything else to ``file``."
#~ msgstr ""
#~ "``parser_prototype`` ve ``docstring_prototype`` öğelerini bastırın, "
#~ "``impl_definition`` öğesini ``block`` öğesine yazın ve diğer her şeyi "
#~ "``file`` öğesine yazın."

#~ msgid "The default filename is ``\"{dirname}/clinic/{basename}.h\"``."
#~ msgstr ""
#~ "Varsayılan dosya adı ``\"{dirname}/clinic/{basename}.h\"`` şeklindedir."

#~ msgid ""
#~ "Save up most of the output from Clinic, to be written into your file near "
#~ "the end.  For Python files implementing modules or builtin types, it's "
#~ "recommended that you dump the buffer just above the static structures for "
#~ "your module or builtin type; these are normally very near the end.  Using "
#~ "``buffer`` may require even more editing than ``file``, if your file has "
#~ "static ``PyMethodDef`` arrays defined in the middle of the file."
#~ msgstr ""
#~ "Clinic'ten gelen çıktının çoğunu, sonuna yakın dosyanıza yazılmak üzere "
#~ "kaydedin.  Modülleri veya yerleşik tipleri uygulayan Python dosyaları "
#~ "için, tamponu modülünüz veya yerleşik tipiniz için statik yapıların hemen "
#~ "üzerine boşaltmanız önerilir; bunlar normalde sona çok yakındır.  "
#~ "Dosyanızın ortasında tanımlanmış statik ``PyMethodDef`` dizileri varsa, "
#~ "``buffer`` kullanmak ``file`` kullanmaktan daha fazla düzenleme "
#~ "gerektirebilir."

#~ msgid ""
#~ "Suppress the ``parser_prototype``, ``impl_prototype``, and "
#~ "``docstring_prototype``, write the ``impl_definition`` to ``block``, and "
#~ "write everything else to ``file``."
#~ msgstr ""
#~ "``parser_prototype``, ``impl_prototype`` ve ``docstring_prototype`` "
#~ "öğelerini bastırın, ``impl_definition`` öğesini ``block`` öğesine yazın "
#~ "ve diğer her şeyi ``file`` öğesine yazın."

#~ msgid ""
#~ "Similar to the ``buffer`` preset, but writes forward declarations to the "
#~ "``two-pass`` buffer, and definitions to the ``buffer``. This is similar "
#~ "to the ``buffer`` preset, but may require less editing than ``buffer``.  "
#~ "Dump the ``two-pass`` buffer near the top of your file, and dump the "
#~ "``buffer`` near the end just like you would when using the ``buffer`` "
#~ "preset."
#~ msgstr ""
#~ "Bu ``buffer`` ön ayarına benzer, ancak ileri bildirimleri ``two-pass`` "
#~ "tamponuna ve tanımları ``buffer`` tamponuna yazar. Bu ``buffer`` ön "
#~ "ayarına benzer, ancak ``buffer``'dan daha az düzenleme gerektirebilir.  "
#~ "Dosyanızın üst kısmına yakın ``two-pass`` tamponunu boşaltın ve "
#~ "``buffer`` ön ayarını kullanırken yaptığınız gibi sonuna yakın "
#~ "``buffer``'ı boşaltın."

#~ msgid ""
#~ "Suppresses the ``impl_prototype``, write the ``impl_definition`` to "
#~ "``block``, write ``docstring_prototype``, ``methoddef_define``, and "
#~ "``parser_prototype`` to ``two-pass``, write everything else to ``buffer``."
#~ msgstr ""
#~ "``impl_prototype``'ı bastırır, ``impl_definition``'ı ``block``'a yazar, "
#~ "``docstring_prototype``, ``methoddef_define`` ve ``parser_prototype``'ı "
#~ "``two-pass``'a yazar, diğer her şeyi ``buffer``'a yazar."

#~ msgid "``partial-buffer``"
#~ msgstr "``partial-buffer``"

#~ msgid ""
#~ "Similar to the ``buffer`` preset, but writes more things to ``block``, "
#~ "only writing the really big chunks of generated code to ``buffer``. This "
#~ "avoids the definition-before-use problem of ``buffer`` completely, at the "
#~ "small cost of having slightly more stuff in the block's output. Dump the "
#~ "``buffer`` near the end, just like you would when using the ``buffer`` "
#~ "preset."
#~ msgstr ""
#~ "``buffer`` ön ayarına benzer, ancak ``block``'a daha fazla şey yazar, "
#~ "yalnızca oluşturulan kodun gerçekten büyük parçalarını ``buffer``'a "
#~ "yazar. Bu, bloğun çıktısında biraz daha fazla şey olması gibi küçük bir "
#~ "maliyetle, ``buffer``'ın kullanımdan önce tanımlama sorununu tamamen "
#~ "ortadan kaldırır. Tıpkı ``buffer`` ön ayarını kullanırken yaptığınız "
#~ "gibi, ``buffer``'ı sonuna doğru boşaltın."

#~ msgid ""
#~ "Suppresses the ``impl_prototype``, write the ``docstring_definition`` and "
#~ "``parser_definition`` to ``buffer``, write everything else to ``block``."
#~ msgstr ""
#~ "``impl_prototype`` ı bastırır, ``docstring_definition`` ve "
#~ "``parser_definition`` ı ``buffer`` a yazar, diğer her şeyi ``block`` a "
#~ "yazar."

#~ msgid "The third new directive is ``destination``:"
#~ msgstr "Üçüncü yeni yönerge ``destination`` dır:"

#~ msgid "This performs an operation on the destination named ``name``."
#~ msgstr "Bu, ``name`` adlı hedef üzerinde bir işlem gerçekleştirir."

#~ msgid "There are two defined subcommands: ``new`` and ``clear``."
#~ msgstr "Tanımlanmış iki alt komut vardır: ``new`` ve ``clear``."

#~ msgid "The ``new`` subcommand works like this:"
#~ msgstr "``new`` alt komutu şu şekilde çalışır:"

#~ msgid ""
#~ "This creates a new destination with name ``<name>`` and type ``<type>``."
#~ msgstr ""
#~ "Bu, adı ``<name>`` ve türü ``<type>`` olan yeni bir hedef oluşturur."

#~ msgid "There are five destination types:"
#~ msgstr "Beş hedef türü vardır:"

#~ msgid "Throws the text away."
#~ msgstr "Metni atıyor."

#~ msgid ""
#~ "Writes the text to the current block.  This is what Clinic originally did."
#~ msgstr "Metni geçerli bloğa yazar.  Kliniğin başlangıçta yaptığı budur."

#~ msgid "A simple text buffer, like the \"buffer\" builtin destination above."
#~ msgstr "Yukarıdaki \"buffer\" yerleşik hedefi gibi basit bir metin tamponu."

#~ msgid ""
#~ "A text file.  The file destination takes an extra argument, a template to "
#~ "use for building the filename, like so:"
#~ msgstr ""
#~ "Bir metin dosyası.  Dosya hedefi, dosya adını oluşturmak için "
#~ "kullanılacak bir şablon olan ekstra bir argüman alır, aşağıdaki gibi:"

#~ msgid "destination <name> new <type> <file_template>"
#~ msgstr "hedef <isim> yeni <tip> <dosya_şablonu>"

#~ msgid ""
#~ "The template can use three strings internally that will be replaced by "
#~ "bits of the filename:"
#~ msgstr ""
#~ "Şablon dahili olarak dosya adının bitleriyle değiştirilecek üç dizge "
#~ "kullanabilir:"

#~ msgid "{path}"
#~ msgstr "{path}"

#~ msgid "The full path to the file, including directory and full filename."
#~ msgstr "Dizin ve tam dosya adı dahil olmak üzere dosyanın tam yolu."

#~ msgid "{dirname}"
#~ msgstr "{dirname}"

#~ msgid "The name of the directory the file is in."
#~ msgstr "Dosyanın içinde bulunduğu dizinin adı."

#~ msgid "{basename}"
#~ msgstr "{basename}"

#~ msgid "Just the name of the file, not including the directory."
#~ msgstr "Sadece dosyanın adı, dizin dahil değil."

#~ msgid "{basename_root}"
#~ msgstr "{basename_root}"

#~ msgid ""
#~ "Basename with the extension clipped off (everything up to but not "
#~ "including the last '.')."
#~ msgstr "Uzantısı kırpılmış temel ad (son '.' dahil olmak üzere her şey)."

#~ msgid "{basename_extension}"
#~ msgstr "{basename_extension}"

#~ msgid ""
#~ "The last '.' and everything after it.  If the basename does not contain a "
#~ "period, this will be the empty string."
#~ msgstr ""
#~ "Son '.' ve ondan sonraki her şey.  Ana ad nokta içermiyorsa, bu boş bir "
#~ "dize olacaktır."

#~ msgid ""
#~ "If there are no periods in the filename, {basename} and {filename} are "
#~ "the same, and {extension} is empty.  \"{basename}{extension}\" is always "
#~ "exactly the same as \"{filename}\".\""
#~ msgstr ""
#~ "Dosya adında nokta yoksa, {basename} ve {filename} aynıdır ve {extension} "
#~ "boştur.  \"{basename}{extension}\" her zaman \"{filename}\" ile tamamen "
#~ "aynıdır.\""

#~ msgid "A two-pass buffer, like the \"two-pass\" builtin destination above."
#~ msgstr ""
#~ "Yukarıdaki \"iki geçişli\" yerleşik hedef gibi iki geçişli bir tampon."

#~ msgid "The ``clear`` subcommand works like this:"
#~ msgstr "``clear`` alt komutu şu şekilde çalışır:"

#~ msgid ""
#~ "It removes all the accumulated text up to this point in the destination. "
#~ "(I don't know what you'd need this for, but I thought maybe it'd be "
#~ "useful while someone's experimenting.)"
#~ msgstr ""
#~ "Hedefte bu noktaya kadar birikmiş tüm metni kaldırır. (Buna ne için "
#~ "ihtiyaç duyacağınızı bilmiyorum, ancak birileri deneme yaparken belki "
#~ "yararlı olabileceğini düşündüm)."

#~ msgid "The fourth new directive is ``set``:"
#~ msgstr "Dördüncü yeni yönerge ``set``'tir:"

#~ msgid ""
#~ "``set`` lets you set two internal variables in Clinic. ``line_prefix`` is "
#~ "a string that will be prepended to every line of Clinic's output; "
#~ "``line_suffix`` is a string that will be appended to every line of "
#~ "Clinic's output."
#~ msgstr ""
#~ "``set`` Klinikte iki dahili değişkeni ayarlamanızı sağlar. "
#~ "``line_prefix``, Kliniğin çıktısının her satırına eklenecek bir dizedir; "
#~ "``line_suffix``, Kliniğin çıktısının her satırına eklenecek bir dizedir."

#~ msgid "Both of these support two format strings:"
#~ msgstr "Bunların her ikisi de iki biçim dizesini destekler:"

#~ msgid "``{block comment start}``"
#~ msgstr "``{block comment start}``"

#~ msgid ""
#~ "Turns into the string ``/*``, the start-comment text sequence for C files."
#~ msgstr ""
#~ "C dosyaları için başlangıç-yorum metin dizisi olan ``/*`` dizesine "
#~ "dönüşür."

#~ msgid "``{block comment end}``"
#~ msgstr "``{block comment end}``"

#~ msgid ""
#~ "Turns into the string ``*/``, the end-comment text sequence for C files."
#~ msgstr ""
#~ "C dosyaları için yorum sonu metin dizisi olan ``*/`` dizesine dönüşür."

#~ msgid ""
#~ "The final new directive is one you shouldn't need to use directly, called "
#~ "``preserve``:"
#~ msgstr ""
#~ "Son yeni yönerge doğrudan kullanmanız gerekmeyen bir yönerge olup "
#~ "``preserve`` olarak adlandırılmıştır:"

#~ msgid ""
#~ "This tells Clinic that the current contents of the output should be kept, "
#~ "unmodified. This is used internally by Clinic when dumping output into "
#~ "``file`` files; wrapping it in a Clinic block lets Clinic use its "
#~ "existing checksum functionality to ensure the file was not modified by "
#~ "hand before it gets overwritten."
#~ msgstr ""
#~ "Bu, Clinic'e çıktının mevcut içeriğinin değiştirilmeden tutulması "
#~ "gerektiğini söyler. Bu, çıktıyı ``file`` dosyalarına dökerken Clinic "
#~ "tarafından dahili olarak kullanılır; bunu bir Clinic bloğuna sarmak, "
#~ "dosyanın üzerine yazılmadan önce elle değiştirilmediğinden emin olmak "
#~ "için Clinic'in mevcut sağlama toplamı işlevini kullanmasını sağlar."

#, fuzzy
#~ msgid "How to use the ``#ifdef`` trick"
#~ msgstr "#ifdef hilesi"

#~ msgid ""
#~ "If you're converting a function that isn't available on all platforms, "
#~ "there's a trick you can use to make life a little easier.  The existing "
#~ "code probably looks like this::"
#~ msgstr ""
#~ "Tüm platformlarda bulunmayan bir fonksiyonu dönüştürüyorsanız, hayatı "
#~ "biraz daha kolaylaştırmak için kullanabileceğiniz bir numara var.  Mevcut "
#~ "kod muhtemelen şuna benzer::"

#~ msgid ""
#~ "And then in the ``PyMethodDef`` structure at the bottom the existing code "
#~ "will have:"
#~ msgstr "Ve sonra alttaki ``PyMethodDef`` yapısında mevcut kod olacaktır:"

#~ msgid ""
#~ "In this scenario, you should enclose the body of your impl function "
#~ "inside the ``#ifdef``, like so::"
#~ msgstr ""
#~ "Bu senaryoda, impl fonksiyonunuzun gövdesini aşağıdaki gibi ``#ifdef`` "
#~ "içine almalısınız::"

#, fuzzy
#~ msgid ""
#~ "Then, remove those three lines from the :c:type:`PyMethodDef` structure, "
#~ "replacing them with the macro Argument Clinic generated:"
#~ msgstr ""
#~ "Ardından, bu üç satırı ``PyMethodDef`` yapısından kaldırın ve bunların "
#~ "yerine Argument Clinic makrosunu oluşturun:"

#~ msgid ""
#~ "(You can find the real name for this macro inside the generated code. Or "
#~ "you can calculate it yourself: it's the name of your function as defined "
#~ "on the first line of your block, but with periods changed to underscores, "
#~ "uppercased, and ``\"_METHODDEF\"`` added to the end.)"
#~ msgstr ""
#~ "(Bu makronun gerçek adını oluşturulan kodun içinde bulabilirsiniz. Ya da "
#~ "kendiniz hesaplayabilirsiniz: bloğunuzun ilk satırında tanımlanan "
#~ "fonksiyonunuzun adıdır, ancak noktalar alt çizgi olarak değiştirilir, "
#~ "büyük harfle yazılır ve sonuna ``\"_METHODDEF\"`` eklenir)"

#~ msgid ""
#~ "Perhaps you're wondering: what if ``HAVE_FUNCTIONNAME`` isn't defined? "
#~ "The ``MODULE_FUNCTIONNAME_METHODDEF`` macro won't be defined either!"
#~ msgstr ""
#~ "Belki de merak ediyorsunuzdur: ``HAVE_FUNCTIONNAME`` tanımlanmamışsa ne "
#~ "olur? ''MODULE_FUNCTIONNAME_METHODDEF'' makrosu da tanımlanmayacaktır!"

#~ msgid ""
#~ "Here's where Argument Clinic gets very clever.  It actually detects that "
#~ "the Argument Clinic block might be deactivated by the ``#ifdef``.  When "
#~ "that happens, it generates a little extra code that looks like this::"
#~ msgstr ""
#~ "Argüman Kliniği burada çok akıllıca davranır.  Aslında Argüman Kliniği "
#~ "bloğunun ``#ifdef`` tarafından devre dışı bırakılabileceğini algılar.  Bu "
#~ "olduğunda, şuna benzeyen küçük bir ekstra kod oluşturur::"

#~ msgid ""
#~ "That means the macro always works.  If the function is defined, this "
#~ "turns into the correct structure, including the trailing comma.  If the "
#~ "function is undefined, this turns into nothing."
#~ msgstr ""
#~ "Bu, makronun her zaman çalıştığı anlamına gelir.  İşlev tanımlıysa, bu, "
#~ "sondaki virgül de dahil olmak üzere doğru yapıya dönüşür.  İşlev "
#~ "tanımlanmamışsa, bu hiçbir şeye dönüşmez."

#~ msgid ""
#~ "However, this causes one ticklish problem: where should Argument Clinic "
#~ "put this extra code when using the \"block\" output preset?  It can't go "
#~ "in the output block, because that could be deactivated by the "
#~ "``#ifdef``.  (That's the whole point!)"
#~ msgstr ""
#~ "Ancak bu, can sıkıcı bir soruna neden olmaktadır: Argüman Kliniği "
#~ "\"blok\" çıktı ön ayarını kullanırken bu ekstra kodu nereye koymalıdır?  "
#~ "Çıkış bloğuna koyulamaz, çünkü ``#ifdef`` tarafından devre dışı "
#~ "bırakılabilir.  (Bütün mesele bu!)"

#~ msgid ""
#~ "In this situation, Argument Clinic writes the extra code to the "
#~ "\"buffer\" destination. This may mean that you get a complaint from "
#~ "Argument Clinic:"
#~ msgstr ""
#~ "Bu durumda, Argüman Kliniği ekstra kodu \"tampon\" hedefine yazar. Bu, "
#~ "Argüman Kliniği'nden bir şikayet almanız anlamına gelebilir:"

#, fuzzy
#~ msgid ""
#~ "When this happens, just open your file, find the ``dump buffer`` block "
#~ "that Argument Clinic added to your file (it'll be at the very bottom), "
#~ "then move it above the :c:type:`PyMethodDef` structure where that macro "
#~ "is used."
#~ msgstr ""
#~ "Bu olduğunda, dosyanızı açın, Argüman Kliniği'nin dosyanıza eklediği "
#~ "``dump buffer`` bloğunu bulun (en altta olacaktır), ardından bu makronun "
#~ "kullanıldığı ``PyMethodDef`` yapısının üzerine taşıyın."

#, fuzzy
#~ msgid "How to use Argument Clinic in Python files"
#~ msgstr "Python dosyalarında Argüman Kliniği kullanma"

#~ msgid ""
#~ "It's actually possible to use Argument Clinic to preprocess Python files. "
#~ "There's no point to using Argument Clinic blocks, of course, as the "
#~ "output wouldn't make any sense to the Python interpreter.  But using "
#~ "Argument Clinic to run Python blocks lets you use Python as a Python "
#~ "preprocessor!"
#~ msgstr ""
#~ "Aslında Python dosyalarını önceden işlemek için Argüman Kliniği kullanmak "
#~ "mümkündür. Argüman Kliniği bloklarını kullanmanın bir anlamı yok elbette, "
#~ "çünkü çıktı Python yorumlayıcısı için bir anlam ifade etmeyecektir.  "
#~ "Ancak Python bloklarını çalıştırmak için Argüman Kliniği'ni kullanmak "
#~ "Python'u bir Python önişlemcisi olarak kullanmanızı sağlar!"

#~ msgid ""
#~ "Since Python comments are different from C comments, Argument Clinic "
#~ "blocks embedded in Python files look slightly different.  They look like "
#~ "this:"
#~ msgstr ""
#~ "Python yorumları C yorumlarından farklı olduğu için, Python dosyalarına "
#~ "gömülü Argüman Kliniği blokları biraz farklı görünür.  Şöyle görünürler:"

#~ msgid "``Py_UNICODE``"
#~ msgstr "``Py_UNICODE``"

#~ msgid "``Py_UNICODE(zeroes=True)``"
#~ msgstr "``Py_UNICODE(zeroes=True)``"

#~ msgid "``Py_UNICODE(accept={str, NoneType})``"
#~ msgstr "``Py_UNICODE(accept={str, NoneType})``"

#~ msgid "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"
#~ msgstr "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"

#~ msgid ""
#~ "(There's also an experimental ``NoneType`` converter, which lets you "
#~ "return ``Py_None`` on success or ``NULL`` on failure, without having to "
#~ "increment the reference count on ``Py_None``.  I'm not sure it adds "
#~ "enough clarity to be worth using.)"
#~ msgstr ""
#~ "(Ayrıca, ``Py_None`` referans sayısını artırmak zorunda kalmadan, başarı "
#~ "durumunda ``Py_None`` veya başarısızlık durumunda ``NULL`` döndürmenizi "
#~ "sağlayan deneysel bir ``NoneType`` dönüştürücü de vardır.  Kullanmaya "
#~ "değecek kadar netlik kattığından emin değilim.)"

#~ msgid ""
#~ "Argument Clinic is a preprocessor for CPython C files. Its purpose is to "
#~ "automate all the boilerplate involved with writing argument parsing code "
#~ "for \"builtins\". This document shows you how to convert your first C "
#~ "function to work with Argument Clinic, and then introduces some advanced "
#~ "topics on Argument Clinic usage."
#~ msgstr ""
#~ "Argüman Kliniği CPython C dosyaları için bir ön işlemcidir. Amacı, "
#~ "\"builtins\" için argüman ayrıştırma kodunun yazılmasıyla ilgili tüm "
#~ "boilerplate'i otomatikleştirmektir. Bu dokümantasyon size ilk C "
#~ "fonksiyonunuzu Argüman Kliniği ile çalışacak şekilde nasıl "
#~ "dönüştüreceğinizi gösterir ve ardından Argüman Kliniği kullanımıyla "
#~ "ilgili bazı ileri düzey konuları tanıtır."

#~ msgid ""
#~ "Argument Clinic's primary goal is to take over responsibility for all "
#~ "argument parsing code inside CPython.  This means that, when you convert "
#~ "a function to work with Argument Clinic, that function should no longer "
#~ "do any of its own argument parsing—the code generated by Argument Clinic "
#~ "should be a \"black box\" to you, where CPython calls in at the top, and "
#~ "your code gets called at the bottom, with ``PyObject *args`` (and maybe "
#~ "``PyObject *kwargs``) magically converted into the C variables and types "
#~ "you need."
#~ msgstr ""
#~ "Argüman Kliniği'nin birincil amacı CPython içindeki tüm argüman "
#~ "ayrıştırma kodunun sorumluluğunu üstlenmektir.  Bu, bir fonksiyonu "
#~ "Argüman Kliniği ile çalışacak şekilde dönüştürdüğünüzde, bu fonksiyonun "
#~ "artık kendi argüman ayrıştırmasını yapmaması gerektiği anlamına gelir - "
#~ "Argüman Kliniği tarafından üretilen kod sizin için bir \"kara kutu\" "
#~ "olmalıdır, CPython üstte çağırır ve kodunuz altta çağrılır, ``PyObject "
#~ "*args`` (ve belki ``PyObject *kwargs``) sihirli bir şekilde ihtiyacınız "
#~ "olan C değişkenlerine ve türlerine dönüştürülür."

#~ msgid ""
#~ "In order for Argument Clinic to accomplish its primary goal, it must be "
#~ "easy to use.  Currently, working with CPython's argument parsing library "
#~ "is a chore, requiring maintaining redundant information in a surprising "
#~ "number of places. When you use Argument Clinic, you don't have to repeat "
#~ "yourself."
#~ msgstr ""
#~ "Argüman Kliniği'nin birincil amacına ulaşabilmesi için kullanımının kolay "
#~ "olması gerekir.  Şu anda, CPython'un argüman ayrıştırma kütüphanesi ile "
#~ "çalışmak, şaşırtıcı sayıda yerde gereksiz bilgileri korumayı gerektiren "
#~ "bir angarya. Argüman Kliniği'ni kullandığınızda, kendinizi tekrar etmek "
#~ "zorunda kalmazsınız."

#~ msgid ""
#~ "Obviously, no one would want to use Argument Clinic unless it's solving "
#~ "their problem—and without creating new problems of its own. So it's "
#~ "paramount that Argument Clinic generate correct code. It'd be nice if the "
#~ "code was faster, too, but at the very least it should not introduce a "
#~ "major speed regression.  (Eventually Argument Clinic *should* make a "
#~ "major speedup possible—we could rewrite its code generator to produce "
#~ "tailor-made argument parsing code, rather than calling the general-"
#~ "purpose CPython argument parsing library.  That would make for the "
#~ "fastest argument parsing possible!)"
#~ msgstr ""
#~ "Açıkçası, hiç kimse Argüman Kliniği'ni kendi sorununu çözmedikçe ve kendi "
#~ "başına yeni sorunlar yaratmadıkça kullanmak istemeyecektir. Bu yüzden "
#~ "Argüman Kliniği'nin doğru kod üretmesi çok önemlidir. Kodun daha hızlı "
#~ "olması da güzel olurdu, ancak en azından büyük bir hız gerilemesi "
#~ "getirmemelidir.  (Sonunda Argüman Kliniği *büyük bir hızlanmayı mümkün "
#~ "kılmalıdır* - genel amaçlı CPython argüman ayrıştırma kütüphanesini "
#~ "çağırmak yerine, özel argüman ayrıştırma kodu üretmek için kod "
#~ "oluşturucusunu yeniden yazabiliriz.  Bu, mümkün olan en hızlı argüman "
#~ "ayrıştırmasını sağlayacaktır!)"

#~ msgid ""
#~ "Additionally, Argument Clinic must be flexible enough to work with any "
#~ "approach to argument parsing.  Python has some functions with some very "
#~ "strange parsing behaviors; Argument Clinic's goal is to support all of "
#~ "them."
#~ msgstr ""
#~ "Ek olarak, Argüman Kliniği argüman ayrıştırmaya yönelik herhangi bir "
#~ "yaklaşımla çalışabilecek kadar esnek olmalıdır.  Python'un çok garip "
#~ "ayrıştırma davranışlarına sahip bazı fonksiyonları vardır; Argüman "
#~ "Kliniği'nin amacı bunların hepsini desteklemektir."

#~ msgid ""
#~ "Finally, the original motivation for Argument Clinic was to provide "
#~ "introspection \"signatures\" for CPython builtins. It used to be, the "
#~ "introspection query functions would throw an exception if you passed in a "
#~ "builtin.  With Argument Clinic, that's a thing of the past!"
#~ msgstr ""
#~ "Son olarak, Argüman Kliniği'nin asıl motivasyonu CPython yerleşik "
#~ "bileşenleri için iç gözlem \"imzaları\" sağlamaktı. Eskiden, iç gözlem "
#~ "sorgu işlevleri, bir yerleşik geçerseniz bir istisna atardı.  Argüman "
#~ "Kliniği ile bu geçmişte kaldı!"

#~ msgid ""
#~ "One idea you should keep in mind, as you work with Argument Clinic: the "
#~ "more information you give it, the better job it'll be able to do. "
#~ "Argument Clinic is admittedly relatively simple right now.  But as it "
#~ "evolves it will get more sophisticated, and it should be able to do many "
#~ "interesting and smart things with all the information you give it."
#~ msgstr ""
#~ "Argüman Kliniği ile çalışırken aklınızda tutmanız gereken bir fikir var: "
#~ "Ona ne kadar çok bilgi verirseniz, o kadar iyi iş çıkaracaktır. Argüman "
#~ "Kliniği kuşkusuz şu anda nispeten basittir.  Ancak geliştikçe daha "
#~ "sofistike hale gelecek ve ona verdiğiniz tüm bilgilerle birçok ilginç ve "
#~ "akıllıca şey yapabilecektir."

#~ msgid ""
#~ "Argument Clinic ships with CPython; you'll find it in ``Tools/clinic/"
#~ "clinic.py``. If you run that script, specifying a C file as an argument:"
#~ msgstr ""
#~ "Argüman Kliniği CPython ile birlikte gelir; ``Tools/clinic/clinic.py`` "
#~ "içinde bulabilirsiniz. Bu dizeyi çalıştırırsanız, argüman olarak bir C "
#~ "dosyası belirtirseniz:"

#~ msgid ""
#~ "Argument Clinic will scan over the file looking for lines that look "
#~ "exactly like this:"
#~ msgstr ""
#~ "Argüman Kliniği dosyayı tarayarak tam olarak buna benzeyen satırları "
#~ "arayacaktır:"

#~ msgid ""
#~ "Everything in between these two lines is input for Argument Clinic. All "
#~ "of these lines, including the beginning and ending comment lines, are "
#~ "collectively called an Argument Clinic \"block\"."
#~ msgstr ""
#~ "Bu iki satır arasındaki her şey Argüman Kliniği için girdidir. Başlangıç "
#~ "ve bitiş yorum satırları da dahil olmak üzere tüm bu satırlara topluca "
#~ "Argüman Kliniği \"bloğu\" denir."

#~ msgid ""
#~ "When Argument Clinic parses one of these blocks, it generates output.  "
#~ "This output is rewritten into the C file immediately after the block, "
#~ "followed by a comment containing a checksum. The Argument Clinic block "
#~ "now looks like this:"
#~ msgstr ""
#~ "Argüman Kliniği bu bloklardan birini ayrıştırdığında çıktı üretir.  Bu "
#~ "çıktı, bloktan hemen sonra C dosyasına yeniden yazılır ve ardından bir "
#~ "sağlama toplamı içeren bir yorum eklenir. Argüman Kliniği bloğu şimdi "
#~ "şöyle görünür:"

#~ msgid ""
#~ "You should never modify the output portion of an Argument Clinic block.  "
#~ "Instead, change the input until it produces the output you want.  (That's "
#~ "the purpose of the checksum—to detect if someone changed the output, as "
#~ "these edits would be lost the next time Argument Clinic writes out fresh "
#~ "output.)"
#~ msgstr ""
#~ "Bir Argüman Kliniği bloğunun çıktı kısmını asla değiştirmemelisiniz.  "
#~ "Bunun yerine, istediğiniz çıktıyı üretene kadar girdiyi değiştirin.  "
#~ "(Sağlama toplamının amacı budur - birisinin çıktıyı değiştirip "
#~ "değiştirmediğini tespit etmek, çünkü bu düzenlemeler Argüman Kliniği bir "
#~ "sonraki sefer yeni çıktı yazdığında kaybolacaktır)"

#~ msgid ""
#~ "For the sake of clarity, here's the terminology we'll use with Argument "
#~ "Clinic:"
#~ msgstr ""
#~ "Açıklık getirmek adına, Argüman Kliniği ile ilgili kullanacağımız "
#~ "terminolojiyi burada bulabilirsiniz:"

#~ msgid ""
#~ "The first line of the comment (``/*[clinic input]``) is the *start line*."
#~ msgstr "Yorumun ilk satırı (``/*[clinic input]``) *başlangıç satırıdır*."

#~ msgid ""
#~ "The last line of the initial comment (``[clinic start generated code]*/"
#~ "``) is the *end line*."
#~ msgstr ""
#~ "İlk yorumun son satırı (``[clinic start generated code]*/``) *son "
#~ "satırdır*."

#~ msgid ""
#~ "The last line (``/*[clinic end generated code: checksum=...]*/``) is the "
#~ "*checksum line*."
#~ msgstr ""
#~ "Son satır (``/*[clinic end generated code: checksum=...]*/``) *checksum "
#~ "line*."

#~ msgid "In between the start line and the end line is the *input*."
#~ msgstr "Yorumun ilk satırı (``/*[clinic input]``) *başlangıç satırıdır*."

#~ msgid ""
#~ "All the text collectively, from the start line to the checksum line "
#~ "inclusively, is the *block*.  (A block that hasn't been successfully "
#~ "processed by Argument Clinic yet doesn't have output or a checksum line, "
#~ "but it's still considered a block.)"
#~ msgstr ""
#~ "Başlangıç satırından sağlama toplamı satırına kadar tüm metin toplu "
#~ "olarak *blok*'tur.  (Argüman Kliniği tarafından henüz başarılı bir "
#~ "şekilde işlenmemiş bir bloğun çıktısı veya sağlama satırı yoktur, ancak "
#~ "yine de bir blok olarak kabul edilir)"

#~ msgid "Converting Your First Function"
#~ msgstr "İlk Fonksiyonunuzu Dönüştürme"

#~ msgid "Let's dive in!"
#~ msgstr "Hadi dalalım!"

#~ msgid "The general form of these parameter lines is as follows:"
#~ msgstr "Bu parametre satırlarının genel formu aşağıdaki gibidir:"

#~ msgid ""
#~ "Currently this is all-or-nothing; either all parameters are positional-"
#~ "only, or none of them are.  (In the future Argument Clinic may relax this "
#~ "restriction.)"
#~ msgstr ""
#~ "Şu anda bu ya hep ya hiçtir; ya tüm parametreler yalnızca konumsaldır ya "
#~ "da hiçbiri değildir.  (Gelecekte Argüman Kliniği bu kısıtlamayı "
#~ "gevşetebilir)"

#~ msgid ""
#~ "Well, except for one difference: ``inspect.signature()`` run on your "
#~ "function should now provide a valid signature!"
#~ msgstr ""
#~ "Tek bir fark dışında: fonksiyonunuz üzerinde çalıştırılan ``inspect."
#~ "signature()`` artık geçerli bir imza sağlamalıdır!"

#~ msgid "Advanced Topics"
#~ msgstr "İleri Düzey Konular"

#~ msgid ""
#~ "Now that you've had some experience working with Argument Clinic, it's "
#~ "time for some advanced topics."
#~ msgstr ""
#~ "Argüman Kliniği ile çalışma konusunda biraz deneyim kazandığınıza göre, "
#~ "bazı ileri düzey konuların zamanı geldi."

#~ msgid "``type``"
#~ msgstr "``type``"

#~ msgid "Py_buffer"
#~ msgstr "Py_buffer"

#~ msgid "Parameter default values"
#~ msgstr "Parametre varsayılan değerleri"

#~ msgid "Using a return converter"
#~ msgstr "Dönüş dönüştürücüsü kullanma"

#~ msgid ""
#~ "None of these take parameters.  For the first three, return -1 to "
#~ "indicate error.  For ``DecodeFSDefault``, the return type is ``const char "
#~ "*``; return a ``NULL`` pointer to indicate an error."
#~ msgstr ""
#~ "Bunların hiçbiri parametre almaz.  İlk üçü için, hatayı belirtmek üzere "
#~ "-1 döndürülür.  ``DecodeFSDefault`` için dönüş türü ``const char *``'dır; "
#~ "bir hata belirtmek için ``NULL`` işaretçisi döndürür."

#~ msgid ""
#~ "There are some additional members of ``CConverter`` you may wish to "
#~ "specify in your subclass.  Here's the current list:"
#~ msgstr ""
#~ "Alt sınıfınızda belirtmek isteyebileceğiniz bazı ek ``CConverter`` "
#~ "üyeleri vardır.  İşte mevcut liste:"

#~ msgid "``default``"
#~ msgstr "``default``"

#~ msgid "``py_default``"
#~ msgstr "``py_default``"

#~ msgid "``c_ignored_default``"
#~ msgstr "``c_ignored_default``"

#~ msgid "``impl_by_reference``"
#~ msgstr "``impl_by_reference``"

#~ msgid "``parse_by_reference``"
#~ msgstr "``parse_by_reference``"

#~ msgid "METH_O and METH_NOARGS"
#~ msgstr "METH_O ve METH_NOARGS"
