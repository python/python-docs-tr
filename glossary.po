# Python Documentation Turkish Translation
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-17 01:28+0300\n"
"PO-Revision-Date: 2022-12-28 16:12-0500\n"
"Last-Translator: \n"
"Language-Team: TURKISH <python.docs.tr@gmail.com>\n"
"Language: tr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.2.2\n"

#: glossary.rst:5
msgid "Glossary"
msgstr "Sözlük"

#: glossary.rst:10
msgid "``>>>``"
msgstr "``>>>``"

#: glossary.rst:12
msgid ""
"The default Python prompt of the interactive shell.  Often seen for code "
"examples which can be executed interactively in the interpreter."
msgstr ""
"Etkileşimli kabuğun varsayılan Python istemi. Genellikle yorumlayıcıda "
"etkileşimli olarak yürütülebilen kod örnekleri için görülür."

#: glossary.rst:14
msgid "``...``"
msgstr "``...``"

#: glossary.rst:16
msgid "Can refer to:"
msgstr "Şunlara başvurabilir:"

#: glossary.rst:18
msgid ""
"The default Python prompt of the interactive shell when entering the code "
"for an indented code block, when within a pair of matching left and right "
"delimiters (parentheses, square brackets, curly braces or triple quotes), or "
"after specifying a decorator."
msgstr ""
"Girintili bir kod bloğu için kod girerken, eşleşen bir çift sol ve sağ "
"sınırlayıcı (parantez, köşeli parantez, kaşlı ayraç veya üçlü tırnak) "
"içindeyken veya bir dekoratör belirttikten sonra etkileşimli kabuğun "
"varsayılan Python istemi."

#: glossary.rst:23
msgid "The :const:`Ellipsis` built-in constant."
msgstr ":const:`Elipsis` yerleşik sabiti."

#: glossary.rst:24
msgid "2to3"
msgstr "2to3"

#: glossary.rst:26
msgid ""
"A tool that tries to convert Python 2.x code to Python 3.x code by handling "
"most of the incompatibilities which can be detected by parsing the source "
"and traversing the parse tree."
msgstr ""
"Kaynağı ayrıştırarak ve ayrıştırma ağacında gezinerek tespit edilebilecek "
"uyumsuzlukların çoğunu işleyerek Python 2.x kodunu Python 3.x koduna "
"dönüştürmeye çalışan bir araç."

#: glossary.rst:30
msgid ""
"2to3 is available in the standard library as :mod:`lib2to3`; a standalone "
"entry point is provided as :file:`Tools/scripts/2to3`.  See :ref:`2to3-"
"reference`."
msgstr ""
"2to3, standart kütüphanede :mod:`lib2to3'; bağımsız bir giriş noktası şu "
"şekilde sağlanır:file:`Tools/scripts/2to3`. Bakınız :ref:`2to3-reference`."

#: glossary.rst:33
msgid "abstract base class"
msgstr "soyut temel sınıf"

#: glossary.rst:35
msgid ""
"Abstract base classes complement :term:`duck-typing` by providing a way to "
"define interfaces when other techniques like :func:`hasattr` would be clumsy "
"or subtly wrong (for example with :ref:`magic methods <special-lookup>`).  "
"ABCs introduce virtual subclasses, which are classes that don't inherit from "
"a class but are still recognized by :func:`isinstance` and :func:"
"`issubclass`; see the :mod:`abc` module documentation.  Python comes with "
"many built-in ABCs for data structures (in the :mod:`collections.abc` "
"module), numbers (in the :mod:`numbers` module), streams (in the :mod:`io` "
"module), import finders and loaders (in the :mod:`importlib.abc` module).  "
"You can create your own ABCs with the :mod:`abc` module."
msgstr ""
"Soyut temel sınıflar :term:`duck-typing` 'i, :func:`hasattr` gibi diğer "
"teknikler beceriksiz veya tamamen yanlış olduğunda arayüzleri tanımlamanın "
"bir yolunu sağlayarak tamamlar (örneğin :ref:`sihirli yöntemlerle <special-"
"lookup>`).  ABC'ler, bir sınıftan miras almayan ancak yine de :func:"
"`isinstance` ve :func:`issubclass` tarafından tanınan sınıflar olan sanal "
"alt sınıfları tanıtır; :mod:`abc` modül belgelerine bakın.  Python comes "
"with many built-in ABCs for data structures (in the :mod:`collections.abc` "
"module), numbers (in the :mod:`numbers` module), streams (in the :mod:`io` "
"module), import finders and loaders (in the :mod:`importlib.abc` module).  :"
"mod:`abc` modülü ile kendi ABC'lerinizi oluşturabilirsiniz."

#: glossary.rst:46
msgid "annotation"
msgstr "dipnot"

#: glossary.rst:48
msgid ""
"A label associated with a variable, a class attribute or a function "
"parameter or return value, used by convention as a :term:`type hint`."
msgstr ""
"Bir değişkenle, bir sınıf niteliğiyle veya bir fonksiyon parametresiyle veya "
"bir dönüş değeriyle ilişkilendirilen, gelenek olarak :term:`type hint <type "
"hint>` biçiminde kullanılan bir etiket."

#: glossary.rst:52
msgid ""
"Annotations of local variables cannot be accessed at runtime, but "
"annotations of global variables, class attributes, and functions are stored "
"in the :attr:`__annotations__` special attribute of modules, classes, and "
"functions, respectively."
msgstr ""
"Yerel değişkenlerin açıklamalarına çalışma zamanında erişilemez, ancak "
"global değişkenlerin, sınıf niteliklerinin ve işlevlerin açıklamaları, "
"sırasıyla modüllerin, sınıfların ve işlevlerin :attr:`__annotations__` özel "
"özelliğinde saklanır."

#: glossary.rst:58
msgid ""
"See :term:`variable annotation`, :term:`function annotation`, :pep:`484` "
"and :pep:`526`, which describe this functionality. Also see :ref:"
"`annotations-howto` for best practices on working with annotations."
msgstr ""
"Bu işlevi açıklayan :term:`variable annotation`, :term:`function "
"annotation`, :pep:`484` ve :pep:`526`'e bakın. Ek açıklamalarla çalışmaya "
"ilişkin en iyi uygulamalar için ayrıca bkz. :ref:`annotations-howto`."

#: glossary.rst:62
msgid "argument"
msgstr "argüman"

#: glossary.rst:64
msgid ""
"A value passed to a :term:`function` (or :term:`method`) when calling the "
"function.  There are two kinds of argument:"
msgstr ""
"Fonksiyon çağrılırken bir :term:`function` 'a (veya :term:`method`) "
"geçirilen bir değer. İki tür argüman vardır:"

#: glossary.rst:67
msgid ""
":dfn:`keyword argument`: an argument preceded by an identifier (e.g. "
"``name=``) in a function call or passed as a value in a dictionary preceded "
"by ``**``.  For example, ``3`` and ``5`` are both keyword arguments in the "
"following calls to :func:`complex`::"
msgstr ""
":dfn:`keyword argument`: bir işlev çağrısında bir tanımlayıcının (ör. "
"``ad=``) önüne geçen veya bir sözlükte ``**`` ile başlayan bir değer olarak "
"geçirilen bir argüman.  Örneğin, ``3`` ve ``5``, aşağıdaki :func:`complex`: "
"çağrılarında anahtar kelimenin argümanleridir:"

#: glossary.rst:75
msgid ""
":dfn:`positional argument`: an argument that is not a keyword argument. "
"Positional arguments can appear at the beginning of an argument list and/or "
"be passed as elements of an :term:`iterable` preceded by ``*``. For example, "
"``3`` and ``5`` are both positional arguments in the following calls::"
msgstr ""
":dfn:`positional argument`: anahtar kelime argümanı olmayan bir argüman. "
"Konumsal argümanler, bir argüman listesinin başında görünebilir ve/veya "
"``*`` ile başlayan bir :term:`iterable` öğesinin öğeleri olarak "
"iletilebilir. Örneğin, ``3`` ve ``5``, aşağıdaki çağrılarda konumsal "
"argümanlerdir:"

#: glossary.rst:84
msgid ""
"Arguments are assigned to the named local variables in a function body. See "
"the :ref:`calls` section for the rules governing this assignment. "
"Syntactically, any expression can be used to represent an argument; the "
"evaluated value is assigned to the local variable."
msgstr ""
"Argümanler, bir fonksiyon gövdesindeki adlandırılmış yerel değişkenlere "
"atanır. Bu atamayı yöneten kurallar için :ref:`calls` bölümüne bakın. "
"Sözdizimsel olarak, bir argümanı temsil etmek için herhangi bir ifade "
"kullanılabilir; değerlendirilen değer yerel değişkene atanır."

#: glossary.rst:89
msgid ""
"See also the :term:`parameter` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"and :pep:`362`."
msgstr ""
"Ayrıca :term:`parameter` sözlüğü girişine, :ref:`the difference between "
"arguments and parameters <faq-argument-vs-parameter>` hakkındaki SSS "
"sorusuna ve :pep:`362` 'ye bakın."

#: glossary.rst:92
msgid "asynchronous context manager"
msgstr "asenkron bağlam yöneticisi"

#: glossary.rst:94
msgid ""
"An object which controls the environment seen in an :keyword:`async with` "
"statement by defining :meth:`__aenter__` and :meth:`__aexit__` methods.  "
"Introduced by :pep:`492`."
msgstr ""
":keyword:`async with` ifadesinde görülen ortamı :meth:`__aenter__` ve :meth:"
"`__aexit__` yöntemlerini tanımlayarak kontrol eden bir nesne.  :pep:`492` de "
"anlatıldı."

#: glossary.rst:97
msgid "asynchronous generator"
msgstr "asenkron jeneratör"

#: glossary.rst:99
msgid ""
"A function which returns an :term:`asynchronous generator iterator`.  It "
"looks like a coroutine function defined with :keyword:`async def` except "
"that it contains :keyword:`yield` expressions for producing a series of "
"values usable in an :keyword:`async for` loop."
msgstr ""
":term:`asynchronous generator iterator` döndüren bir işlev.  Bir :keyword:"
"`async for` döngüsünde kullanılabilen bir dizi değer üretmek için :keyword:"
"`yield` ifadeleri içermesi dışında :keyword:`async def` ile tanımlanmış bir "
"eşyordam işlevine benziyor."

#: glossary.rst:104
msgid ""
"Usually refers to an asynchronous generator function, but may refer to an "
"*asynchronous generator iterator* in some contexts.  In cases where the "
"intended meaning isn't clear, using the full terms avoids ambiguity."
msgstr ""
"Genellikle bir asenkron üreteç işlevine atıfta bulunur, ancak bazı "
"bağlamlarda bir *asynchronous generator iterator* 'e karşılık gelebilir.  "
"Amaçlanan anlamın net olmadığı durumlarda, tam terimlerin kullanılması "
"belirsizliği önler."

#: glossary.rst:108
msgid ""
"An asynchronous generator function may contain :keyword:`await` expressions "
"as well as :keyword:`async for`, and :keyword:`async with` statements."
msgstr ""
"Bir asenkron üretici fonksiyonu, :keyword:`await` ifadelerinin yanı sıra :"
"keyword:`async for` ve :keyword:`async with` ifadeleri içerebilir."

#: glossary.rst:111
msgid "asynchronous generator iterator"
msgstr "asenkron jeneratör yineleyici"

#: glossary.rst:113
msgid "An object created by a :term:`asynchronous generator` function."
msgstr ""
"Bir :term:`asynchronous generator` işlevi tarafından oluşturulan bir nesne."

#: glossary.rst:115
msgid ""
"This is an :term:`asynchronous iterator` which when called using the :meth:"
"`__anext__` method returns an awaitable object which will execute the body "
"of the asynchronous generator function until the next :keyword:`yield` "
"expression."
msgstr ""
"Bu, :meth:`__anext__` yöntemi kullanılarak çağrıldığında, bir sonraki :"
"keyword:`yield` ifadesine kadar asynchronous generator işlevinin gövdesini "
"yürütecek, beklenebilir bir nesne döndüren bir :term:`asynchronous iterator`."

#: glossary.rst:120
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *asynchronous generator iterator* effectively resumes "
"with another awaitable returned by :meth:`__anext__`, it picks up where it "
"left off.  See :pep:`492` and :pep:`525`."
msgstr ""
"Her :keyword:`yield`, konum yürütme durumunu hatırlayarak (yerel değişkenler "
"ve bekleyen try ifadeleri dahil) işlemeyi geçici olarak askıya alır. "
"*asynchronous generator iterator*, :meth:`__anext__` tarafından döndürülen "
"başka birbeklenebilir ile etkili bir şekilde devam ettiğinde, kaldığı yerden "
"devam eder. Bkz. :pep:`492` ve :pep:`525`."

#: glossary.rst:125
msgid "asynchronous iterable"
msgstr "eşzamansız yinelenebilir"

#: glossary.rst:127
msgid ""
"An object, that can be used in an :keyword:`async for` statement. Must "
"return an :term:`asynchronous iterator` from its :meth:`__aiter__` method.  "
"Introduced by :pep:`492`."
msgstr ""
"Bir :keyword:`async for` ifadesinde kullanılabilen bir nesne. :meth:"
"`__aiter__` yönteminden bir :term:`asynchronous iterator` döndürmelidir.  :"
"pep:`492` 'de tanıtıldı."

#: glossary.rst:130
msgid "asynchronous iterator"
msgstr "asenkron yineleyici"

#: glossary.rst:132
msgid ""
"An object that implements the :meth:`__aiter__` and :meth:`__anext__` "
"methods.  ``__anext__`` must return an :term:`awaitable` object. :keyword:"
"`async for` resolves the awaitables returned by an asynchronous iterator's :"
"meth:`__anext__` method until it raises a :exc:`StopAsyncIteration` "
"exception.  Introduced by :pep:`492`."
msgstr ""
":meth:`__aiter__` ve :meth:`__anext__` yöntemlerini uygulayan bir nesne.  "
"``__anext__`` bir :term:`awaitable` nesnesi döndürmelidir. :keyword:`async "
"for`, bir asenkron yineleyicinin :meth:`__anext__` yöntemi tarafından "
"döndürülen beklenebilirleri bir :exc:`StopAsyncIteration` istisnası "
"oluşturana kadar çözer.  :pep:`492` 'de açıklandı."

#: glossary.rst:137
msgid "attribute"
msgstr "nitelik"

#: glossary.rst:139
msgid ""
"A value associated with an object which is usually referenced by name using "
"dotted expressions. For example, if an object *o* has an attribute *a* it "
"would be referenced as *o.a*."
msgstr ""
"Noktalı ifadeler kullanılarak adıyla başvurulan bir nesneyle ilişkili "
"değer.  Örneğin, *o* nesnesinin *a* özniteliği varsa, bu nesneye *o.a* "
"olarak başvurulur."

#: glossary.rst:144
msgid ""
"It is possible to give an object an attribute whose name is not an "
"identifier as defined by :ref:`identifiers`, for example using :func:"
"`setattr`, if the object allows it. Such an attribute will not be accessible "
"using a dotted expression, and would instead need to be retrieved with :func:"
"`getattr`."
msgstr ""
"Bir nesneye, eğer nesne izin veriyorsa, örneğin :func:`setattr` kullanarak, "
"adı :ref:`identifiers` tarafından tanımlandığı gibi tanımlayıcı olmayan bir "
"öznitelik vermek mümkündür. Böyle bir özniteliğe noktalı bir ifade "
"kullanılarak erişilemez ve bunun yerine :func:`getattr` ile alınması gerekir."

#: glossary.rst:149
msgid "awaitable"
msgstr "beklenebilir"

#: glossary.rst:151
msgid ""
"An object that can be used in an :keyword:`await` expression.  Can be a :"
"term:`coroutine` or an object with an :meth:`__await__` method. See also :"
"pep:`492`."
msgstr ""
":keyword:`await` ifadesinde kullanılabilen bir nesne.  Bir :term:`coroutine` "
"veya :meth:`__await__` yöntemine sahip bir nesne olabilir. Ayrıca bakınız :"
"pep:`492`."

#: glossary.rst:154
msgid "BDFL"
msgstr "BDFL"

#: glossary.rst:156
msgid ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum <https://gvanrossum."
"github.io/>`_, Python's creator."
msgstr ""
"Benevolent Dictator For Life, namı diğer `Guido van Rossum <https://"
"gvanrossum.github.io/>`_, Python'un yaratıcısı."

#: glossary.rst:158
msgid "binary file"
msgstr "ikili dosya"

#: glossary.rst:160
msgid ""
"A :term:`file object` able to read and write :term:`bytes-like objects "
"<bytes-like object>`. Examples of binary files are files opened in binary "
"mode (``'rb'``, ``'wb'`` or ``'rb+'``), :data:`sys.stdin.buffer`, :data:`sys."
"stdout.buffer`, and instances of :class:`io.BytesIO` and :class:`gzip."
"GzipFile`."
msgstr ""
"Bir :term:`dosya nesnesi <file object>` :term:`bayt benzeri nesneler <bytes-"
"like object>` okuyabilir ve yazabilir. İkili dosya örnekleri, ikili modda "
"açılan dosyalardır (``'rb'``, ``'wb'`` veya ``'rb+'``), :data:`sys.stdin."
"buffer`, :data:`sys.stdout.buffer` ve :class:`io.BytesIO` ve :class:`gzip."
"GzipFile` örnekleri."

#: glossary.rst:167
msgid ""
"See also :term:`text file` for a file object able to read and write :class:"
"`str` objects."
msgstr ""
"Ayrıca :class:`str` nesnelerini okuyabilen ve yazabilen bir dosya nesnesi "
"için :term:`text file` 'a bakın."

#: glossary.rst:169
msgid "borrowed reference"
msgstr "ödünç alınan referans"

#: glossary.rst:171
msgid ""
"In Python's C API, a borrowed reference is a reference to an object. It does "
"not modify the object reference count. It becomes a dangling pointer if the "
"object is destroyed. For example, a garbage collection can remove the last :"
"term:`strong reference` to the object and so destroy it."
msgstr ""
"Python'un C API 'sinde ödünç alınan referans, bir nesneye yapılan bir "
"referanstır. Nesne referans sayısını değiştirmez. Nesne yok edilirse sarkan "
"bir işaretçi olur. Örneğin, bir çöp toplama, nesneye yapılan son :term:"
"`strong reference` kaldırabilir ve böylece onu yok edebilir."

#: glossary.rst:176
msgid ""
"Calling :c:func:`Py_INCREF` on the :term:`borrowed reference` is recommended "
"to convert it to a :term:`strong reference` in-place, except when the object "
"cannot be destroyed before the last usage of the borrowed reference. The :c:"
"func:`Py_NewRef` function can be used to create a new :term:`strong "
"reference`."
msgstr ""
":term:`borrowed reference` üzerinde :c:func:`Py_INCREF` çağırmak, nesnenin "
"ödünç alınanın son kullanımından önce yok edilemediği durumlar dışında, onu "
"yerinde bir :term:`strong reference` 'a dönüştürmek için tavsiye edilir. "
"referans. :c:func:`Py_NewRef` işlevi, yeni bir :term:`strong reference` "
"oluşturmak için kullanılabilir."

#: glossary.rst:181
msgid "bytes-like object"
msgstr "bayt benzeri nesne"

#: glossary.rst:183
msgid ""
"An object that supports the :ref:`bufferobjects` and can export a C-:term:"
"`contiguous` buffer. This includes all :class:`bytes`, :class:`bytearray`, "
"and :class:`array.array` objects, as well as many common :class:`memoryview` "
"objects.  Bytes-like objects can be used for various operations that work "
"with binary data; these include compression, saving to a binary file, and "
"sending over a socket."
msgstr ""
":ref:`bufferobjects` 'i destekleyen ve bir C-:term:`contiguous` arabelleğini "
"dışa aktarabilen bir nesne. Bu, tüm :class:`bytes`, :class:`bytearray` ve :"
"class:`array.array` nesnelerinin yanı sıra birçok yaygın :class:`memoryview` "
"nesnesini içerir.  Bayt benzeri nesneler, ikili verilerle çalışan çeşitli "
"işlemler için kullanılabilir; bunlara sıkıştırma, ikili dosyaya kaydetme ve "
"bir soket üzerinden gönderme dahildir."

#: glossary.rst:190
msgid ""
"Some operations need the binary data to be mutable.  The documentation often "
"refers to these as \"read-write bytes-like objects\".  Example mutable "
"buffer objects include :class:`bytearray` and a :class:`memoryview` of a :"
"class:`bytearray`. Other operations require the binary data to be stored in "
"immutable objects (\"read-only bytes-like objects\"); examples of these "
"include :class:`bytes` and a :class:`memoryview` of a :class:`bytes` object."
msgstr ""
"Bazı işlemler, değişken olması için ikili verilere ihtiyaç duyar.  Belgeler "
"genellikle bunlara \"okuma-yazma bayt benzeri nesneler\" olarak atıfta "
"bulunur. Örnek değiştirilebilir arabellek nesneleri :class:`bytearray` ve "
"bir :class:`bytearray` :class:`memoryview` içerir. Diğer işlemler, ikili "
"verilerin değişmez nesnelerde (\"salt okunur bayt benzeri nesneler\") "
"depolanmasını gerektirir; bunların örnekleri arasında :class:`bytes` ve bir :"
"class:`bytes` nesnesinin :class:`memoryview` bulunur."

#: glossary.rst:198
msgid "bytecode"
msgstr "bayt kodu"

#: glossary.rst:200
msgid ""
"Python source code is compiled into bytecode, the internal representation of "
"a Python program in the CPython interpreter.  The bytecode is also cached in "
"``.pyc`` files so that executing the same file is faster the second time "
"(recompilation from source to bytecode can be avoided).  This \"intermediate "
"language\" is said to run on a :term:`virtual machine` that executes the "
"machine code corresponding to each bytecode. Do note that bytecodes are not "
"expected to work between different Python virtual machines, nor to be stable "
"between Python releases."
msgstr ""
"Python kaynak kodu, bir Python programının CPython yorumlayıcısındaki dahili "
"temsili olan bayt kodunda derlenir.  Bayt kodu ayrıca ``.pyc`` dosyalarında "
"önbelleğe alınır, böylece aynı dosyanın ikinci kez çalıştırılması daha hızlı "
"olur (kaynaktan bayt koduna yeniden derleme önlenebilir).  Bu \"ara dilin\", "
"her bir bayt koduna karşılık gelen makine kodunu yürüten bir :term:`sanal "
"makine <virtual machine>` üzerinde çalıştığı söylenir. Bayt kodlarının "
"farklı Python sanal makineleri arasında çalışması veya Python sürümleri "
"arasında kararlı olması beklenmediğini unutmayın."

#: glossary.rst:210
msgid ""
"A list of bytecode instructions can be found in the documentation for :ref:"
"`the dis module <bytecodes>`."
msgstr ""
"Bayt kodu talimatlarının bir listesi :ref:`bytecodes` dokümanında "
"bulunabilir."

#: glossary.rst:212
msgid "callable"
msgstr "çağırılabilir"

#: glossary.rst:214
msgid ""
"A callable is an object that can be called, possibly with a set of arguments "
"(see :term:`argument`), with the following syntax::"
msgstr ""
"Bir çağrılabilir, muhtemelen bir dizi argümanla (bkz. :term:`argument`) ve "
"aşağıdaki sözdizimiyle çağrılabilen bir nesnedir::"

#: glossary.rst:219
msgid ""
"A :term:`function`, and by extension a :term:`method`, is a callable. An "
"instance of a class that implements the :meth:`~object.__call__` method is "
"also a callable."
msgstr ""
"Bir :term:`fonksiyon <function>` ve uzantısı olarak bir :term:`metot "
"<method>` bir çağrılabilirdir. :meth:`~object.__call__` yöntemini uygulayan "
"bir sınıf örneği de bir çağrılabilirdir."

#: glossary.rst:222
msgid "callback"
msgstr "geri çağırmak"

#: glossary.rst:224
msgid ""
"A subroutine function which is passed as an argument to be executed at some "
"point in the future."
msgstr ""
"Gelecekte bir noktada yürütülecek bir argüman olarak iletilen bir alt "
"program işlevi."

#: glossary.rst:226
msgid "class"
msgstr "sınıf"

#: glossary.rst:228
msgid ""
"A template for creating user-defined objects. Class definitions normally "
"contain method definitions which operate on instances of the class."
msgstr ""
"Kullanıcı tanımlı nesneler oluşturmak için bir şablon. Sınıf tanımları "
"normalde sınıfın örnekleri üzerinde çalışan yöntem tanımlarını içerir."

#: glossary.rst:231
msgid "class variable"
msgstr "sınıf değişkeni"

#: glossary.rst:233
msgid ""
"A variable defined in a class and intended to be modified only at class "
"level (i.e., not in an instance of the class)."
msgstr ""
"Bir sınıfta tanımlanmış ve yalnızca sınıf düzeyinde (yani sınıfın bir "
"örneğinde değil) değiştirilmesi amaçlanan bir değişken."

#: glossary.rst:235
msgid "complex number"
msgstr "karmaşık sayı"

#: glossary.rst:237
msgid ""
"An extension of the familiar real number system in which all numbers are "
"expressed as a sum of a real part and an imaginary part.  Imaginary numbers "
"are real multiples of the imaginary unit (the square root of ``-1``), often "
"written ``i`` in mathematics or ``j`` in engineering.  Python has built-in "
"support for complex numbers, which are written with this latter notation; "
"the imaginary part is written with a ``j`` suffix, e.g., ``3+1j``.  To get "
"access to complex equivalents of the :mod:`math` module, use :mod:`cmath`.  "
"Use of complex numbers is a fairly advanced mathematical feature.  If you're "
"not aware of a need for them, it's almost certain you can safely ignore them."
msgstr ""
"Tüm sayıların bir reel kısım ve bir sanal kısım toplamı olarak ifade "
"edildiği bilinen gerçek sayı sisteminin bir uzantısı.  Hayali sayılar, "
"hayali birimin gerçek katlarıdır (``-1`` 'in karekökü), genellikle "
"matematikte ``i`` veya mühendislikte ``j`` ile yazılır.  Python, bu son "
"gösterimle yazılan karmaşık sayılar için yerleşik desteğe sahiptir; hayali "
"kısım bir ``j`` son ekiyle yazılır, örneğin ``3+1j``.  :mod:`math` modülünün "
"karmaşık eş değerlerine erişmek için :mod:`cmath` kullanın.  Karmaşık "
"sayıların kullanımı oldukça gelişmiş bir matematiksel özelliktir. Onlara "
"olan ihtiyacın farkında değilseniz, onları güvenle görmezden gelebileceğiniz "
"neredeyse kesindir."

#: glossary.rst:247
msgid "context manager"
msgstr "bağlam yöneticisi"

#: glossary.rst:249
msgid ""
"An object which controls the environment seen in a :keyword:`with` statement "
"by defining :meth:`__enter__` and :meth:`__exit__` methods. See :pep:`343`."
msgstr ""
":keyword:`with` ifadesinde görülen ortamı :meth:`__enter__` ve :meth:"
"`__exit__` yöntemlerini tanımlayarak kontrol eden bir nesne. Bakınız :pep:"
"`343`."

#: glossary.rst:252
msgid "context variable"
msgstr "bağlam değişkeni"

#: glossary.rst:254
msgid ""
"A variable which can have different values depending on its context. This is "
"similar to Thread-Local Storage in which each execution thread may have a "
"different value for a variable. However, with context variables, there may "
"be several contexts in one execution thread and the main usage for context "
"variables is to keep track of variables in concurrent asynchronous tasks. "
"See :mod:`contextvars`."
msgstr ""
"Bağlamına bağlı olarak farklı değerler alabilen bir değişken. Bu, her "
"yürütme iş parçacığının bir değişken için farklı bir değere sahip "
"olabileceği Thread-Local Storage'a benzer. Bununla birlikte, bağlam "
"değişkenleriyle, bir yürütme iş parçacığında birkaç bağlam olabilir ve "
"bağlam değişkenlerinin ana kullanımı, eşzamanlı zaman uyumsuz görevlerde "
"değişkenleri izlemektir. Bakınız :mod:`contextvars`."

#: glossary.rst:261
msgid "contiguous"
msgstr "bitişik"

#: glossary.rst:265
msgid ""
"A buffer is considered contiguous exactly if it is either *C-contiguous* or "
"*Fortran contiguous*.  Zero-dimensional buffers are C and Fortran "
"contiguous.  In one-dimensional arrays, the items must be laid out in memory "
"next to each other, in order of increasing indexes starting from zero.  In "
"multidimensional C-contiguous arrays, the last index varies the fastest when "
"visiting items in order of memory address.  However, in Fortran contiguous "
"arrays, the first index varies the fastest."
msgstr ""
"Bir arabellek, *C-bitişik* veya *Fortran bitişik* ise tam olarak bitişik "
"olarak kabul edilir.  Sıfır boyutlu arabellekler C ve Fortran bitişiktir.  "
"Tek boyutlu dizilerde, öğeler sıfırdan başlayarak artan dizinler sırasına "
"göre bellekte yan yana yerleştirilmelidir.  Çok boyutlu C-bitişik dizilerde, "
"öğeleri bellek adresi sırasına göre ziyaret ederken son dizin en hızlı "
"şekilde değişir.  Ancak, Fortran bitişik dizilerinde, ilk dizin en hızlı "
"şekilde değişir."

#: glossary.rst:273
msgid "coroutine"
msgstr "eşyordam"

#: glossary.rst:275
msgid ""
"Coroutines are a more generalized form of subroutines. Subroutines are "
"entered at one point and exited at another point.  Coroutines can be "
"entered, exited, and resumed at many different points.  They can be "
"implemented with the :keyword:`async def` statement.  See also :pep:`492`."
msgstr ""
"Eşyordamlar, altyordamların daha genelleştirilmiş bir biçimidir. Alt "
"programlara bir noktada girilir ve başka bir noktada çıkılır.  Eşyordamlar "
"birçok farklı noktada girilebilir, çıkılabilir ve devam ettirilebilir.  :"
"keyword:`async def` ifadesi ile uygulanabilirler.  Ayrıca bakınız :pep:`492`."

#: glossary.rst:280
msgid "coroutine function"
msgstr "eşyordam işlevi"

#: glossary.rst:282
msgid ""
"A function which returns a :term:`coroutine` object.  A coroutine function "
"may be defined with the :keyword:`async def` statement, and may contain :"
"keyword:`await`, :keyword:`async for`, and :keyword:`async with` keywords.  "
"These were introduced by :pep:`492`."
msgstr ""
"Bir :term:`coroutine` nesnesi döndüren bir işlev.  Bir eşyordam işlevi :"
"keyword:`async def` ifadesiyle tanımlanabilir ve :keyword:`await`, :keyword:"
"`async for` ve :keyword:`async with` anahtar kelimelerini içerebilir.  "
"Bunlar :pep:`492` tarafından tanıtıldı."

#: glossary.rst:287
msgid "CPython"
msgstr "CPython"

#: glossary.rst:289
msgid ""
"The canonical implementation of the Python programming language, as "
"distributed on `python.org <https://www.python.org>`_.  The term \"CPython\" "
"is used when necessary to distinguish this implementation from others such "
"as Jython or IronPython."
msgstr ""
"Python programlama dilinin `python.org <https://www.python.org>`_ üzerinde "
"dağıtıldığı şekliyle kurallı uygulaması.  \"CPython\" terimi, gerektiğinde "
"bu uygulamayı Jython veya IronPython gibi diğerlerinden ayırmak için "
"kullanılır."

#: glossary.rst:293
msgid "decorator"
msgstr "dekoratör"

#: glossary.rst:295
msgid ""
"A function returning another function, usually applied as a function "
"transformation using the ``@wrapper`` syntax.  Common examples for "
"decorators are :func:`classmethod` and :func:`staticmethod`."
msgstr ""
"Genellikle ``@wrapper`` sözdizimi kullanılarak bir işlev dönüşümü olarak "
"uygulanan, başka bir işlevi döndüren bir işlev.  Dekoratörler için yaygın "
"örnekler şunlardır: :func:`classmethod` ve :func:`staticmethod`."

#: glossary.rst:299
msgid ""
"The decorator syntax is merely syntactic sugar, the following two function "
"definitions are semantically equivalent::"
msgstr ""
"Dekoratör sözdizimi yalnızca sözdizimsel şekerdir, aşağıdaki iki işlev "
"tanımı anlamsal olarak eş değerdir:"

#: glossary.rst:310
msgid ""
"The same concept exists for classes, but is less commonly used there.  See "
"the documentation for :ref:`function definitions <function>` and :ref:`class "
"definitions <class>` for more about decorators."
msgstr ""
"Aynı kavram sınıflar için de mevcuttur, ancak orada daha az kullanılır.  "
"Dekoratörler hakkında daha fazla bilgi için :ref:`function definitions "
"<function>` ve :ref:`class definitions <class>` belgelerine bakın."

#: glossary.rst:313
msgid "descriptor"
msgstr "tanımlayıcı"

#: glossary.rst:315
msgid ""
"Any object which defines the methods :meth:`__get__`, :meth:`__set__`, or :"
"meth:`__delete__`.  When a class attribute is a descriptor, its special "
"binding behavior is triggered upon attribute lookup.  Normally, using *a.b* "
"to get, set or delete an attribute looks up the object named *b* in the "
"class dictionary for *a*, but if *b* is a descriptor, the respective "
"descriptor method gets called.  Understanding descriptors is a key to a deep "
"understanding of Python because they are the basis for many features "
"including functions, methods, properties, class methods, static methods, and "
"reference to super classes."
msgstr ""
":meth:`__get__`, :meth:`__set__` veya :meth:`__delete__` yöntemlerini "
"tanımlayan herhangi bir nesne.  Bir sınıf özniteliği bir tanımlayıcı "
"olduğunda, öznitelik araması üzerine özel bağlama davranışı tetiklenir.  "
"Normalde, bir özniteliği almak, ayarlamak veya silmek için *a.b* kullanmak, "
"*a* için sınıf sözlüğünde *b* adlı nesneyi arar, ancak *b* bir tanımlayıcı "
"ise, ilgili tanımlayıcı yöntemi çağrılır.  Tanımlayıcıları anlamak, Python'u "
"derinlemesine anlamanın anahtarıdır çünkü bunlar, işlevler, yöntemler, "
"özellikler, sınıf yöntemleri, statik yöntemler ve süper sınıflara başvuru "
"gibi birçok özelliğin temelidir."

#: glossary.rst:325
msgid ""
"For more information about descriptors' methods, see :ref:`descriptors` or "
"the :ref:`Descriptor How To Guide <descriptorhowto>`."
msgstr ""
"Tanımlayıcıların yöntemleri hakkında daha fazla bilgi için, bkz. :ref:"
"`descriptors` veya :ref:`Descriptor How To Guide <descriptorhowto>`."

#: glossary.rst:327
msgid "dictionary"
msgstr "sözlük"

#: glossary.rst:329
msgid ""
"An associative array, where arbitrary keys are mapped to values.  The keys "
"can be any object with :meth:`__hash__` and :meth:`__eq__` methods. Called a "
"hash in Perl."
msgstr ""
"Rasgele anahtarların değerlerle eşlendiği ilişkisel bir dizi.  Anahtarlar, :"
"meth:`__hash__` ve :meth:`__eq__` yöntemleriyle herhangi bir nesne olabilir. "
"Perl'de karma denir."

#: glossary.rst:332
msgid "dictionary comprehension"
msgstr "sözlük anlama"

#: glossary.rst:334
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a dictionary with the results. ``results = {n: n ** 2 for n in "
"range(10)}`` generates a dictionary containing key ``n`` mapped to value ``n "
"** 2``. See :ref:`comprehensions`."
msgstr ""
"Öğelerin tümünü veya bir kısmını yinelenebilir bir şekilde işlemenin ve "
"sonuçları içeren bir sözlük döndürmenin kompakt bir yolu. ``results = {n: n "
"** 2 for range(10)}``, ``n ** 2`` değerine eşlenmiş ``n`` anahtarını içeren "
"bir sözlük oluşturur. Bkz. :ref:`comprehensions`."

#: glossary.rst:338
msgid "dictionary view"
msgstr "sözlük görünümü"

#: glossary.rst:340
msgid ""
"The objects returned from :meth:`dict.keys`, :meth:`dict.values`, and :meth:"
"`dict.items` are called dictionary views. They provide a dynamic view on the "
"dictionary’s entries, which means that when the dictionary changes, the view "
"reflects these changes. To force the dictionary view to become a full list "
"use ``list(dictview)``.  See :ref:`dict-views`."
msgstr ""
":meth:`dict.keys`, :meth:`dict.values` ve :meth:`dict.items` 'den döndürülen "
"nesnelere sözlük görünümleri denir. Sözlüğün girişleri üzerinde dinamik bir "
"görünüm sağlarlar; bu, sözlük değiştiğinde görünümün bu değişiklikleri "
"yansıttığı anlamına gelir. Sözlük görünümünü tam liste olmaya zorlamak için "
"``list(dictview)`` kullanın.  Bakınız :ref:`dict-views`."

#: glossary.rst:346
msgid "docstring"
msgstr "belge dizisi"

#: glossary.rst:348
msgid ""
"A string literal which appears as the first expression in a class, function "
"or module.  While ignored when the suite is executed, it is recognized by "
"the compiler and put into the :attr:`__doc__` attribute of the enclosing "
"class, function or module.  Since it is available via introspection, it is "
"the canonical place for documentation of the object."
msgstr ""
"Bir sınıf, işlev veya modülde ilk ifade olarak görünen bir dize değişmezi.  "
"Paket yürütüldüğünde yoksayılırken, derleyici tarafından tanınır ve "
"çevreleyen sınıfın, işlevin veya modülün :attr:`__doc__` özniteliğine "
"yerleştirilir.  İç gözlem yoluyla erişilebilir olduğundan, nesnenin "
"belgelenmesi için kurallı yerdir."

#: glossary.rst:354
msgid "duck-typing"
msgstr "ördek yazma"

#: glossary.rst:356
msgid ""
"A programming style which does not look at an object's type to determine if "
"it has the right interface; instead, the method or attribute is simply "
"called or used (\"If it looks like a duck and quacks like a duck, it must be "
"a duck.\")  By emphasizing interfaces rather than specific types, well-"
"designed code improves its flexibility by allowing polymorphic "
"substitution.  Duck-typing avoids tests using :func:`type` or :func:"
"`isinstance`.  (Note, however, that duck-typing can be complemented with :"
"term:`abstract base classes <abstract base class>`.)  Instead, it typically "
"employs :func:`hasattr` tests or :term:`EAFP` programming."
msgstr ""
"Doğru arayüze sahip olup olmadığını belirlemek için bir nesnenin türüne "
"bakmayan bir programlama stili; bunun yerine, yöntem veya nitelik basitçe "
"çağrılır veya kullanılır (\"Ördek gibi görünüyorsa ve ördek gibi vaklıyorsa, "
"ördek olmalıdır.\")  İyi tasarlanmış kod, belirli türlerden ziyade "
"arayüzleri vurgulayarak, polimorfik ikameye izin vererek esnekliğini "
"artırır.  Ördek yazma, :func:`type` veya :func:`isinstance` kullanan "
"testleri önler.  (Ancak, ördek yazmanın :term:`abstract base class` ile "
"tamamlanabileceğini unutmayın.)  Bunun yerine, genellikle :func:`hasattr` "
"testleri veya :term:`EAFP` programlamasını kullanır."

#: glossary.rst:365
msgid "EAFP"
msgstr "EAFP"

#: glossary.rst:367
msgid ""
"Easier to ask for forgiveness than permission.  This common Python coding "
"style assumes the existence of valid keys or attributes and catches "
"exceptions if the assumption proves false.  This clean and fast style is "
"characterized by the presence of many :keyword:`try` and :keyword:`except` "
"statements.  The technique contrasts with the :term:`LBYL` style common to "
"many other languages such as C."
msgstr ""
"Af dilemek izin almaktan daha kolaydır.  Bu yaygın Python kodlama stili, "
"geçerli anahtarların veya niteliklerin varlığını varsayar ve varsayımın "
"yanlış çıkması durumunda istisnaları yakalar.  Bu temiz ve hızlı stil, "
"birçok :keyword:`try` ve :keyword:`except` ifadesinin varlığı ile "
"karakterize edilir.  Teknik, C gibi diğer birçok dilde ortak olan :term:"
"`LBYL` stiliyle çelişir."

#: glossary.rst:373
msgid "expression"
msgstr "ifade (değer döndürür)"

#: glossary.rst:375
msgid ""
"A piece of syntax which can be evaluated to some value.  In other words, an "
"expression is an accumulation of expression elements like literals, names, "
"attribute access, operators or function calls which all return a value.  In "
"contrast to many other languages, not all language constructs are "
"expressions.  There are also :term:`statement`\\s which cannot be used as "
"expressions, such as :keyword:`while`.  Assignments are also statements, not "
"expressions."
msgstr ""
"Bir değere göre değerlendirilebilecek bir sözdizimi parçası.  Başka bir "
"deyişle, bir ifade, tümü bir değer döndüren sabit değerler, adlar, öznitelik "
"erişimi, işleçler veya işlev çağrıları gibi ifade öğelerinin bir "
"toplamıdır.  Diğer birçok dilin aksine, tüm dil yapıları ifade değildir. "
"Ayrıca :keyword:`while` gibi kullanılamayan :term:`ifadeler <statement>` de "
"vardır.  Atamalar da değer döndürmeyen ifadelerdir (statement)."

#: glossary.rst:382
msgid "extension module"
msgstr "uzatma modülü"

#: glossary.rst:384
msgid ""
"A module written in C or C++, using Python's C API to interact with the core "
"and with user code."
msgstr ""
"Çekirdekle ve kullanıcı koduyla etkileşim kurmak için Python'un C API'sini "
"kullanan, C veya C++ ile yazılmış bir modül."

#: glossary.rst:386
msgid "f-string"
msgstr "f-string"

#: glossary.rst:388
msgid ""
"String literals prefixed with ``'f'`` or ``'F'`` are commonly called \"f-"
"strings\" which is short for :ref:`formatted string literals <f-strings>`.  "
"See also :pep:`498`."
msgstr ""
"Ön eki ``'f'`` veya ``'F'`` olan dize değişmezleri genellikle \"f-strings\" "
"olarak adlandırılır; bu, :ref:`formatted string literals <f-strings>` 'ın "
"kısaltmasıdır.  Ayrıca bkz. :pep:`498`."

#: glossary.rst:391
msgid "file object"
msgstr "dosya nesnesi"

#: glossary.rst:393
msgid ""
"An object exposing a file-oriented API (with methods such as :meth:`read()` "
"or :meth:`write()`) to an underlying resource.  Depending on the way it was "
"created, a file object can mediate access to a real on-disk file or to "
"another type of storage or communication device (for example standard input/"
"output, in-memory buffers, sockets, pipes, etc.).  File objects are also "
"called :dfn:`file-like objects` or :dfn:`streams`."
msgstr ""
"Dosya yönelimli bir API'yi (:meth:`read()` veya :meth:`write()` gibi "
"yöntemlerle) temel alınan bir kaynağa gösteren bir nesne.  Oluşturulma "
"şekline bağlı olarak, bir dosya nesnesi gerçek bir disk üzerindeki dosyaya "
"veya başka bir tür depolama veya iletişim aygıtına (örneğin standart giriş/"
"çıkış, bellek içi arabellekler, yuvalar, borular vb.) erişime aracılık "
"edebilir. .  Dosya nesneleri ayrıca :dfn:`file-like objects` veya :dfn:"
"`streams` olarak da adlandırılır."

#: glossary.rst:401
msgid ""
"There are actually three categories of file objects: raw :term:`binary files "
"<binary file>`, buffered :term:`binary files <binary file>` and :term:`text "
"files <text file>`. Their interfaces are defined in the :mod:`io` module.  "
"The canonical way to create a file object is by using the :func:`open` "
"function."
msgstr ""
"Aslında üç dosya nesnesi kategorisi vardır: ham :term:`binary files <binary "
"file>`, arabelleğe alınmış :term:`binary files <binary file>` ve :term:`text "
"files <text file>`. Arayüzleri :mod:`io` modülünde tanımlanmıştır.  Bir "
"dosya nesnesi yaratmanın kurallı yolu :func:`open` işlevini kullanmaktır."

#: glossary.rst:406
msgid "file-like object"
msgstr "dosya benzeri nesne"

#: glossary.rst:408
msgid "A synonym for :term:`file object`."
msgstr ":term:`dosya nesnesi` ile eşanlamlıdır."

#: glossary.rst:409
msgid "filesystem encoding and error handler"
msgstr "dosya sistemi kodlaması ve hata işleyicisi"

#: glossary.rst:411
msgid ""
"Encoding and error handler used by Python to decode bytes from the operating "
"system and encode Unicode to the operating system."
msgstr ""
"Python tarafından işletim sistemindeki baytların kodunu çözmek ve Unicode'u "
"işletim sistemine kodlamak için kullanılan kodlama ve hata işleyici."

#: glossary.rst:414
msgid ""
"The filesystem encoding must guarantee to successfully decode all bytes "
"below 128. If the file system encoding fails to provide this guarantee, API "
"functions can raise :exc:`UnicodeError`."
msgstr ""
"Dosya sistemi kodlaması, 128'in altındaki tüm baytların kodunu başarıyla "
"çözmeyi garanti etmelidir. Dosya sistemi kodlaması bu garantiyi "
"sağlayamazsa, API işlevleri :exc:`UnicodeError` değerini yükseltebilir."

#: glossary.rst:418
msgid ""
"The :func:`sys.getfilesystemencoding` and :func:`sys."
"getfilesystemencodeerrors` functions can be used to get the filesystem "
"encoding and error handler."
msgstr ""
":func:`sys.getfilesystemencoding` ve :func:`sys.getfilesystemencodeerrors` "
"işlevleri, dosya sistemi kodlamasını ve hata işleyicisini almak için "
"kullanılabilir."

#: glossary.rst:422
msgid ""
"The :term:`filesystem encoding and error handler` are configured at Python "
"startup by the :c:func:`PyConfig_Read` function: see :c:member:`~PyConfig."
"filesystem_encoding` and :c:member:`~PyConfig.filesystem_errors` members of :"
"c:type:`PyConfig`."
msgstr ""
":term:`filesystem encoding and error handler` Python başlangıcında :c:func:"
"`PyConfig_Read` işleviyle yapılandırılır: bkz. :c:member:`~PyConfig."
"filesystem_encoding` ve :c:member:`~PyConfig. filesystem_errors` üyeleri :c:"
"type:`PyConfig`."

#: glossary.rst:427
msgid "See also the :term:`locale encoding`."
msgstr "Ayrıca bkz. :term:`locale encoding`."

#: glossary.rst:428
msgid "finder"
msgstr "bulucu"

#: glossary.rst:430
msgid ""
"An object that tries to find the :term:`loader` for a module that is being "
"imported."
msgstr ""
"İçe aktarılmakta olan bir modül için :term:`loader` 'ı bulmaya çalışan bir "
"nesne."

#: glossary.rst:433
msgid ""
"Since Python 3.3, there are two types of finder: :term:`meta path finders "
"<meta path finder>` for use with :data:`sys.meta_path`, and :term:`path "
"entry finders <path entry finder>` for use with :data:`sys.path_hooks`."
msgstr ""
"Python 3.3'ten beri, iki çeşit bulucu vardır: :data:`sys.meta_path` ile "
"kullanılmak üzere :term:`meta yol bulucular <meta path finder>`, ve :data:"
"`sys.path_hooks` ile kullanılmak üzere :term:`yol girişi bulucular <path "
"entry finder>`."

#: glossary.rst:437
msgid "See :pep:`302`, :pep:`420` and :pep:`451` for much more detail."
msgstr "Daha fazla ayrıntı için :pep:`302`, :pep:`420` ve :pep:`451` bakın."

#: glossary.rst:438
msgid "floor division"
msgstr "kat bölümü"

#: glossary.rst:440
msgid ""
"Mathematical division that rounds down to nearest integer.  The floor "
"division operator is ``//``.  For example, the expression ``11 // 4`` "
"evaluates to ``2`` in contrast to the ``2.75`` returned by float true "
"division.  Note that ``(-11) // 4`` is ``-3`` because that is ``-2.75`` "
"rounded *downward*. See :pep:`238`."
msgstr ""
"En yakın tam sayıya yuvarlayan matematiksel bölme.  Kat bölme operatörü ``//"
"`` şeklindedir.  Örneğin, ``11 // 4`` ifadesi, gerçek yüzer bölme tarafından "
"döndürülen ``2.75`` değerinin aksine ``2`` olarak değerlendirilir.  "
"``(-11) // 4`` 'ün ``-3`` olduğuna dikkat edin, çünkü bu ``-2.75`` "
"yuvarlatılmış *aşağı*. Bakınız :pep:`238`."

#: glossary.rst:445
msgid "function"
msgstr "fonksiyon"

#: glossary.rst:447
msgid ""
"A series of statements which returns some value to a caller. It can also be "
"passed zero or more :term:`arguments <argument>` which may be used in the "
"execution of the body. See also :term:`parameter`, :term:`method`, and the :"
"ref:`function` section."
msgstr ""
"Bir arayana bir değer döndüren bir dizi ifade. Ayrıca, gövdenin "
"yürütülmesinde kullanılabilen sıfır veya daha fazla :term:`argüman "
"<argument>` iletilebilir. Ayrıca :term:`parameter`, :term:`method` ve :ref:"
"`function` bölümüne bakın."

#: glossary.rst:451
msgid "function annotation"
msgstr "fonksiyon açıklaması"

#: glossary.rst:453
msgid "An :term:`annotation` of a function parameter or return value."
msgstr ""
"Bir işlev parametresinin veya dönüş değerinin :term:`ek açıklaması "
"<annotation>`."

#: glossary.rst:455
msgid ""
"Function annotations are usually used for :term:`type hints <type hint>`: "
"for example, this function is expected to take two :class:`int` arguments "
"and is also expected to have an :class:`int` return value::"
msgstr ""
"İşlev ek açıklamaları genellikle :term:`type hints <type hint>` için "
"kullanılır: örneğin, bu fonksiyonun iki :class:`int` argüman alması ve "
"ayrıca bir :class:`int` dönüş değerine sahip olması beklenir ::"

#: glossary.rst:463
msgid "Function annotation syntax is explained in section :ref:`function`."
msgstr "İşlev açıklama sözdizimi :ref:`function` bölümünde açıklanmaktadır."

#: glossary.rst:465
msgid ""
"See :term:`variable annotation` and :pep:`484`, which describe this "
"functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"Bu işlevi açıklayan :term:`variable annotation` ve :pep:`484` 'e bakın. Ek "
"açıklamalarla çalışmaya ilişkin en iyi uygulamalar için ayrıca :ref:"
"`annotations-howto` konusuna bakın."

#: glossary.rst:469
msgid "__future__"
msgstr "__future__"

#: glossary.rst:471
msgid ""
"A :ref:`future statement <future>`, ``from __future__ import <feature>``, "
"directs the compiler to compile the current module using syntax or semantics "
"that will become standard in a future release of Python. The :mod:"
"`__future__` module documents the possible values of *feature*.  By "
"importing this module and evaluating its variables, you can see when a new "
"feature was first added to the language and when it will (or did) become the "
"default::"
msgstr ""
"Bir :ref:`future ifadesi <future>`, ``from __future__ import <feature>``, "
"derleyiciyi, Python'un gelecekteki bir sürümünde standart hale gelecek olan "
"sözdizimini veya semantiği kullanarak mevcut modülü derlemeye yönlendirir. :"
"mod:`__future__` modülü, *feature*'ın olası değerlerini belgeler.  Bu modülü "
"içe aktararak ve değişkenlerini değerlendirerek, dile ilk kez yeni bir "
"özelliğin ne zaman eklendiğini ve ne zaman varsayılan olacağını (ya da "
"yaptığını) görebilirsiniz:"

#: glossary.rst:482
msgid "garbage collection"
msgstr "çöp toplama"

#: glossary.rst:484
msgid ""
"The process of freeing memory when it is not used anymore.  Python performs "
"garbage collection via reference counting and a cyclic garbage collector "
"that is able to detect and break reference cycles.  The garbage collector "
"can be controlled using the :mod:`gc` module."
msgstr ""
"Artık kullanılmadığında belleği boşaltma işlemi.  Python, referans sayımı ve "
"referans döngülerini algılayıp kırabilen bir döngüsel çöp toplayıcı "
"aracılığıyla çöp toplama gerçekleştirir.  Çöp toplayıcı :mod:`gc` modülü "
"kullanılarak kontrol edilebilir."

#: glossary.rst:490
msgid "generator"
msgstr "jeneratör"

#: glossary.rst:492
msgid ""
"A function which returns a :term:`generator iterator`.  It looks like a "
"normal function except that it contains :keyword:`yield` expressions for "
"producing a series of values usable in a for-loop or that can be retrieved "
"one at a time with the :func:`next` function."
msgstr ""
"Bir :term:`generator iterator` döndüren bir işlev.  Bir for döngüsünde "
"kullanılabilen bir dizi değer üretmek için :keyword:`yield` ifadeleri "
"içermesi veya :func:`next` işleviyle birer birer alınabilmesi dışında normal "
"bir işleve benziyor."

#: glossary.rst:497
msgid ""
"Usually refers to a generator function, but may refer to a *generator "
"iterator* in some contexts.  In cases where the intended meaning isn't "
"clear, using the full terms avoids ambiguity."
msgstr ""
"Genellikle bir üretici işlevine atıfta bulunur, ancak bazı bağlamlarda bir "
"*jeneratör yineleyicisine* atıfta bulunabilir.  Amaçlanan anlamın net "
"olmadığı durumlarda, tam terimlerin kullanılması belirsizliği önler."

#: glossary.rst:500
msgid "generator iterator"
msgstr "jeneratör yineleyici"

#: glossary.rst:502
msgid "An object created by a :term:`generator` function."
msgstr "Bir :term:`generator` işlevi tarafından oluşturulan bir nesne."

#: glossary.rst:504
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *generator iterator* resumes, it picks up where it "
"left off (in contrast to functions which start fresh on every invocation)."
msgstr ""
"Her :keyword:`yield`, konum yürütme durumunu hatırlayarak (yerel değişkenler "
"ve bekleyen try ifadeleri dahil) işlemeyi geçici olarak askıya alır.  "
"*jeneratör yineleyici* devam ettiğinde, kaldığı yerden devam eder (her "
"çağrıda yeniden başlayan işlevlerin aksine)."

#: glossary.rst:511
msgid "generator expression"
msgstr "jeneratör ifadesi"

#: glossary.rst:513
msgid ""
"An expression that returns an iterator.  It looks like a normal expression "
"followed by a :keyword:`!for` clause defining a loop variable, range, and an "
"optional :keyword:`!if` clause.  The combined expression generates values "
"for an enclosing function::"
msgstr ""
"Yineleyici döndüren bir ifade.  Bir döngü değişkenini, aralığı ve isteğe "
"bağlı bir :keyword:`!if` yan tümcesini tanımlayan bir :keyword:`!for` yan "
"tümcesinin takip ettiği normal bir ifadeye benziyor.  Birleştirilmiş ifade, "
"bir çevreleyen için değerler üretir::"

#: glossary.rst:520
msgid "generic function"
msgstr "genel işlev"

#: glossary.rst:522
msgid ""
"A function composed of multiple functions implementing the same operation "
"for different types. Which implementation should be used during a call is "
"determined by the dispatch algorithm."
msgstr ""
"Farklı türler için aynı işlemi uygulayan birden çok işlevden oluşan bir "
"işlev. Bir çağrı sırasında hangi uygulamanın kullanılması gerektiği, "
"gönderme algoritması tarafından belirlenir."

#: glossary.rst:526
msgid ""
"See also the :term:`single dispatch` glossary entry, the :func:`functools."
"singledispatch` decorator, and :pep:`443`."
msgstr ""
"Ayrıca :term:`single dispatch` sözlük girdisine, :func:`functools."
"singledispatch` dekoratörüne ve :pep:`443` 'e bakın."

#: glossary.rst:528
msgid "generic type"
msgstr "genel tip"

#: glossary.rst:530
msgid ""
"A :term:`type` that can be parameterized; typically a :ref:`container "
"class<sequence-types>` such as :class:`list` or :class:`dict`. Used for :"
"term:`type hints <type hint>` and :term:`annotations <annotation>`."
msgstr ""
"Parametrelendirilebilen bir :term:`type`; tipik olarak bir :ref:`konteyner "
"sınıfı <sequence-types>`, örneğin :class:`list` veya :class:`dict`. :term:"
"`type hint` ve :term:`annotation` için kullanılır."

#: glossary.rst:535
msgid ""
"For more details, see :ref:`generic alias types<types-genericalias>`, :pep:"
"`483`, :pep:`484`, :pep:`585`, and the :mod:`typing` module."
msgstr ""
"Daha fazla ayrıntı için :ref:`generic allias types<types-genericalias>`, :"
"pep:`483`, :pep:`484`, :pep:`585` ve :mod:`typing` modülüne bakın."

#: glossary.rst:537
msgid "GIL"
msgstr "GIL"

#: glossary.rst:539
msgid "See :term:`global interpreter lock`."
msgstr "Bakınız :term:`global interpreter lock`."

#: glossary.rst:540
msgid "global interpreter lock"
msgstr "genel tercüman kilidi"

#: glossary.rst:542
msgid ""
"The mechanism used by the :term:`CPython` interpreter to assure that only "
"one thread executes Python :term:`bytecode` at a time. This simplifies the "
"CPython implementation by making the object model (including critical built-"
"in types such as :class:`dict`) implicitly safe against concurrent access.  "
"Locking the entire interpreter makes it easier for the interpreter to be "
"multi-threaded, at the expense of much of the parallelism afforded by multi-"
"processor machines."
msgstr ""
":term:`CPython` yorumlayıcısı tarafından aynı anda yalnızca bir iş "
"parçacığının Python :term:`bytecode` 'u yürütmesini sağlamak için kullanılan "
"mekanizma. Bu, nesne modelini (:class:`dict` gibi kritik yerleşik türler "
"dahil) eşzamanlı erişime karşı örtük olarak güvenli hale getirerek CPython "
"uygulamasını basitleştirir.  Tüm yorumlayıcıyı kilitlemek, çok işlemcili "
"makinelerin sağladığı paralelliğin çoğu pahasına, yorumlayıcının çok iş "
"parçacıklı olmasını kolaylaştırır."

#: glossary.rst:551
msgid ""
"However, some extension modules, either standard or third-party, are "
"designed so as to release the GIL when doing computationally intensive tasks "
"such as compression or hashing.  Also, the GIL is always released when doing "
"I/O."
msgstr ""
"Bununla birlikte, standart veya üçüncü taraf bazı genişletme modülleri, "
"sıkıştırma veya karma gibi hesaplama açısından yoğun görevler yaparken "
"GIL'yi serbest bırakacak şekilde tasarlanmıştır.  Ayrıca, GIL, G/Ç yaparken "
"her zaman serbest bırakılır."

#: glossary.rst:556
msgid ""
"Past efforts to create a \"free-threaded\" interpreter (one which locks "
"shared data at a much finer granularity) have not been successful because "
"performance suffered in the common single-processor case. It is believed "
"that overcoming this performance issue would make the implementation much "
"more complicated and therefore costlier to maintain."
msgstr ""
"\"Serbest iş parçacıklı\" bir yorumlayıcı (paylaşılan verileri çok daha ince "
"bir ayrıntı düzeyinde kilitleyen) oluşturma çabaları, ortak tek işlemcili "
"durumda performans düştüğü için başarılı olmamıştır. Bu performans sorununun "
"üstesinden gelinmesinin uygulamayı çok daha karmaşık hale getireceğine ve "
"dolayısıyla bakımını daha maliyetli hale getireceğine inanılmaktadır."

#: glossary.rst:562
msgid "hash-based pyc"
msgstr "karma tabanlı pyc"

#: glossary.rst:564
msgid ""
"A bytecode cache file that uses the hash rather than the last-modified time "
"of the corresponding source file to determine its validity. See :ref:`pyc-"
"invalidation`."
msgstr ""
"Geçerliliğini belirlemek için ilgili kaynak dosyanın son değiştirilme zamanı "
"yerine karma değerini kullanan bir bayt kodu önbellek dosyası. Bakınız :ref:"
"`pyc-invalidation`."

#: glossary.rst:567
msgid "hashable"
msgstr "yıkanabilir"

#: glossary.rst:569
msgid ""
"An object is *hashable* if it has a hash value which never changes during "
"its lifetime (it needs a :meth:`__hash__` method), and can be compared to "
"other objects (it needs an :meth:`__eq__` method).  Hashable objects which "
"compare equal must have the same hash value."
msgstr ""
"Bir nesne, ömrü boyunca asla değişmeyen bir karma değere sahipse (bir :meth:"
"`__hash__` yöntemine ihtiyaç duyar) ve diğer nesnelerle "
"karşılaştırılabilirse (bir :meth:`__eq__` yöntemine ihtiyaç duyar) "
"*hashable* olur. .  Eşit karşılaştıran Hashable nesneleri aynı karma "
"değerine sahip olmalıdır."

#: glossary.rst:574
msgid ""
"Hashability makes an object usable as a dictionary key and a set member, "
"because these data structures use the hash value internally."
msgstr ""
"Hashability, bir nesneyi bir sözlük anahtarı ve bir set üyesi olarak "
"kullanılabilir hale getirir, çünkü bu veri yapıları hash değerini dahili "
"olarak kullanır."

#: glossary.rst:577
msgid ""
"Most of Python's immutable built-in objects are hashable; mutable containers "
"(such as lists or dictionaries) are not; immutable containers (such as "
"tuples and frozensets) are only hashable if their elements are hashable.  "
"Objects which are instances of user-defined classes are hashable by "
"default.  They all compare unequal (except with themselves), and their hash "
"value is derived from their :func:`id`."
msgstr ""
"Python'un değişmez yerleşik nesnelerinin çoğu, yıkanabilir; değiştirilebilir "
"kaplar (listeler veya sözlükler gibi) değildir; değişmez kaplar (tüpler ve "
"donmuş kümeler gibi) yalnızca öğelerinin yıkanabilir olması durumunda "
"yıkanabilirdir.  Kullanıcı tanımlı sınıfların örnekleri olan nesneler "
"varsayılan olarak hash edilebilirdir.  Hepsi eşit olmayanı karşılaştırır "
"(kendileriyle hariç) ve hash değerleri :func:`id` 'lerinden türetilir."

#: glossary.rst:584
msgid "IDLE"
msgstr "BOŞTA"

#: glossary.rst:586
msgid ""
"An Integrated Development and Learning Environment for Python. :ref:`idle` "
"is a basic editor and interpreter environment which ships with the standard "
"distribution of Python."
msgstr ""
"Python için Entegre Geliştirme Ortamı. :ref:`idle`, Python'un standart "
"dağıtımıyla birlikte gelen temel bir düzenleyici ve yorumlayıcı ortamıdır."

#: glossary.rst:589
msgid "immutable"
msgstr "değişmez"

#: glossary.rst:591
msgid ""
"An object with a fixed value.  Immutable objects include numbers, strings "
"and tuples.  Such an object cannot be altered.  A new object has to be "
"created if a different value has to be stored.  They play an important role "
"in places where a constant hash value is needed, for example as a key in a "
"dictionary."
msgstr ""
"Sabit değeri olan bir nesne.  Değişmez nesneler arasında sayılar, dizeler ve "
"demetler bulunur.  Böyle bir nesne değiştirilemez.  Farklı bir değerin "
"saklanması gerekiyorsa yeni bir nesne oluşturulmalıdır.  Örneğin bir "
"sözlükte anahtar olarak, sabit bir karma değerinin gerekli olduğu yerlerde "
"önemli bir rol oynarlar."

#: glossary.rst:596
msgid "import path"
msgstr "içe aktarım yolu"

#: glossary.rst:598
msgid ""
"A list of locations (or :term:`path entries <path entry>`) that are searched "
"by the :term:`path based finder` for modules to import. During import, this "
"list of locations usually comes from :data:`sys.path`, but for subpackages "
"it may also come from the parent package's ``__path__`` attribute."
msgstr ""
"İçe aktarılacak modüller için :term:`path based finder` tarafından aranan "
"konumların (veya :term:`path entries <path entry>`) listesi. İçe aktarma "
"sırasında, bu konum listesi genellikle :data:`sys.path` adresinden gelir, "
"ancak alt paketler için üst paketin ``__path__`` özelliğinden de gelebilir."

#: glossary.rst:603
msgid "importing"
msgstr "içe aktarma"

#: glossary.rst:605
msgid ""
"The process by which Python code in one module is made available to Python "
"code in another module."
msgstr ""
"Bir modüldeki Python kodunun başka bir modüldeki Python koduna sunulması "
"süreci."

#: glossary.rst:607
msgid "importer"
msgstr "içe aktarıcı"

#: glossary.rst:609
msgid ""
"An object that both finds and loads a module; both a :term:`finder` and :"
"term:`loader` object."
msgstr ""
"Bir modülü hem bulan hem de yükleyen bir nesne; hem bir :term:`finder` hem "
"de :term:`loader` nesnesi."

#: glossary.rst:611
msgid "interactive"
msgstr "etkileşimli"

#: glossary.rst:613
msgid ""
"Python has an interactive interpreter which means you can enter statements "
"and expressions at the interpreter prompt, immediately execute them and see "
"their results.  Just launch ``python`` with no arguments (possibly by "
"selecting it from your computer's main menu). It is a very powerful way to "
"test out new ideas or inspect modules and packages (remember ``help(x)``)."
msgstr ""
"Python'un etkileşimli bir yorumlayıcısı vardır; bu, yorumlayıcı isteminde "
"ifadeler ve ifadeler girebileceğiniz, bunları hemen çalıştırabileceğiniz ve "
"sonuçlarını görebileceğiniz anlamına gelir.  Herhangi bir argüman olmadan "
"``python`` 'u başlatmanız yeterlidir (muhtemelen bilgisayarınızın ana "
"menüsünden seçerek). Yeni fikirleri test etmenin veya modülleri ve paketleri "
"incelemenin çok güçlü bir yoludur (``help(x)`` 'i unutmayın)."

#: glossary.rst:619
msgid "interpreted"
msgstr "yorumlanmış"

#: glossary.rst:621
msgid ""
"Python is an interpreted language, as opposed to a compiled one, though the "
"distinction can be blurry because of the presence of the bytecode compiler.  "
"This means that source files can be run directly without explicitly creating "
"an executable which is then run. Interpreted languages typically have a "
"shorter development/debug cycle than compiled ones, though their programs "
"generally also run more slowly.  See also :term:`interactive`."
msgstr ""
"Python, derlenmiş bir dilin aksine yorumlanmış bir dildir, ancak bayt kodu "
"derleyicisinin varlığı nedeniyle ayrım bulanık olabilir.  Bu, kaynak "
"dosyaların daha sonra çalıştırılacak bir yürütülebilir dosya oluşturmadan "
"doğrudan çalıştırılabileceği anlamına gelir. Yorumlanan diller genellikle "
"derlenmiş dillerden daha kısa bir geliştirme/hata ayıklama döngüsüne "
"sahiptir, ancak programları genellikle daha yavaş çalışır.  Ayrıca bkz. :"
"term:`interactive`."

#: glossary.rst:628
msgid "interpreter shutdown"
msgstr "tercüman kapatma"

#: glossary.rst:630
msgid ""
"When asked to shut down, the Python interpreter enters a special phase where "
"it gradually releases all allocated resources, such as modules and various "
"critical internal structures.  It also makes several calls to the :term:"
"`garbage collector <garbage collection>`. This can trigger the execution of "
"code in user-defined destructors or weakref callbacks. Code executed during "
"the shutdown phase can encounter various exceptions as the resources it "
"relies on may not function anymore (common examples are library modules or "
"the warnings machinery)."
msgstr ""
"Kapatılması istendiğinde, Python yorumlayıcısı, modüller ve çeşitli kritik "
"iç yapılar gibi tahsis edilen tüm kaynakları kademeli olarak serbest "
"bıraktığı özel bir aşamaya girer.  Ayrıca :term:`garbage collector <garbage "
"collection>` için birkaç çağrı yapar. Bu, kullanıcı tanımlı yıkıcılarda veya "
"zayıf referans geri aramalarında kodun yürütülmesini tetikleyebilir. Kapatma "
"aşamasında yürütülen kod, dayandığı kaynaklar artık çalışmayabileceğinden "
"çeşitli istisnalarla karşılaşabilir (yaygın örnekler kütüphane modülleri "
"veya uyarı makineleridir)."

#: glossary.rst:639
msgid ""
"The main reason for interpreter shutdown is that the ``__main__`` module or "
"the script being run has finished executing."
msgstr ""
"Yorumlayıcının kapatılmasının ana nedeni, ``__main__`` modülünün veya "
"çalıştırılan betiğin yürütmeyi bitirmiş olmasıdır."

#: glossary.rst:641
msgid "iterable"
msgstr "yinelenebilir"

#: glossary.rst:643
msgid ""
"An object capable of returning its members one at a time. Examples of "
"iterables include all sequence types (such as :class:`list`, :class:`str`, "
"and :class:`tuple`) and some non-sequence types like :class:`dict`, :term:"
"`file objects <file object>`, and objects of any classes you define with an :"
"meth:`__iter__` method or with a :meth:`__getitem__` method that implements :"
"term:`sequence` semantics."
msgstr ""
"Üyelerini teker teker döndürebilen bir nesne. Yineleme örnekleri, tüm dizi "
"türlerini (:class:`list`, :class:`str`, ve :class:`tuple` gibi) ve :class:"
"`dict`, :term:`dosya objeleri <file object>` gibi bazı dizi olmayan türleri "
"ve bir :meth:`__iter__` yöntemiyle veya :term:`dizi <sequence>` semantiğini "
"uygulayan bir :meth:`__getitem__` yöntemiyle tanımladığınız tüm sınıfların "
"nesnelerini içerir."

#: glossary.rst:650
msgid ""
"Iterables can be used in a :keyword:`for` loop and in many other places "
"where a sequence is needed (:func:`zip`, :func:`map`, ...).  When an "
"iterable object is passed as an argument to the built-in function :func:"
"`iter`, it returns an iterator for the object.  This iterator is good for "
"one pass over the set of values.  When using iterables, it is usually not "
"necessary to call :func:`iter` or deal with iterator objects yourself.  The "
"``for`` statement does that automatically for you, creating a temporary "
"unnamed variable to hold the iterator for the duration of the loop.  See "
"also :term:`iterator`, :term:`sequence`, and :term:`generator`."
msgstr ""
"Yinelenebilirler bir :keyword:`for` döngüsünde ve bir dizinin gerekli olduğu "
"diğer birçok yerde kullanılabilir (:func:`zip`, :func:`map`, ...).  "
"Yerleşik :func:`iter` işlevine argüman olarak yinelenebilir bir nesne "
"iletildiğinde, nesne için bir yineleyici döndürür.  Bu yineleyici, değerler "
"kümesi üzerinden bir geçiş için iyidir.  Yinelenebilirleri kullanırken, "
"genellikle :func:`iter` çağırmanız veya yineleyici nesnelerle kendiniz "
"ilgilenmeniz gerekmez.  ``for`` ifadesi bunu sizin için otomatik olarak "
"yapar ve yineleyiciyi döngü süresince tutmak için geçici bir adsız değişken "
"oluşturur.  Ayrıca bkz. :term:`iterator`, :term:`sequence` ve :term:"
"`generator`."

#: glossary.rst:660
msgid "iterator"
msgstr "yineleyici"

#: glossary.rst:662
msgid ""
"An object representing a stream of data.  Repeated calls to the iterator's :"
"meth:`~iterator.__next__` method (or passing it to the built-in function :"
"func:`next`) return successive items in the stream.  When no more data are "
"available a :exc:`StopIteration` exception is raised instead.  At this "
"point, the iterator object is exhausted and any further calls to its :meth:"
"`__next__` method just raise :exc:`StopIteration` again.  Iterators are "
"required to have an :meth:`__iter__` method that returns the iterator object "
"itself so every iterator is also iterable and may be used in most places "
"where other iterables are accepted.  One notable exception is code which "
"attempts multiple iteration passes.  A container object (such as a :class:"
"`list`) produces a fresh new iterator each time you pass it to the :func:"
"`iter` function or use it in a :keyword:`for` loop.  Attempting this with an "
"iterator will just return the same exhausted iterator object used in the "
"previous iteration pass, making it appear like an empty container."
msgstr ""
"Bir veri akışını temsil eden bir nesne.  Yineleyicinin :meth:`~iterator."
"__next__` yöntemine (veya yerleşik :func:`next` işlevine iletilmesi) "
"yinelenen çağrılar, akıştaki ardışık öğeleri döndürür.  Daha fazla veri "
"bulunmadığında, bunun yerine bir :exc:`StopIteration` istisnası "
"oluşturulur.  Bu noktada, yineleyici nesnesi tükenir ve :meth:`__next__` "
"yöntemine yapılan diğer çağrılar yalnızca :exc:`StopIteration` öğesini "
"yeniden yükseltir.  Yineleyicilerin, yineleyici nesnesinin kendisini "
"döndüren bir :meth:`__iter__` yöntemine sahip olmaları gerekir, böylece her "
"yineleyici de yinelenebilir ve diğer yinelenebilirlerin kabul edildiği çoğu "
"yerde kullanılabilir.  Dikkate değer bir istisna, birden çok yineleme "
"geçişini deneyen koddur.  Bir kapsayıcı nesnesi (örneğin bir :class:`list`), "
"onu :func:`iter` işlevine her ilettiğinizde veya onu bir :keyword:`for` "
"döngüsünde kullandığınızda yeni bir yineleyici üretir.  Bunu bir "
"yineleyiciyle denemek, önceki yineleme geçişinde kullanılan aynı tükenmiş "
"yineleyici nesnesini döndürerek boş bir kap gibi görünmesini sağlar."

#: glossary.rst:677
msgid "More information can be found in :ref:`typeiter`."
msgstr "Daha fazla bilgi :ref:`typeiter` içinde bulunabilir."

#: glossary.rst:681
msgid ""
"CPython does not consistently apply the requirement that an iterator define :"
"meth:`__iter__`."
msgstr ""
"CPython, bir yineleyicinin :meth:`__iter__` tanımlaması gereksinimini "
"tutarlı bir şekilde uygulamaz."

#: glossary.rst:683
msgid "key function"
msgstr "anahtar işlev"

#: glossary.rst:685
msgid ""
"A key function or collation function is a callable that returns a value used "
"for sorting or ordering.  For example, :func:`locale.strxfrm` is used to "
"produce a sort key that is aware of locale specific sort conventions."
msgstr ""
"Anahtar işlevi veya harmanlama işlevi, sıralama veya sıralama için "
"kullanılan bir değeri döndüren bir çağrılabilir.  Örneğin, :func:`locale."
"strxfrm`, yerel ayara özgü sıralama kurallarının farkında olan bir sıralama "
"anahtarı üretmek için kullanılır."

#: glossary.rst:690
msgid ""
"A number of tools in Python accept key functions to control how elements are "
"ordered or grouped.  They include :func:`min`, :func:`max`, :func:`sorted`, :"
"meth:`list.sort`, :func:`heapq.merge`, :func:`heapq.nsmallest`, :func:`heapq."
"nlargest`, and :func:`itertools.groupby`."
msgstr ""
"Python'daki bir dizi araç, öğelerin nasıl sıralandığını veya "
"gruplandırıldığını kontrol etmek için temel işlevleri kabul eder.  Bunlar :"
"func:`min`, :func:`max`, :func:`sorted`, :meth:`list.sort`, :func:`heapq."
"merge`, :func:`heapq.nsmallest`, :func:`heapq.nlargest` ve :func:`itertools."
"groupby`."

#: glossary.rst:696
msgid ""
"There are several ways to create a key function.  For example. the :meth:"
"`str.lower` method can serve as a key function for case insensitive sorts.  "
"Alternatively, a key function can be built from a :keyword:`lambda` "
"expression such as ``lambda r: (r[0], r[2])``.  Also, :func:`operator."
"attrgetter`, :func:`operator.itemgetter`, and :func:`operator.methodcaller` "
"are three key function constructors.  See the :ref:`Sorting HOW TO "
"<sortinghowto>` for examples of how to create and use key functions."
msgstr ""
"Bir tuş fonksiyonu oluşturmanın birkaç yolu vardır.  Örneğin. :meth:`str."
"lower` yöntemi, büyük/küçük harfe duyarlı olmayan sıralamalar için bir "
"anahtar fonksiyonu işlevi görebilir.  Alternatif olarak, ``lambda r: (r[0], "
"r[2])`` gibi bir :keyword:`lambda` ifadesinden bir anahtar işlevi "
"oluşturulabilir.  Ayrıca, :func:`~operator.attrgetter`, :func:`~operator."
"itemgetter` ve :func:`~operator.methodcaller` fonksiyonları üç anahtar "
"fonksiyon kurucularıdır.  Anahtar işlevlerin nasıl oluşturulacağı ve "
"kullanılacağına ilişkin örnekler için :ref:`Sorting HOW TO <sortinghowto>` "
"bölümüne bakın."

#: glossary.rst:703
msgid "keyword argument"
msgstr "anahtar kelime argümanı"

#: glossary.rst:994
msgid "See :term:`argument`."
msgstr "Bakınız :term:`argument`."

#: glossary.rst:706
msgid "lambda"
msgstr "lambda"

#: glossary.rst:708
msgid ""
"An anonymous inline function consisting of a single :term:`expression` which "
"is evaluated when the function is called.  The syntax to create a lambda "
"function is ``lambda [parameters]: expression``"
msgstr ""
"İşlev çağrıldığında değerlendirilen tek bir :term:`expression` 'dan oluşan "
"anonim bir satır içi işlev.  Bir lambda işlevi oluşturmak için sözdizimi "
"``lambda [parametreler]: ifade`` şeklindedir"

#: glossary.rst:711
msgid "LBYL"
msgstr "LBYL"

#: glossary.rst:713
msgid ""
"Look before you leap.  This coding style explicitly tests for pre-conditions "
"before making calls or lookups.  This style contrasts with the :term:`EAFP` "
"approach and is characterized by the presence of many :keyword:`if` "
"statements."
msgstr ""
"Zıplamadan önce Bak.  Bu kodlama stili, arama veya arama yapmadan önce ön "
"koşulları açıkça test eder.  Bu stil, :term:`EAFP` yaklaşımıyla çelişir ve "
"birçok :keyword:`if` ifadesinin varlığı ile karakterize edilir."

#: glossary.rst:718
msgid ""
"In a multi-threaded environment, the LBYL approach can risk introducing a "
"race condition between \"the looking\" and \"the leaping\".  For example, "
"the code, ``if key in mapping: return mapping[key]`` can fail if another "
"thread removes *key* from *mapping* after the test, but before the lookup. "
"This issue can be solved with locks or by using the EAFP approach."
msgstr ""
"Çok iş parçacıklı bir ortamda, LBYL yaklaşımı \"bakan\" ve \"sıçrayan\" "
"arasında bir yarış koşulu getirme riskini taşıyabilir.  Örneğin, ``if key in "
"mapping: return mapping[key]`` kodu, testten sonra, ancak aramadan önce "
"başka bir iş parçacığı *eşlemeden* *key* kaldırırsa başarısız olabilir. Bu "
"sorun, kilitlerle veya EAFP yaklaşımı kullanılarak çözülebilir."

#: glossary.rst:723
msgid "locale encoding"
msgstr "yerel kodlama"

#: glossary.rst:725
msgid ""
"On Unix, it is the encoding of the LC_CTYPE locale. It can be set with :func:"
"`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>`."
msgstr ""
"Unix'te, LC_CTYPE yerel ayarının kodlamasıdır. :func:`locale."
"setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>` ile ayarlanabilir."

#: glossary.rst:728
msgid "On Windows, it is the ANSI code page (ex: ``\"cp1252\"``)."
msgstr "Windows'ta bu, ANSI kod sayfasıdır (ör. ``\"cp1252\"``)."

#: glossary.rst:730
msgid ""
"On Android and VxWorks, Python uses ``\"utf-8\"`` as the locale encoding."
msgstr ""
"Android ve VxWorks'te Python, yerel kodlama olarak ``\"utf-8\"`` kullanır."

#: glossary.rst:732
msgid "``locale.getencoding()`` can be used to get the locale encoding."
msgstr "Yerel kodlamayı almak için ``locale.getencoding()`` kullanılabilir."

#: glossary.rst:734
msgid "See also the :term:`filesystem encoding and error handler`."
msgstr "Ayrıca :term:`filesystem encoding and error handler` 'ne bakın."

#: glossary.rst:735
msgid "list"
msgstr "liste"

#: glossary.rst:737
msgid ""
"A built-in Python :term:`sequence`.  Despite its name it is more akin to an "
"array in other languages than to a linked list since access to elements is "
"O(1)."
msgstr ""
"Yerleşik bir Python :term:`dizi`.  Adına rağmen, öğelere erişim O(1) "
"olduğundan, diğer dillerdeki bir diziye, bağlantılı bir listeden daha "
"yakındır."

#: glossary.rst:740
msgid "list comprehension"
msgstr "liste anlama"

#: glossary.rst:742
msgid ""
"A compact way to process all or part of the elements in a sequence and "
"return a list with the results.  ``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]`` generates a list of strings containing even hex "
"numbers (0x..) in the range from 0 to 255. The :keyword:`if` clause is "
"optional.  If omitted, all elements in ``range(256)`` are processed."
msgstr ""
"Bir dizideki öğelerin tümünü veya bir kısmını işlemenin ve sonuçları içeren "
"bir liste döndürmenin kompakt bir yolu.  ``sonuç = ['{:#04x}'.format(x) for "
"range(256) if x % 2 == 0]``, dizinde çift onaltılık sayılar (0x..) içeren "
"bir diziler listesi oluşturur. 0 ile 255 arasındadır. :keyword:`if` yan "
"tümcesi isteğe bağlıdır.  Atlanırsa, \"aralık(256)\" içindeki tüm öğeler "
"işlenir."

#: glossary.rst:748
msgid "loader"
msgstr "yükleyici"

#: glossary.rst:750
msgid ""
"An object that loads a module. It must define a method named :meth:"
"`load_module`. A loader is typically returned by a :term:`finder`. See :pep:"
"`302` for details and :class:`importlib.abc.Loader` for an :term:`abstract "
"base class`."
msgstr ""
"Modül yükleyen bir nesne. :meth:`load_module` adında bir yöntem "
"tanımlamalıdır. Bir yükleyici genellikle bir :term:`finder` ile döndürülür. "
"Ayrıntılar için :pep:`302` ve bir :term:`soyut temel sınıf` için :class:"
"`importlib.abc.Loader` bölümüne bakın."

#: glossary.rst:754
msgid "magic method"
msgstr "sihirli yöntem"

#: glossary.rst:758
msgid "An informal synonym for :term:`special method`."
msgstr ":term:`special method` için gayri resmi bir eşanlamlı."

#: glossary.rst:759
msgid "mapping"
msgstr "haritalama"

#: glossary.rst:761
msgid ""
"A container object that supports arbitrary key lookups and implements the "
"methods specified in the :class:`collections.abc.Mapping` or :class:"
"`collections.abc.MutableMapping` :ref:`abstract base classes <collections-"
"abstract-base-classes>`.  Examples include :class:`dict`, :class:"
"`collections.defaultdict`, :class:`collections.OrderedDict` and :class:"
"`collections.Counter`."
msgstr ""
"Keyfi anahtar aramalarını destekleyen ve :class:`~collections.abc.Mapping` "
"veya :class:`~collections.abc.MutableMapping` :ref:`collections-abstract-"
"base-classes` içinde belirtilen yöntemleri uygulayan bir kapsayıcı nesnesi. "
"Örnekler arasında :class:`dict`, :class:`collections.defaultdict`, :class:"
"`collections.OrderedDict` ve :class:`collections.Counter` sayılabilir."

#: glossary.rst:767
msgid "meta path finder"
msgstr "meta yol bulucu"

#: glossary.rst:769
msgid ""
"A :term:`finder` returned by a search of :data:`sys.meta_path`.  Meta path "
"finders are related to, but different from :term:`path entry finders <path "
"entry finder>`."
msgstr ""
"Bir :term:`finder`, :data:`sys.meta_path` aramasıyla döndürülür.  Meta yol "
"bulucular, :term:`yol girişi bulucuları <path entry finder>` ile "
"ilişkilidir, ancak onlardan farklıdır."

#: glossary.rst:773
msgid ""
"See :class:`importlib.abc.MetaPathFinder` for the methods that meta path "
"finders implement."
msgstr ""
"Meta yol bulucuların uyguladığı yöntemler için :class:`importlib.abc."
"MetaPathFinder` bölümüne bakın."

#: glossary.rst:775
msgid "metaclass"
msgstr "metasınıf"

#: glossary.rst:777
msgid ""
"The class of a class.  Class definitions create a class name, a class "
"dictionary, and a list of base classes.  The metaclass is responsible for "
"taking those three arguments and creating the class.  Most object oriented "
"programming languages provide a default implementation.  What makes Python "
"special is that it is possible to create custom metaclasses.  Most users "
"never need this tool, but when the need arises, metaclasses can provide "
"powerful, elegant solutions.  They have been used for logging attribute "
"access, adding thread-safety, tracking object creation, implementing "
"singletons, and many other tasks."
msgstr ""
"Bir sınıfın sınıfı.  Sınıf tanımları, bir sınıf adı, bir sınıf sözlüğü ve "
"temel sınıfların bir listesini oluşturur.  Metasınıf, bu üç argümanı "
"almaktan ve sınıfı oluşturmaktan sorumludur. Çoğu nesne yönelimli "
"programlama dili, varsayılan bir uygulama sağlar.  Python'u özel yapan şey, "
"özel metasınıflar oluşturmanın mümkün olmasıdır. Çoğu kullanıcı bu araca "
"hiçbir zaman ihtiyaç duymaz, ancak ihtiyaç duyulduğunda, metasınıflar güçlü "
"ve zarif çözümler sağlayabilir.  Nitelik erişimini günlüğe kaydetmek, iş "
"parçacığı güvenliği eklemek, nesne oluşturmayı izlemek, tekilleri uygulamak "
"ve diğer birçok görev için kullanılmışlardır."

#: glossary.rst:787
msgid "More information can be found in :ref:`metaclasses`."
msgstr "Daha fazla bilgi :ref:`metaclasses` içinde bulunabilir."

#: glossary.rst:788
msgid "method"
msgstr "metot"

#: glossary.rst:790
msgid ""
"A function which is defined inside a class body.  If called as an attribute "
"of an instance of that class, the method will get the instance object as its "
"first :term:`argument` (which is usually called ``self``). See :term:"
"`function` and :term:`nested scope`."
msgstr ""
"Bir sınıf gövdesi içinde tanımlanan bir işlev. Bu sınıfın bir örneğinin "
"özniteliği olarak çağrılırsa, yöntem örnek nesnesini ilk :term:`argument` "
"(genellikle ``self`` olarak adlandırılır) olarak alır. Bkz. :term:`function` "
"ve :term:`nested scope`."

#: glossary.rst:794
msgid "method resolution order"
msgstr "metot kalite sıralaması"

#: glossary.rst:796
msgid ""
"Method Resolution Order is the order in which base classes are searched for "
"a member during lookup. See `The Python 2.3 Method Resolution Order <https://"
"www.python.org/download/releases/2.3/mro/>`_ for details of the algorithm "
"used by the Python interpreter since the 2.3 release."
msgstr ""
"Metot Çözüm Sırası, arama sırasında bir üye için temel sınıfların arandığı "
"sıradır. 2.3 sürümünden bu yana Python yorumlayıcısı tarafından kullanılan "
"algoritmanın ayrıntıları için bkz. `The Python 2.3 Method Resolution Order "
"<https://www.python.org/download/releases/2.3/mro/>`_."

#: glossary.rst:800
msgid "module"
msgstr "modül"

#: glossary.rst:802
msgid ""
"An object that serves as an organizational unit of Python code.  Modules "
"have a namespace containing arbitrary Python objects.  Modules are loaded "
"into Python by the process of :term:`importing`."
msgstr ""
"Python kodunun kuruluş birimi olarak hizmet eden bir nesne. Modüller, "
"rastgele Python nesneleri içeren bir ad alanına sahiptir. Modüller, :term:"
"`importing` işlemiyle Python'a yüklenir."

#: glossary.rst:806
msgid "See also :term:`package`."
msgstr "Ayrıca bakınız :term:`package`."

#: glossary.rst:807
msgid "module spec"
msgstr "modül özelliği"

#: glossary.rst:809
msgid ""
"A namespace containing the import-related information used to load a module. "
"An instance of :class:`importlib.machinery.ModuleSpec`."
msgstr ""
"Bir modülü yüklemek için kullanılan içe aktarmayla ilgili bilgileri içeren "
"bir ad alanı. Bir :class:`importlib.machinery.ModuleSpec` örneği."

#: glossary.rst:811
msgid "MRO"
msgstr "MRO"

#: glossary.rst:813
msgid "See :term:`method resolution order`."
msgstr "Bakınız :term:`metot çözüm sırası <method resolution order>`."

#: glossary.rst:814
msgid "mutable"
msgstr "değiştirilebilir"

#: glossary.rst:816
msgid ""
"Mutable objects can change their value but keep their :func:`id`.  See also :"
"term:`immutable`."
msgstr ""
"Değiştirilebilir (mutable) nesneler değerlerini değiştirebilir ancak :func:"
"`idlerini <id>` koruyabilirler. Ayrıca bkz. :term:`immutable`."

#: glossary.rst:818
msgid "named tuple"
msgstr "adlandırılmış demet"

#: glossary.rst:820
msgid ""
"The term \"named tuple\" applies to any type or class that inherits from "
"tuple and whose indexable elements are also accessible using named "
"attributes.  The type or class may have other features as well."
msgstr ""
"\"named tuple\" terimi, demetten miras alan ve dizinlenebilir öğelerine de "
"adlandırılmış nitelikler kullanılarak erişilebilen herhangi bir tür veya "
"sınıf için geçerlidir. Tür veya sınıfın başka özellikleri de olabilir."

#: glossary.rst:824
msgid ""
"Several built-in types are named tuples, including the values returned by :"
"func:`time.localtime` and :func:`os.stat`.  Another example is :data:`sys."
"float_info`::"
msgstr ""
"Çeşitli yerleşik türler, :func:`time.localtime` ve :func:`os.stat` "
"tarafından döndürülen değerler de dahil olmak üzere, tanımlama grupları "
"olarak adlandırılır. Başka bir örnek :data:`sys.float_info`::"

#: glossary.rst:835
msgid ""
"Some named tuples are built-in types (such as the above examples). "
"Alternatively, a named tuple can be created from a regular class definition "
"that inherits from :class:`tuple` and that defines named fields.  Such a "
"class can be written by hand or it can be created with the factory function :"
"func:`collections.namedtuple`.  The latter technique also adds some extra "
"methods that may not be found in hand-written or built-in named tuples."
msgstr ""
"Bazı adlandırılmış demetler yerleşik türlerdir (yukarıdaki örnekler gibi). "
"Alternatif olarak, :class:`tuple` öğesinden miras alan ve adlandırılmış "
"alanları tanımlayan normal bir sınıf tanımından adlandırılmış bir tanımlama "
"grubu oluşturulabilir. Böyle bir sınıf elle yazılabilir veya fabrika işlevi :"
"func:`collections.namedtuple` ile oluşturulabilir. İkinci teknik ayrıca elle "
"yazılmış veya yerleşik adlandırılmış demetlerde bulunmayan bazı ekstra "
"yöntemler ekler."

#: glossary.rst:842
msgid "namespace"
msgstr "ad alanı"

#: glossary.rst:844
msgid ""
"The place where a variable is stored.  Namespaces are implemented as "
"dictionaries.  There are the local, global and built-in namespaces as well "
"as nested namespaces in objects (in methods).  Namespaces support modularity "
"by preventing naming conflicts.  For instance, the functions :func:`builtins."
"open <.open>` and :func:`os.open` are distinguished by their namespaces.  "
"Namespaces also aid readability and maintainability by making it clear which "
"module implements a function.  For instance, writing :func:`random.seed` or :"
"func:`itertools.islice` makes it clear that those functions are implemented "
"by the :mod:`random` and :mod:`itertools` modules, respectively."
msgstr ""
"Değişkenin saklandığı yer. Ad alanları sözlükler olarak uygulanır. "
"Nesnelerde (yöntemlerde) yerel, genel ve yerleşik ad alanlarının yanı sıra "
"iç içe ad alanları vardır. Ad alanları, adlandırma çakışmalarını önleyerek "
"modülerliği destekler. Örneğin, :func:`builtins.open <.open>` ve :func:`os."
"open` işlevleri ad alanlarıyla ayırt edilir. Ad alanları, hangi modülün bir "
"işlevi uyguladığını açıkça belirterek okunabilirliğe ve sürdürülebilirliğe "
"de yardımcı olur. Örneğin, :func:`random.seed` veya :func:`itertools.islice` "
"yazmak, bu işlevlerin sırasıyla :mod:`random` ve :mod:`itertools` modülleri "
"tarafından uygulandığını açıkça gösterir."

#: glossary.rst:854
msgid "namespace package"
msgstr "ad alanı paketi"

#: glossary.rst:856
msgid ""
"A :pep:`420` :term:`package` which serves only as a container for "
"subpackages.  Namespace packages may have no physical representation, and "
"specifically are not like a :term:`regular package` because they have no "
"``__init__.py`` file."
msgstr ""
"A :pep:`420` :term:`package`, yalnızca alt paketler için bir kap olarak "
"hizmet eder. Ad alanı paketlerinin hiçbir fiziksel temsili olmayabilir ve "
"``__init__.py`` dosyası olmadığından özellikle :term:`regular package` gibi "
"değildirler."

#: glossary.rst:861
msgid "See also :term:`module`."
msgstr "Ayrıca bkz. :term:`module`."

#: glossary.rst:862
msgid "nested scope"
msgstr "iç içe kapsam"

#: glossary.rst:864
msgid ""
"The ability to refer to a variable in an enclosing definition.  For "
"instance, a function defined inside another function can refer to variables "
"in the outer function.  Note that nested scopes by default work only for "
"reference and not for assignment.  Local variables both read and write in "
"the innermost scope.  Likewise, global variables read and write to the "
"global namespace.  The :keyword:`nonlocal` allows writing to outer scopes."
msgstr ""
"Kapsamlı bir tanımdaki bir değişkene atıfta bulunma yeteneği. Örneğin, başka "
"bir fonksiyonun içinde tanımlanan bir fonksiyon, dış fonksiyondaki "
"değişkenlere atıfta bulunabilir. İç içe kapsamların varsayılan olarak "
"yalnızca başvuru için çalıştığını ve atama için çalışmadığını unutmayın. "
"Yerel değişkenler en içteki kapsamda hem okur hem de yazar. Benzer şekilde, "
"global değişkenler global ad alanını okur ve yazar. :keyword:`nonlocal`, dış "
"kapsamlara yazmaya izin verir."

#: glossary.rst:871
msgid "new-style class"
msgstr "yeni stil sınıf"

#: glossary.rst:873
msgid ""
"Old name for the flavor of classes now used for all class objects.  In "
"earlier Python versions, only new-style classes could use Python's newer, "
"versatile features like :attr:`~object.__slots__`, descriptors, properties, :"
"meth:`__getattribute__`, class methods, and static methods."
msgstr ""
"Artık tüm sınıf nesneleri için kullanılan sınıfların lezzetinin eski adı. "
"Önceki Python sürümlerinde, yalnızca yeni stil sınıfları Python'un :attr:"
"`~object.__slots__`, tanımlayıcılar, özellikler, :meth:`__getattribute__`, "
"sınıf yöntemleri ve statik yöntemler gibi daha yeni, çok yönlü özelliklerini "
"kullanabilirdi."

#: glossary.rst:877
msgid "object"
msgstr "obje"

#: glossary.rst:879
msgid ""
"Any data with state (attributes or value) and defined behavior (methods).  "
"Also the ultimate base class of any :term:`new-style class`."
msgstr ""
"Durum (öznitelikler veya değer) ve tanımlanmış davranış (yöntemler) içeren "
"herhangi bir veri. Ayrıca herhangi bir :term:`yeni tarz sınıfın <new-style "
"class>` nihai temel sınıfı."

#: glossary.rst:882
msgid "package"
msgstr "paket"

#: glossary.rst:884
msgid ""
"A Python :term:`module` which can contain submodules or recursively, "
"subpackages.  Technically, a package is a Python module with a ``__path__`` "
"attribute."
msgstr ""
"Alt modüller veya yinelemeli olarak alt paketler içerebilen bir Python :term:"
"`module`. Teknik olarak bir paket, ``__path__`` özniteliğine sahip bir "
"Python modülüdür."

#: glossary.rst:888
msgid "See also :term:`regular package` and :term:`namespace package`."
msgstr "Ayrıca bkz. :term:`regular package` ve :term:`namespace package`."

#: glossary.rst:889
msgid "parameter"
msgstr "parametre"

#: glossary.rst:891
msgid ""
"A named entity in a :term:`function` (or method) definition that specifies "
"an :term:`argument` (or in some cases, arguments) that the function can "
"accept.  There are five kinds of parameter:"
msgstr ""
"Bir :term:`function` (veya yöntem) tanımında, işlevin kabul edebileceği bir :"
"term:`argument` (veya bazı durumlarda, argümanlar) belirten adlandırılmış "
"bir varlık.  Beş çeşit parametre vardır:"

#: glossary.rst:895
msgid ""
":dfn:`positional-or-keyword`: specifies an argument that can be passed "
"either :term:`positionally <argument>` or as a :term:`keyword argument "
"<argument>`.  This is the default kind of parameter, for example *foo* and "
"*bar* in the following::"
msgstr ""
":dfn:`positional-or-keyword`: :term:`pozisyonel <argument>` veya bir :term:"
"`keyword argümanı <argument>` olarak iletilebilen bir argüman belirtir. Bu, "
"varsayılan parametre türüdür, örneğin aşağıdakilerde *foo* ve *bar*::"

#: glossary.rst:904
msgid ""
":dfn:`positional-only`: specifies an argument that can be supplied only by "
"position. Positional-only parameters can be defined by including a ``/`` "
"character in the parameter list of the function definition after them, for "
"example *posonly1* and *posonly2* in the following::"
msgstr ""
":dfn:`positional-only`: yalnızca konuma göre sağlanabilen bir argüman "
"belirtir. Yalnızca konumsal parametreler, onlardan sonra fonksiyon tanımının "
"parametre listesine bir ``/`` karakteri eklenerek tanımlanabilir, örneğin "
"aşağıdakilerde *posonly1* ve *posonly2*::"

#: glossary.rst:913
msgid ""
":dfn:`keyword-only`: specifies an argument that can be supplied only by "
"keyword.  Keyword-only parameters can be defined by including a single var-"
"positional parameter or bare ``*`` in the parameter list of the function "
"definition before them, for example *kw_only1* and *kw_only2* in the "
"following::"
msgstr ""
":dfn:`keyword-only`: sadece anahtar kelime ile sağlanabilen bir argüman "
"belirtir. Yalnızca anahtar kelime (keyword-only) parametreleri, onlardan "
"önceki fonksiyon tanımının parametre listesine tek bir değişken konumlu "
"parametre veya çıplak ``*`` dahil edilerek tanımlanabilir, örneğin "
"aşağıdakilerde *kw_only1* ve *kw_only2*::"

#: glossary.rst:921
msgid ""
":dfn:`var-positional`: specifies that an arbitrary sequence of positional "
"arguments can be provided (in addition to any positional arguments already "
"accepted by other parameters).  Such a parameter can be defined by "
"prepending the parameter name with ``*``, for example *args* in the "
"following::"
msgstr ""
":dfn:`var-positional`: keyfi bir pozisyonel argüman dizisinin "
"sağlanabileceğini belirtir (diğer parametreler tarafından zaten kabul "
"edilmiş herhangi bir konumsal argümana ek olarak). Böyle bir parametre, "
"parametre adının başına ``*`` eklenerek tanımlanabilir, örneğin "
"aşağıdakilerde *args*::"

#: glossary.rst:929
msgid ""
":dfn:`var-keyword`: specifies that arbitrarily many keyword arguments can be "
"provided (in addition to any keyword arguments already accepted by other "
"parameters).  Such a parameter can be defined by prepending the parameter "
"name with ``**``, for example *kwargs* in the example above."
msgstr ""
":dfn:`var-keyword`: keyfi olarak birçok anahtar kelime argümanının "
"sağlanabileceğini belirtir (diğer parametreler tarafından zaten kabul edilen "
"herhangi bir anahtar kelime argümanına ek olarak). Böyle bir parametre, "
"parametre adının başına ``**``, örneğin yukarıdaki örnekte *kwargs* "
"eklenerek tanımlanabilir."

#: glossary.rst:935
msgid ""
"Parameters can specify both optional and required arguments, as well as "
"default values for some optional arguments."
msgstr ""
"Parametreler, hem isteğe bağlı hem de gerekli argümanleri ve ayrıca bazı "
"isteğe bağlı bağımsız değişkenler için varsayılan değerleri belirtebilir."

#: glossary.rst:938
msgid ""
"See also the :term:`argument` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"the :class:`inspect.Parameter` class, the :ref:`function` section, and :pep:"
"`362`."
msgstr ""
"Ayrıca bkz. :term:`argüman <argument>`, :ref:`argümanlar ve parametreler "
"arasındaki fark <faq-argument-vs-parameter>`, :class:`inspect.Parameter`, :"
"ref:`function` ve :pep:`362`."

#: glossary.rst:942
msgid "path entry"
msgstr "yol girişi"

#: glossary.rst:944
msgid ""
"A single location on the :term:`import path` which the :term:`path based "
"finder` consults to find modules for importing."
msgstr ""
":term:`path based finder` içe aktarma modüllerini bulmak için başvurduğu :"
"term:`import path` üzerindeki tek bir konum."

#: glossary.rst:946
msgid "path entry finder"
msgstr "yol girişi bulucu"

#: glossary.rst:948
msgid ""
"A :term:`finder` returned by a callable on :data:`sys.path_hooks` (i.e. a :"
"term:`path entry hook`) which knows how to locate modules given a :term:"
"`path entry`."
msgstr ""
"Bir :term:`finder` :data:`sys.path_hooks` (yani bir :term:`yol giriş "
"kancası`) üzerinde bir çağrılabilir tarafından döndürülür ve :term:`path "
"entry` verilen modüllerin nasıl bulunacağını bilir."

#: glossary.rst:952
msgid ""
"See :class:`importlib.abc.PathEntryFinder` for the methods that path entry "
"finders implement."
msgstr ""
"Yol girişi bulucularının uyguladığı yöntemler için :class:`importlib.abc."
"PathEntryFinder` bölümüne bakın."

#: glossary.rst:954
msgid "path entry hook"
msgstr "yol giriş kancası"

#: glossary.rst:956
msgid ""
"A callable on the :data:`sys.path_hook` list which returns a :term:`path "
"entry finder` if it knows how to find modules on a specific :term:`path "
"entry`."
msgstr ""
":data:`sys.path_hook` listesinde, belirli bir :term:`yol girişindeki <path "
"entry>` modülleri nasıl bulacağını biliyorsa, bir :term:`yol girişi bulucu "
"<path entry finder>` döndüren bir çağrılabilir."

#: glossary.rst:959
msgid "path based finder"
msgstr "yol tabanlı bulucu"

#: glossary.rst:961
msgid ""
"One of the default :term:`meta path finders <meta path finder>` which "
"searches an :term:`import path` for modules."
msgstr ""
"Modüller için bir :term:`import path` arayan varsayılan :term:`meta yol "
"buluculardan <meta path finder>` biri."

#: glossary.rst:963
msgid "path-like object"
msgstr "yol benzeri nesne"

#: glossary.rst:965
msgid ""
"An object representing a file system path. A path-like object is either a :"
"class:`str` or :class:`bytes` object representing a path, or an object "
"implementing the :class:`os.PathLike` protocol. An object that supports the :"
"class:`os.PathLike` protocol can be converted to a :class:`str` or :class:"
"`bytes` file system path by calling the :func:`os.fspath` function; :func:"
"`os.fsdecode` and :func:`os.fsencode` can be used to guarantee a :class:"
"`str` or :class:`bytes` result instead, respectively. Introduced by :pep:"
"`519`."
msgstr ""
"Bir dosya sistemi yolunu temsil eden bir nesne. Yol benzeri bir nesne, bir "
"yolu temsil eden bir :class:`str` veya :class:`bytes` nesnesi veya :class:"
"`os.PathLike` protokolünü uygulayan bir nesnedir. :class:`os.PathLike` "
"protokolünü destekleyen bir nesne, :func:`os.fspath` işlevi çağrılarak bir :"
"class:`str` veya :class:`bytes` dosya sistemi yoluna dönüştürülebilir; :func:"
"`os.fsdecode` ve :func:`os.fsencode`, bunun yerine sırasıyla :class:`str` "
"veya :class:`bytes` sonucunu garanti etmek için kullanılabilir. :pep:`519` "
"tarafından tanıtıldı."

#: glossary.rst:973
msgid "PEP"
msgstr "PEP"

#: glossary.rst:975
msgid ""
"Python Enhancement Proposal. A PEP is a design document providing "
"information to the Python community, or describing a new feature for Python "
"or its processes or environment. PEPs should provide a concise technical "
"specification and a rationale for proposed features."
msgstr ""
"Python Geliştirme Önerisi. PEP, Python topluluğuna bilgi sağlayan veya "
"Python veya süreçleri ya da ortamı için yeni bir özelliği açıklayan bir "
"tasarım belgesidir. PEP'ler, önerilen özellikler için özlü bir teknik "
"şartname ve bir gerekçe sağlamalıdır."

#: glossary.rst:981
msgid ""
"PEPs are intended to be the primary mechanisms for proposing major new "
"features, for collecting community input on an issue, and for documenting "
"the design decisions that have gone into Python. The PEP author is "
"responsible for building consensus within the community and documenting "
"dissenting opinions."
msgstr ""
"PEP'lerin, önemli yeni özellikler önermek, bir sorun hakkında topluluk "
"girdisi toplamak ve Python'a giren tasarım kararlarını belgelemek için "
"birincil mekanizmalar olması amaçlanmıştır. PEP yazarı, topluluk içinde "
"fikir birliği oluşturmaktan ve muhalif görüşleri belgelemekten sorumludur."

#: glossary.rst:987
msgid "See :pep:`1`."
msgstr "Bakınız :pep:`1`."

#: glossary.rst:988
msgid "portion"
msgstr "kısım"

#: glossary.rst:990
msgid ""
"A set of files in a single directory (possibly stored in a zip file) that "
"contribute to a namespace package, as defined in :pep:`420`."
msgstr ""
":pep:`420` içinde tanımlandığı gibi, bir ad alanı paketine katkıda bulunan "
"tek bir dizindeki (muhtemelen bir zip dosyasında depolanan) bir dizi dosya."

#: glossary.rst:992
msgid "positional argument"
msgstr "konumsal argüman"

#: glossary.rst:995
msgid "provisional API"
msgstr "geçici API"

#: glossary.rst:997
msgid ""
"A provisional API is one which has been deliberately excluded from the "
"standard library's backwards compatibility guarantees.  While major changes "
"to such interfaces are not expected, as long as they are marked provisional, "
"backwards incompatible changes (up to and including removal of the "
"interface) may occur if deemed necessary by core developers.  Such changes "
"will not be made gratuitously -- they will occur only if serious fundamental "
"flaws are uncovered that were missed prior to the inclusion of the API."
msgstr ""
"Geçici bir API, standart kitaplığın geriye dönük uyumluluk garantilerinden "
"kasıtlı olarak hariç tutulan bir API'dir. Bu tür arayüzlerde büyük "
"değişiklikler beklenmese de, geçici olarak işaretlendikleri sürece, çekirdek "
"geliştiriciler tarafından gerekli görüldüğü takdirde geriye dönük uyumsuz "
"değişiklikler (arayüzün kaldırılmasına kadar ve buna kadar) meydana "
"gelebilir. Bu tür değişiklikler karşılıksız yapılmayacaktır - bunlar "
"yalnızca API'nin eklenmesinden önce gözden kaçan ciddi temel kusurlar ortaya "
"çıkarsa gerçekleşecektir."

#: glossary.rst:1006
msgid ""
"Even for provisional APIs, backwards incompatible changes are seen as a "
"\"solution of last resort\" - every attempt will still be made to find a "
"backwards compatible resolution to any identified problems."
msgstr ""
"Geçici API'ler için bile, geriye dönük uyumsuz değişiklikler \"son çare "
"çözümü\" olarak görülür - tanımlanan herhangi bir soruna geriye dönük uyumlu "
"bir çözüm bulmak için her türlü girişimde bulunulacaktır."

#: glossary.rst:1010
msgid ""
"This process allows the standard library to continue to evolve over time, "
"without locking in problematic design errors for extended periods of time.  "
"See :pep:`411` for more details."
msgstr ""
"Bu süreç, standart kitaplığın, uzun süreler boyunca sorunlu tasarım "
"hatalarına kilitlenmeden zaman içinde gelişmeye devam etmesini sağlar. Daha "
"fazla ayrıntı için bkz. :pep:`411`."

#: glossary.rst:1013
msgid "provisional package"
msgstr "geçici paket"

#: glossary.rst:1015
msgid "See :term:`provisional API`."
msgstr "Bakınız :term:`provisional API`."

#: glossary.rst:1016
msgid "Python 3000"
msgstr "Python 3000"

#: glossary.rst:1018
msgid ""
"Nickname for the Python 3.x release line (coined long ago when the release "
"of version 3 was something in the distant future.)  This is also abbreviated "
"\"Py3k\"."
msgstr ""
"Python 3.x sürüm satırının takma adı (uzun zaman önce sürüm 3'ün piyasaya "
"sürülmesi uzak bir gelecekte olduğu zaman ortaya çıktı.) Bu aynı zamanda "
"\"Py3k\" olarak da kısaltılır."

#: glossary.rst:1021
msgid "Pythonic"
msgstr "Pythonic"

#: glossary.rst:1023
msgid ""
"An idea or piece of code which closely follows the most common idioms of the "
"Python language, rather than implementing code using concepts common to "
"other languages.  For example, a common idiom in Python is to loop over all "
"elements of an iterable using a :keyword:`for` statement.  Many other "
"languages don't have this type of construct, so people unfamiliar with "
"Python sometimes use a numerical counter instead::"
msgstr ""
"Diğer dillerde ortak kavramları kullanarak kod uygulamak yerine Python "
"dilinin en yaygın deyimlerini yakından takip eden bir fikir veya kod "
"parçası. Örneğin, Python'da yaygın bir deyim, bir :keyword:`for` ifadesi "
"kullanarak yinelenebilir bir öğenin tüm öğeleri üzerinde döngü "
"oluşturmaktır. Diğer birçok dilde bu tür bir yapı yoktur, bu nedenle "
"Python'a aşina olmayan kişiler bazen bunun yerine sayısal bir sayaç kullanır:"

#: glossary.rst:1033
msgid "As opposed to the cleaner, Pythonic method::"
msgstr "Temizleyicinin aksine, Pythonic yöntemi::"

#: glossary.rst:1037
msgid "qualified name"
msgstr "nitelikli isim"

#: glossary.rst:1039
msgid ""
"A dotted name showing the \"path\" from a module's global scope to a class, "
"function or method defined in that module, as defined in :pep:`3155`.  For "
"top-level functions and classes, the qualified name is the same as the "
"object's name::"
msgstr ""
":pep:`3155` içinde tanımlandığı gibi, bir modülün genel kapsamından o "
"modülde tanımlanan bir sınıfa, işleve veya yönteme giden \"yolu\" gösteren "
"noktalı ad. Üst düzey işlevler ve sınıflar için nitelikli ad, nesnenin "
"adıyla aynıdır::"

#: glossary.rst:1056
msgid ""
"When used to refer to modules, the *fully qualified name* means the entire "
"dotted path to the module, including any parent packages, e.g. ``email.mime."
"text``::"
msgstr ""
"Modüllere atıfta bulunmak için kullanıldığında, *tam nitelenmiş ad*, "
"herhangi bir üst paket de dahil olmak üzere, modüle giden tüm noktalı yol "
"anlamına gelir, örn. ``email.mime.text``::"

#: glossary.rst:1063
msgid "reference count"
msgstr "referans sayısı"

#: glossary.rst:1065
msgid ""
"The number of references to an object.  When the reference count of an "
"object drops to zero, it is deallocated.  Reference counting is generally "
"not visible to Python code, but it is a key element of the :term:`CPython` "
"implementation.  Programmers can call the :func:`sys.getrefcount` function "
"to return the reference count for a particular object."
msgstr ""
"Bir nesneye yapılan başvuruların sayısı. Bir nesnenin referans sayısı sıfıra "
"düştüğünde, yeniden konumlandırılır. Referans sayımı genellikle Python kodu "
"tarafından görülmez, ancak :term:`CPython` uygulamasının önemli bir "
"öğesidir. Programcılar, belirli bir nesne için başvuru sayısını döndürmek "
"için :func:`sys.getrefcount` işlevini çağırabilir."

#: glossary.rst:1071
msgid "regular package"
msgstr "sürekli paketleme"

#: glossary.rst:1073
msgid ""
"A traditional :term:`package`, such as a directory containing an ``__init__."
"py`` file."
msgstr ""
"``__init__.py`` dosyası içeren bir dizin gibi geleneksel bir :term:`package`."

#: glossary.rst:1076
msgid "See also :term:`namespace package`."
msgstr "Ayrıca bkz. :term:`ad alanı paketi`."

#: glossary.rst:1077
msgid "__slots__"
msgstr "__slots__"

#: glossary.rst:1079
msgid ""
"A declaration inside a class that saves memory by pre-declaring space for "
"instance attributes and eliminating instance dictionaries.  Though popular, "
"the technique is somewhat tricky to get right and is best reserved for rare "
"cases where there are large numbers of instances in a memory-critical "
"application."
msgstr ""
"Örnek öznitelikleri için önceden yer bildirerek ve örnek sözlüklerini "
"ortadan kaldırarak bellekten tasarruf sağlayan bir sınıf içindeki bildirim. "
"Popüler olmasına rağmen, tekniğin doğru olması biraz zor ve en iyi, bellek "
"açısından kritik bir uygulamada çok sayıda örneğin bulunduğu nadir durumlar "
"için ayrılmıştır."

#: glossary.rst:1084
msgid "sequence"
msgstr "dizi"

#: glossary.rst:1086
msgid ""
"An :term:`iterable` which supports efficient element access using integer "
"indices via the :meth:`__getitem__` special method and defines a :meth:"
"`__len__` method that returns the length of the sequence. Some built-in "
"sequence types are :class:`list`, :class:`str`, :class:`tuple`, and :class:"
"`bytes`. Note that :class:`dict` also supports :meth:`__getitem__` and :meth:"
"`__len__`, but is considered a mapping rather than a sequence because the "
"lookups use arbitrary :term:`immutable` keys rather than integers."
msgstr ""
":meth:`__getitem__` özel yöntemi aracılığıyla tamsayı dizinlerini kullanarak "
"verimli öğe erişimini destekleyen ve dizinin uzunluğunu döndüren bir :meth:"
"`__len__` yöntemini tanımlayan bir :term:`iterable`. Bazı yerleşik dizi "
"türleri şunlardır: :class:`list`, :class:`str`, :class:`tuple` ve :class:"
"`bytes`. :class:`dict` ayrıca :meth:`__getitem__` ve :meth:`__len__` 'i de "
"desteklediğine dikkat edin, ancak aramalar tamsayılar yerine rastgele :term:"
"`immutable` anahtarları kullandığından bir diziden ziyade bir eşleme olarak "
"kabul edilir."

#: glossary.rst:1095
msgid ""
"The :class:`collections.abc.Sequence` abstract base class defines a much "
"richer interface that goes beyond just :meth:`__getitem__` and :meth:"
"`__len__`, adding :meth:`count`, :meth:`index`, :meth:`__contains__`, and :"
"meth:`__reversed__`. Types that implement this expanded interface can be "
"registered explicitly using :func:`~abc.ABCMeta.register`."
msgstr ""
":class:`collections.abc.Sequence` soyut temel sınıfı;, :meth:`count`, :meth:"
"`index`, :meth:`__contains__`, ve :meth:`__reversed__` ekleyerek sadece :"
"meth:`__getitem__` ve :meth:`__len__` 'in ötesine geçen çok daha zengin bir "
"arayüzü tanımlar. Bu genişletilmiş arabirimi uygulayan türler, :func:`~abc."
"ABCMeta.register` kullanılarak açıkça kaydedilebilir."

#: glossary.rst:1102
msgid "set comprehension"
msgstr "anlamak"

#: glossary.rst:1104
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a set with the results. ``results = {c for c in 'abracadabra' if c "
"not in 'abc'}`` generates the set of strings ``{'r', 'd'}``.  See :ref:"
"`comprehensions`."
msgstr ""
"Öğelerin tümünü veya bir kısmını yinelenebilir bir şekilde işlemenin ve "
"sonuçlarla birlikte bir küme döndürmenin kompakt bir yolu. ``results = {c "
"for c in 'abracadabra' if c not in 'abc'}``, ``{'r', 'd'}`` dizelerini "
"oluşturur. Bakınız :ref:`comprehensions`."

#: glossary.rst:1108
msgid "single dispatch"
msgstr "tek sevk"

#: glossary.rst:1110
msgid ""
"A form of :term:`generic function` dispatch where the implementation is "
"chosen based on the type of a single argument."
msgstr ""
"Uygulamanın tek bir argüman türüne göre seçildiği bir :term:`generic "
"function` gönderimi biçimi."

#: glossary.rst:1112
msgid "slice"
msgstr "parçalamak"

#: glossary.rst:1114
msgid ""
"An object usually containing a portion of a :term:`sequence`.  A slice is "
"created using the subscript notation, ``[]`` with colons between numbers "
"when several are given, such as in ``variable_name[1:3:5]``.  The bracket "
"(subscript) notation uses :class:`slice` objects internally."
msgstr ""
"Genellikle bir :term:`sequence` 'nin bir bölümünü içeren bir nesne. Bir "
"dilim, örneğin ``variable_name[1:3:5]`` 'de olduğu gibi, birkaç tane "
"verildiğinde, sayılar arasında iki nokta üst üste koyarak, ``[]`` alt simge "
"gösterimi kullanılarak oluşturulur. Köşeli ayraç (alt simge) gösterimi, "
"dahili olarak :class:`slice` nesnelerini kullanır."

#: glossary.rst:1118
msgid "special method"
msgstr "özel metod"

#: glossary.rst:1122
msgid ""
"A method that is called implicitly by Python to execute a certain operation "
"on a type, such as addition.  Such methods have names starting and ending "
"with double underscores.  Special methods are documented in :ref:"
"`specialnames`."
msgstr ""
"Toplama gibi bir tür üzerinde belirli bir işlemi yürütmek için Python "
"tarafından örtük olarak çağrılan bir yöntem. Bu tür yöntemlerin çift alt "
"çizgi ile başlayan ve biten adları vardır. Özel yöntemler :ref:"
"`specialnames` içinde belgelenmiştir."

#: glossary.rst:1126
msgid "statement"
msgstr "ifade (değer döndürmez)"

#: glossary.rst:1128
msgid ""
"A statement is part of a suite (a \"block\" of code).  A statement is either "
"an :term:`expression` or one of several constructs with a keyword, such as :"
"keyword:`if`, :keyword:`while` or :keyword:`for`."
msgstr ""
"Bir ifade, bir paketin parçasıdır (kod \"bloğu\"). Bir ifade, bir :term:"
"`expression` veya :keyword:`if`, :keyword:`while` veya :keyword:`for` gibi "
"bir anahtar kelimeye sahip birkaç yapıdan biridir."

#: glossary.rst:1131
msgid "strong reference"
msgstr "güçlü referans"

#: glossary.rst:1133
msgid ""
"In Python's C API, a strong reference is a reference to an object which "
"increments the object's reference count when it is created and decrements "
"the object's reference count when it is deleted."
msgstr ""
"Python'un C API'sinde, güçlü bir referans, oluşturulduğunda nesnenin "
"referans sayısını artıran ve silindiğinde nesnenin referans sayısını azaltan "
"bir nesneye yapılan referanstır."

#: glossary.rst:1137
msgid ""
"The :c:func:`Py_NewRef` function can be used to create a strong reference to "
"an object. Usually, the :c:func:`Py_DECREF` function must be called on the "
"strong reference before exiting the scope of the strong reference, to avoid "
"leaking one reference."
msgstr ""
":c:func:`Py_NewRef` fonksiyonu, bir nesneye güçlü bir başvuru oluşturmak "
"için kullanılabilir. Genellikle :c:func:`Py_DECREF` fonksiyonu, bir "
"referansın sızmasını önlemek için güçlü referans kapsamından çıkmadan önce "
"güçlü referansta çağrılmalıdır."

#: glossary.rst:1142
msgid "See also :term:`borrowed reference`."
msgstr "Ayrıca bkz. :term:`ödünç alınan referans <borrowed reference>`."

#: glossary.rst:1143
msgid "text encoding"
msgstr "yazı çözümleme"

#: glossary.rst:1145
msgid ""
"A string in Python is a sequence of Unicode code points (in range "
"``U+0000``--``U+10FFFF``). To store or transfer a string, it needs to be "
"serialized as a sequence of bytes."
msgstr ""
"Python'da bir dize, bir Unicode kod noktaları dizisidir (``U+0000``--"
"``U+10FFFF`` aralığında). Bir dizeyi depolamak veya aktarmak için, bir bayt "
"dizisi olarak seri hale getirilmesi gerekir."

#: glossary.rst:1149
msgid ""
"Serializing a string into a sequence of bytes is known as \"encoding\", and "
"recreating the string from the sequence of bytes is known as \"decoding\"."
msgstr ""
"Bir dizeyi bir bayt dizisi halinde seri hale getirmek \"kodlama (encoding)\" "
"olarak bilinir ve dizeyi bayt dizisinden yeniden oluşturmak \"kod çözme "
"(decoding)\" olarak bilinir."

#: glossary.rst:1152
msgid ""
"There are a variety of different text serialization :ref:`codecs <standard-"
"encodings>`, which are collectively referred to as \"text encodings\"."
msgstr ""
"Toplu olarak \"metin kodlamaları\" olarak adlandırılan çeşitli farklı metin "
"serileştirme :ref:`kodekleri <standard-encodings>` vardır."

#: glossary.rst:1155
msgid "text file"
msgstr "yazı dosyası"

#: glossary.rst:1157
msgid ""
"A :term:`file object` able to read and write :class:`str` objects. Often, a "
"text file actually accesses a byte-oriented datastream and handles the :term:"
"`text encoding` automatically. Examples of text files are files opened in "
"text mode (``'r'`` or ``'w'``), :data:`sys.stdin`, :data:`sys.stdout`, and "
"instances of :class:`io.StringIO`."
msgstr ""
"A :term:`file object` :class:`str` nesnelerini okuyabilir ve yazabilir. Çoğu "
"zaman, bir metin dosyası aslında bir bayt yönelimli veri akışına erişir ve "
"otomatik olarak :term:`text encoding` işler. Metin dosyalarına örnek olarak "
"metin modunda açılan dosyalar (``'r'`` veya ``'w'``), :data:`sys.stdin`, :"
"data:`sys.stdout` ve :class:`io.StringIO` örnekleri verilebilir."

#: glossary.rst:1164
msgid ""
"See also :term:`binary file` for a file object able to read and write :term:"
"`bytes-like objects <bytes-like object>`."
msgstr ""
"Ayrıca :term:`ikili dosyaları <binary file>` okuyabilen ve yazabilen bir "
"dosya nesnesi için :term:`bayt benzeri nesnelere <bytes-like object>` bakın."

#: glossary.rst:1166
msgid "triple-quoted string"
msgstr "üç tırnaklı dize"

#: glossary.rst:1168
msgid ""
"A string which is bound by three instances of either a quotation mark (\") "
"or an apostrophe (').  While they don't provide any functionality not "
"available with single-quoted strings, they are useful for a number of "
"reasons.  They allow you to include unescaped single and double quotes "
"within a string and they can span multiple lines without the use of the "
"continuation character, making them especially useful when writing "
"docstrings."
msgstr ""
"Üç tırnak işareti (\") veya kesme işareti (') ile sınırlanan bir dize. Tek "
"tırnaklı dizelerde bulunmayan herhangi bir işlevsellik sağlamasalar da, "
"birkaç nedenden dolayı faydalıdırlar. bir dizeye çıkışsız tek ve çift tırnak "
"eklemeniz gerekir ve bunlar, devam karakterini kullanmadan birden çok satıra "
"yayılabilir, bu da onları özellikle belge dizileri yazarken kullanışlı hale "
"getirir."

#: glossary.rst:1175
msgid "type"
msgstr "tip"

#: glossary.rst:1177
msgid ""
"The type of a Python object determines what kind of object it is; every "
"object has a type.  An object's type is accessible as its :attr:`~instance."
"__class__` attribute or can be retrieved with ``type(obj)``."
msgstr ""
"Bir Python nesnesinin türü, onun ne tür bir nesne olduğunu belirler; her "
"nesnenin bir türü vardır. Bir nesnenin tipine :attr:`~instance.__class__` "
"niteliği ile erişilebilir veya ``type(obj)`` ile alınabilir."

#: glossary.rst:1181
msgid "type alias"
msgstr "tip takma adı"

#: glossary.rst:1183
msgid "A synonym for a type, created by assigning the type to an identifier."
msgstr "Bir tanımlayıcıya tür atanarak oluşturulan, bir tür için eş anlamlı."

#: glossary.rst:1185
msgid ""
"Type aliases are useful for simplifying :term:`type hints <type hint>`. For "
"example::"
msgstr ""
"Tür takma adları, :term:`tür ipuçlarını <type hint>` basitleştirmek için "
"kullanışlıdır. Örneğin::"

#: glossary.rst:1192
msgid "could be made more readable like this::"
msgstr "bu şekilde daha okunaklı hale getirilebilir::"

#: glossary.rst:1213
msgid "See :mod:`typing` and :pep:`484`, which describe this functionality."
msgstr "Bu işlevi açıklayan :mod:`typing` ve :pep:`484` bölümlerine bakın."

#: glossary.rst:1200
msgid "type hint"
msgstr "tür ipucu"

#: glossary.rst:1202
msgid ""
"An :term:`annotation` that specifies the expected type for a variable, a "
"class attribute, or a function parameter or return value."
msgstr ""
"Bir değişken, bir sınıf niteliği veya bir işlev parametresi veya dönüş "
"değeri için beklenen türü belirten bir :term:`ek açıklama <annotation>`."

#: glossary.rst:1205
msgid ""
"Type hints are optional and are not enforced by Python but they are useful "
"to static type analysis tools, and aid IDEs with code completion and "
"refactoring."
msgstr ""
"Tür ipuçları isteğe bağlıdır ve Python tarafından uygulanmaz, ancak bunlar "
"statik tip analiz araçları için faydalıdır ve kod tamamlama ve yeniden "
"düzenleme ile IDE'lere yardımcı olur."

#: glossary.rst:1209
msgid ""
"Type hints of global variables, class attributes, and functions, but not "
"local variables, can be accessed using :func:`typing.get_type_hints`."
msgstr ""
"Genel değişkenlerin, sınıf özniteliklerinin ve işlevlerin tür ipuçlarına, "
"yerel değişkenlere değil, :func:`typing.get_type_hints` kullanılarak "
"erişilebilir."

#: glossary.rst:1214
msgid "universal newlines"
msgstr "evrensel yeni satırlar"

#: glossary.rst:1216
msgid ""
"A manner of interpreting text streams in which all of the following are "
"recognized as ending a line: the Unix end-of-line convention ``'\\n'``, the "
"Windows convention ``'\\r\\n'``, and the old Macintosh convention "
"``'\\r'``.  See :pep:`278` and :pep:`3116`, as well as :func:`bytes."
"splitlines` for an additional use."
msgstr ""
"Aşağıdakilerin tümünün bir satırın bitişi olarak kabul edildiği metin "
"akışlarını yorumlamanın bir yolu: Unix satır sonu kuralı ``\\n'``, Windows "
"kuralı ``'\\r\\n'``, ve eski Macintosh kuralı ``'\\r'``. Ek bir kullanım "
"için :pep:`278` ve :pep:`3116` ve ayrıca :func:`bytes.splitlines` bakın."

#: glossary.rst:1221
msgid "variable annotation"
msgstr "değişken açıklama"

#: glossary.rst:1223
msgid "An :term:`annotation` of a variable or a class attribute."
msgstr ""
"Bir değişkenin veya bir sınıf özniteliğinin :term:`ek açıklaması "
"<annotation>`."

#: glossary.rst:1225
msgid ""
"When annotating a variable or a class attribute, assignment is optional::"
msgstr ""
"Bir değişkene veya sınıf niteliğine açıklama eklerken atama isteğe bağlıdır::"

#: glossary.rst:1230
msgid ""
"Variable annotations are usually used for :term:`type hints <type hint>`: "
"for example this variable is expected to take :class:`int` values::"
msgstr ""
"Değişken açıklamaları genellikle :term:`tür ipuçları <type hint>` için "
"kullanılır: örneğin, bu değişkenin :class:`int` değerlerini alması beklenir::"

#: glossary.rst:1236
msgid "Variable annotation syntax is explained in section :ref:`annassign`."
msgstr "Değişken açıklama sözdizimi :ref:`annassign` bölümünde açıklanmıştır."

#: glossary.rst:1238
msgid ""
"See :term:`function annotation`, :pep:`484` and :pep:`526`, which describe "
"this functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"Bu işlevi açıklayan; :term:`function annotation`, :pep:`484` ve :pep:`526` "
"bölümlerine bakın. Ek açıklamalarla çalışmaya ilişkin en iyi uygulamalar "
"için ayrıca bkz. :ref:`annotations-howto`."

#: glossary.rst:1242
msgid "virtual environment"
msgstr "sanal ortam"

#: glossary.rst:1244
msgid ""
"A cooperatively isolated runtime environment that allows Python users and "
"applications to install and upgrade Python distribution packages without "
"interfering with the behaviour of other Python applications running on the "
"same system."
msgstr ""
"Python kullanıcılarının ve uygulamalarının, aynı sistem üzerinde çalışan "
"diğer Python uygulamalarının davranışına müdahale etmeden Python dağıtım "
"paketlerini kurmasına ve yükseltmesine olanak tanıyan, işbirliği içinde "
"yalıtılmış bir çalışma zamanı ortamı."

#: glossary.rst:1249
msgid "See also :mod:`venv`."
msgstr "Ayrıca bakınız :mod:`venv`."

#: glossary.rst:1250
msgid "virtual machine"
msgstr "sanal makine"

#: glossary.rst:1252
msgid ""
"A computer defined entirely in software.  Python's virtual machine executes "
"the :term:`bytecode` emitted by the bytecode compiler."
msgstr ""
"Tamamen yazılımla tanımlanmış bir bilgisayar. Python'un sanal makinesi, bayt "
"kodu derleyicisi tarafından yayınlanan :term:`bytecode` 'u çalıştırır."

#: glossary.rst:1254
msgid "Zen of Python"
msgstr "Python'un Zen'i"

#: glossary.rst:1256
msgid ""
"Listing of Python design principles and philosophies that are helpful in "
"understanding and using the language.  The listing can be found by typing "
"\"``import this``\" at the interactive prompt."
msgstr ""
"Dili anlamaya ve kullanmaya yardımcı olan Python tasarım ilkeleri ve "
"felsefelerinin listesi. Liste, etkileşimli komut isteminde \"``import "
"this``\" yazarak bulunabilir."

#~ msgid "coercion"
#~ msgstr "zorlama"

#~ msgid ""
#~ "The implicit conversion of an instance of one type to another during an "
#~ "operation which involves two arguments of the same type.  For example, "
#~ "``int(3.15)`` converts the floating point number to the integer ``3``, "
#~ "but in ``3+4.5``, each argument is of a different type (one int, one "
#~ "float), and both must be converted to the same type before they can be "
#~ "added or it will raise a :exc:`TypeError`.  Without coercion, all "
#~ "arguments of even compatible types would have to be normalized to the "
#~ "same value by the programmer, e.g., ``float(3)+4.5`` rather than just "
#~ "``3+4.5``."
#~ msgstr ""
#~ "Aynı türden iki argüman içeren bir işlem sırasında bir tür örneğinin "
#~ "diğerine örtük olarak dönüştürülmesi.  Örneğin, ``int(3.15)``, kayan "
#~ "noktalı sayıyı ``3`` tamsayısına dönüştürür, ancak ``3+4.5`` 'te her "
#~ "argüman farklı türdedir (bir int, bir kayan nokta), ve her ikisi de "
#~ "eklenmeden önce aynı türe dönüştürülmelidir, aksi takdirde bir :exc:"
#~ "`TypeError` yükseltir. Zorlama olmadan, uyumlu türlerin bile tüm "
#~ "argümanlarının programcı tarafından aynı değere normalleştirilmesi "
#~ "gerekir, örneğin: ``3+4,5`` yerine ``float(3)+4,5``."

#~ msgid ""
#~ "Python uses the :term:`filesystem encoding and error handler` to convert "
#~ "between Unicode filenames and bytes filenames."
#~ msgstr ""
#~ "Python, Unicode dosya adları ile bayt dosya adları arasında dönüştürme "
#~ "yapmak için :term:`filesystem encoding and error handler` kullanır."

#~ msgid "A codec which encodes Unicode strings to bytes."
#~ msgstr "Unicode dizelerini baytlara kodlayan bir codec bileşeni."
